{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-08-18T01:05:44.364374+00:00",
  "repo": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "Needs PR",
      "description": "Needs a text proposal in a Pull Request",
      "color": "5319e7"
    },
    {
      "name": "Need Discussion",
      "description": "The Issue needs discussion to determine next step",
      "color": "CD1DFD"
    },
    {
      "name": "PR exists",
      "description": "",
      "color": "c5def5"
    },
    {
      "name": "Wait for DTLS 1.3 discussion",
      "description": "",
      "color": "006b75"
    }
  ],
  "issues": [
    {
      "number": 8,
      "id": "MDU6SXNzdWU3ODY5Njc3MDk=",
      "title": "Clarify SCTP + SCPT-AUTH replay protection",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/8",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Recevied this comment from Mohamed Boucadair\r\n\r\nI have a question about this text: \r\n\r\n   As SCTP with SCTP-AUTH provides replay protection for DATA chunks,\r\n   DTLS/SCTP provides replay protection for user messages.\r\n\r\nRFC4895 says the following: \r\n\r\n   Because SCTP already has a built-in mechanism that handles the\r\n   reception of duplicated chunks, the presented solution makes use of\r\n   this functionality and does not provide a method to avoid replay\r\n   attacks by itself.\r\n\r\nWith that in mind, what is meant by \"SCTP with SCTP-AUTH\"?\r\n\r\nSo we should clarify what we refer to when stating that replay protection exists prior to the decryption of DTLS records. ",
      "createdAt": "2021-01-15T15:10:38Z",
      "updatedAt": "2021-02-19T12:12:52Z",
      "closedAt": "2021-02-19T12:12:52Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Believe this issue is resolved now with the improved text. Closing issue.",
          "createdAt": "2021-02-19T12:12:52Z",
          "updatedAt": "2021-02-19T12:12:52Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWU4MTE1MzE3Nzc=",
      "title": "Don't refer to partial message API",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/11",
      "state": "CLOSED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "SCTP stacks can handle large received messages. There is no requirement to use the SocketAPI, although we make sure things can be implemented using it...",
      "createdAt": "2021-02-18T22:46:40Z",
      "updatedAt": "2021-06-17T12:21:32Z",
      "closedAt": "2021-06-17T12:21:32Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So we can probably update the text to be more generic in the requirement on messages sizes. Possibly we could move the whole discussion about the interaction between the different layer's buffering requirement into an appendix.",
          "createdAt": "2021-02-19T12:15:48Z",
          "updatedAt": "2021-02-19T12:15:48Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "Reference to Socket API has been removed from the text in commitment 8d09ca0...",
          "createdAt": "2021-06-17T12:21:32Z",
          "updatedAt": "2021-06-17T12:21:32Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU4MTE1MzUzMDI=",
      "title": "Allow re-negotiation for DTLS 1.2",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/12",
      "state": "CLOSED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "To allow refreshing the keys.",
      "createdAt": "2021-02-18T22:53:49Z",
      "updatedAt": "2021-06-30T10:55:20Z",
      "closedAt": "2021-06-30T10:55:20Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Renegotiation seems to be disabled by default  in many DTLS implementation due to security problems. Might be ok to use as long as RFC 5476 is mandates, but my understanding is some security isssues still remain. Also not perfect to rely on parts of TLS libraries that are normally disables.\r\n\r\nhttps://security.stackexchange.com/questions/24554/should-i-use-ssl-tls-renegotiation/230327#230327\r\n\r\nI made a PR that allows renegotiation and added security considerations.",
          "createdAt": "2021-02-19T06:15:39Z",
          "updatedAt": "2021-02-19T06:15:39Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So, the PR was #21 and that was merged after direct discussion and review. ",
          "createdAt": "2021-02-19T12:18:20Z",
          "updatedAt": "2021-02-19T12:18:20Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Issue ready to be closed in my view. ",
          "createdAt": "2021-06-21T12:46:32Z",
          "updatedAt": "2021-06-21T12:46:32Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU4MTE1MzY3NDE=",
      "title": "Allow key updates for DTLS 1.3",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/13",
      "state": "CLOSED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We need the sender dry dance here (similar to the re-negotiation), I guess.",
      "createdAt": "2021-02-18T22:56:44Z",
      "updatedAt": "2021-06-30T10:55:29Z",
      "closedAt": "2021-06-30T10:55:29Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "This was allowed but not described. I made a PR describing this. A problem is that KeyUpdate in DTLS 1.3 does not change the exporter master secret so we might need to add some sequence number to the exporter....",
          "createdAt": "2021-02-19T06:12:27Z",
          "updatedAt": "2021-02-19T06:12:27Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So the PR #21 does the information text. But the question about exporter remains. ",
          "createdAt": "2021-02-19T12:19:57Z",
          "updatedAt": "2021-02-19T12:19:57Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, if new keys are needed we would need to add a sequence to the label or the context of the exporter. EAP-TLS 1.3 wanted to put a type code in the context but TLS people rather wanted concatenation with the label. (just a matter principles)\r\n\r\nMight also be the case the we don't derive any new key for SCTP-AUTH and uses the same key during the lifetime of the DTLS connection. Untruncated HMAC-256 is very strong and has 256-bit key. (need to check these details, but I think it is a 32 byte key and tag). Without PFS the only reason to rekey would be AEAD limits. ",
          "createdAt": "2021-02-19T12:48:15Z",
          "updatedAt": "2021-02-19T12:48:15Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This was allowed but not described. I made a PR describing this. A problem is that KeyUpdate in DTLS 1.3 does not change the exporter master secret so we might need to add some sequence number to the exporter....\r\n\r\nInteresting. Do you know why that master secret is not changed?",
          "createdAt": "2021-02-19T13:31:24Z",
          "updatedAt": "2021-02-19T13:31:24Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Might also be the case the we don't derive any new key for SCTP-AUTH and uses the same key during the lifetime of the DTLS connection. Untruncated HMAC-256 is very strong and has 256-bit key. (need to check these details, but I think it is a 32 byte key and tag). Without PFS the only reason to rekey would be AEAD limits.\r\n\r\nOK. But why do we perform a change of key material used by DTLS layer and not perform one at SCTP layer?\r\n\r\n",
          "createdAt": "2021-02-19T13:39:52Z",
          "updatedAt": "2021-02-19T13:39:52Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The TLS AEAD (e.g. AES-GCM) need to change keys quite frequently. TLS 1.3 has put very strict limits of around s^23 records (or something like that). The HMAC-SHA256 is mush stronger and could be much longer without changign keys (for this reasons).\r\n\r\nYou might still want to change both keys to limit the effect of key leakage. That would with current TLS 1.3 require terminating the TLS connection and do resumption.",
          "createdAt": "2021-02-19T14:06:08Z",
          "updatedAt": "2021-02-19T14:06:08Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't know for certain why the key is not changed but I can speculate.\r\n\r\nThe renegotiation in earlier versions was basically a handshake inside the connection theoretically allowing renegotiation of all parameters. It has been troubled with a lot of security issues, partly because it is big and complex. It seems to be disables in most libraries by default, but I don't know how severe the remaining security problems are.\r\n\r\nGiven this, I think the TLS working group wanted something small and simple that they could prove the security of. Also web connections are typically not that long. Some use cases of the Exported like EAP-TLS use the exporter once and then closes the connection. I guess nobody required this property when TLS 1.3 was designed.",
          "createdAt": "2021-02-19T14:12:43Z",
          "updatedAt": "2021-02-19T14:12:43Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't know for certain why the key is not changed but I can speculate.\r\n> \r\n> The renegotiation in earlier versions was basically a handshake inside the connection theoretically allowing renegotiation of all parameters. It has been troubled with a lot of security issues, partly because it is big and complex. It seems to be disables in most libraries by default, but I don't know how severe the remaining security problems are.\r\n> \r\n> Given this, I think the TLS working group wanted something small and simple that they could prove the security of. Also web connections are typically not that long. Some use cases of the Exported like EAP-TLS use the exporter once and then closes the connection. I guess nobody required this property when TLS 1.3 was designed.\r\n\r\nThank you very much for the explanation.",
          "createdAt": "2021-02-19T14:28:19Z",
          "updatedAt": "2021-02-19T14:28:19Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The TLS AEAD (e.g. AES-GCM) need to change keys quite frequently. TLS 1.3 has put very strict limits of around s^23 records (or something like that). The HMAC-SHA256 is mush stronger and could be much longer without changign keys (for this reasons).\r\n> \r\nOK.\r\n> You might still want to change both keys to limit the effect of key leakage. That would with current TLS 1.3 require terminating the TLS connection and do resumption.\r\n\r\nSure. Thanks for the clarification.\r\n\r\nI was just looking for symmetry between\r\n\r\n1. DTLS 1.2 where a renegotiation is performed to refresh keys\r\n2. DTLS 1.3 where re-keying is performed to refresh keys\r\n\r\nand updating the SCTP level key for 1. but not for 2.",
          "createdAt": "2021-02-19T14:34:11Z",
          "updatedAt": "2021-02-19T14:36:37Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So SCTP-AUTH rekeys on DTLS connection renegotiation. Which will mean never for DTLS 1.3 unless there are future extensions to enable it. While it can occurr for DTLS 1.2. If that is correctly summarized I think this issue can be closed.",
          "createdAt": "2021-06-21T12:51:53Z",
          "updatedAt": "2021-06-21T12:51:53Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU4MTE1Mzg1MzE=",
      "title": "An application cannot control SCTP level revoking",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/14",
      "state": "CLOSED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tuexen"
      ],
      "labels": [
        "Needs PR"
      ],
      "body": "",
      "createdAt": "2021-02-18T23:00:25Z",
      "updatedAt": "2021-07-06T07:50:22Z",
      "closedAt": "2021-07-06T07:50:22Z",
      "comments": [
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "```\r\nTo prevent DTLS from discarding DTLS user messages while it is shutting down,\r\na CloseNotify message MUST only be sent after all outstanding SCTP user\r\nmessages have been acknowledged by the SCTP peer and MUST NOT be\r\nrevoked by the SCTP peer.\u00b6\r\n```\r\ndoesn't make sense. At least it needs rewording.",
          "createdAt": "2021-02-18T23:01:47Z",
          "updatedAt": "2021-02-18T23:01:47Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "That text was in RFC 6083.\r\n\r\nTo my understanding the issue here is that if the DTLS layer sends a protected user message  and immediately after that does SCTP association close, then if that close is acted on the DTLS record may not have been completely delivered. Which if partial delivered records are provided to the received implementation and then forces decryption and integrity verification, then the receiver will have DTLS connection failure also at the end. Thus, for a controlled close, each peer needs to first stop sending data, then verify that the data has been delivered on all streams before it does an close on the SCTP association. \r\n\r\nSo yes, this do need an reformulation. ",
          "createdAt": "2021-02-19T12:26:03Z",
          "updatedAt": "2021-02-19T12:26:03Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ahh, I see. Now I remember. That is the generic formulation for the sender dry dance.... The reason for this is that you need to avoid the DTLS layer to drop messages due to non-expected epoch values. So the sender sends everything with the old epoch, waits until the cum ack goes by (this is the revoking part) and then sends they new epoch. On the receiver side when getting the first first message for the new epoch, the receiver must empty the receive buffer first.\r\nThe point here is that only messages on stream 0 are in sequence...\r\nI think this dance is still needed, but John thinks different. I'll open an issue for discussing this.",
          "createdAt": "2021-02-19T12:48:16Z",
          "updatedAt": "2021-02-19T12:48:16Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I think this comes down to how strict the DTLS stack will be with epochs for individual records close to the change of keys. I think we really don't want epoch changes between DTLS records within a protected user message. So the sender would need to complete the protection operation of user messages being protected, then perform the key change, then it can process new messages. Which from a sender perspective introduce some delay but not horribly much. \r\n\r\n1. Indicated need to rekey, or renegotiation message received.\r\n2. Lock for accepting new user messages\r\n3. Empty sending queue, i.e. all data delivered to SCTP. \r\n4. Perform rekeying (may include message exchange with peer)\r\n5. Unlock for new messages.\r\n\r\nI think the receiver side is much harder if one can't retrieve the previous key for a short duration until one have ensured that each individual protected user message protected by the old key have been processed. We have to take into account that user messages on different streams may be down prioritized or subject to packet losses require retransmission.  ",
          "createdAt": "2021-02-19T15:05:32Z",
          "updatedAt": "2021-02-19T15:05:32Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think this comes down to how strict the DTLS stack will be with epochs for individual records close to the change of keys. I think we really don't want epoch changes between DTLS records within a protected user message. So the sender would need to complete the protection operation of user messages being protected, then perform the key change, then it can process new messages. Which from a sender perspective introduce some delay but not horribly much.\r\n> \r\n> 1. Indicated need to rekey, or renegotiation message received.\r\n> 2. Lock for accepting new user messages\r\n> 3. Empty sending queue, i.e. all data delivered to SCTP.\r\n> 4. Perform rekeying (may include message exchange with peer)\r\n> 5. Unlock for new messages.\r\n> \r\n> I think the receiver side is much harder if one can't retrieve the previous key for a short duration until one have ensured that each individual protected user message protected by the old key have been processed. We have to take into account that user messages on different streams may be down prioritized or subject to packet losses require retransmission.\r\n\r\nAs I said, we need to drain the sender side (which is ensuring nothing is buffered anymore in the SCTP layer; when using the socket API, this is waiting for the sender dry event). Then send the new message. On the receiver side when getting this new message, buffer it, read all other messages from SCTP, and finally process it. This way we can make sure all oder messages are processed.\r\n\r\nBTW: the sender dry event was defined for exactly this use...",
          "createdAt": "2021-02-19T15:15:46Z",
          "updatedAt": "2021-02-19T15:16:48Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Okay, I think we need to investigate if we have two modes of operation here. We have the guaranteed to work, which is to drain the queue, but can cause impact on the upper layer protocol as we might introduce some delay when messages are queue while performing the drain operation. The second one is to know that the peer supports processing the previous epoch for a while, so that one can just switch key on the next user message one starts sending. \r\n\r\nBoth of these would still have issues issues with very long user messages. So I think we need more thinking on this issues. ",
          "createdAt": "2021-02-22T09:40:50Z",
          "updatedAt": "2021-02-22T09:40:50Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Issue #25 is related to this discussion. ",
          "createdAt": "2021-02-22T09:41:51Z",
          "updatedAt": "2021-02-22T09:41:51Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "The text needs reformulation. @tuexen will reword this to be clearer about the need for doing draining before closing the SCTP association. ",
          "createdAt": "2021-06-30T08:41:54Z",
          "updatedAt": "2021-06-30T08:41:54Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU4MTE1NDc0NDE=",
      "title": "IANA Section needs to be completed for Adaptation Layer Indication",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/15",
      "state": "CLOSED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tuexen",
        "gloinul"
      ],
      "labels": [
        "Needs PR"
      ],
      "body": "Use an adaptation layer indication",
      "createdAt": "2021-02-18T23:16:09Z",
      "updatedAt": "2021-06-30T09:21:41Z",
      "closedAt": "2021-06-30T09:21:41Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Yes, this has been accepted among the authors, and the removal of the DTLS-supported option has been done in PR #18.\r\n\r\nDoesn't the IANA section for the Adaptation layer need a bit more text? ",
          "createdAt": "2021-02-19T12:28:51Z",
          "updatedAt": "2021-02-19T12:28:51Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Normally I provide the table entry to be added, but I don't know how to do tables in Markdown, according to the markdown spec in https://spec.commonmark.org/0.29/.",
          "createdAt": "2021-02-19T13:08:16Z",
          "updatedAt": "2021-02-19T13:08:16Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So if you want to make a table, then it is more a question of how kramdown handles this. \r\n\r\nDepending on what you want to accomplish. I noticed that HTTP/3 spec has a table in this section:\r\n\r\nhttps://www.ietf.org/archive/id/draft-ietf-quic-http-34.html#name-http-framing-layer\r\n\r\nThe markdown source for that table is the below. \r\nhttps://github.com/quicwg/base-drafts/blob/master/draft-ietf-quic-http.md\r\n\r\n\r\n`| Frame          | Control Stream | Request Stream | Push Stream | Section                  |`\r\n`| -------------- | -------------- | -------------- | ----------- | ------------------------ |`\r\n`| DATA           | No             | Yes            | Yes         | {{frame-data}}           |`\r\n`| HEADERS        | No             | Yes            | Yes         | {{frame-headers}}        |`\r\n`| CANCEL_PUSH    | Yes            | No             | No          | {{frame-cancel-push}}    |`\r\n`| SETTINGS       | Yes (1)        | No             | No          | {{frame-settings}}       |`\r\n`| PUSH_PROMISE   | No             | Yes            | No          | {{frame-push-promise}}   |`\r\n`| GOAWAY         | Yes            | No             | No          | {{frame-goaway}}         |`\r\n`| MAX_PUSH_ID    | Yes            | No             | No          | {{frame-max-push-id}}    |`\r\n`| Reserved       | Yes            | Yes            | Yes         | {{frame-reserved}}       |`\r\n`{: #stream-frame-mapping title=\"HTTP/3 Frames and Stream Type Overview\"}`",
          "createdAt": "2021-02-19T15:17:11Z",
          "updatedAt": "2021-02-19T15:21:54Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "A new file containing the markdown format \"Adaptation_layer_indication.md\" has been added for proposal to IANA.",
          "createdAt": "2021-06-17T12:23:29Z",
          "updatedAt": "2021-06-17T12:23:29Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Okay, this needs further work to create a complete IANA section for the Adaptation Layer Indication. Proposal is a start but needs more work.",
          "createdAt": "2021-06-21T12:56:54Z",
          "updatedAt": "2021-06-21T12:56:54Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU4MTE1OTIzODI=",
      "title": "AUTH related issues",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/16",
      "state": "CLOSED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tuexen"
      ],
      "labels": [
        "Needs PR"
      ],
      "body": "1. Only SHA-1 is mandatory to implement.\r\n2. SHA-1 can't be disabled via the socket API for the algorithm requested to be used by the peer.\r\n3. The AUTH negotiation relies on an acceptable mandatory to implement algorithm.\r\n4. There is no socket option to query which algorithm is used to send AUTH chunks.\r\n5. What about SHA-384 and SHA-512?\r\n\r\n1.-3. could be addressed by requiring that SCTP AUTH used SHA-256 instead of SHA-1 as mandatory to implement. 4. Can easily be addressed by adding another socket option. It would be nice to address 5., but that is not necessary.\r\n",
      "createdAt": "2021-02-19T00:54:54Z",
      "updatedAt": "2021-07-12T11:44:43Z",
      "closedAt": "2021-07-12T11:44:43Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "5. Might make sense to register some of SHA-384, SHA-512, SHAKE128, SHAKE256, but not required for RFC6083bis. SHA-384 is required for compliance with US CNSA suite. ",
          "createdAt": "2021-02-22T10:17:47Z",
          "updatedAt": "2021-02-22T10:17:47Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "How to deal with this needs further discussion, even if the main part is a separate update of SCTP-AUTH to define those algorithms. ",
          "createdAt": "2021-06-21T12:58:14Z",
          "updatedAt": "2021-06-21T12:58:14Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Let see if we can conclude on this issue. I think what we say is the following.\r\n\r\nRFC6083bis can mandate that one uses a SCTP-AUTH implementation that supports SHA-256 and that it prioritize that over SHA-1. \r\n\r\nThe socket API is lacking functionality to verify that SHA-256 was chosen to be used, but technically this specification can mandate that one verify that choice and if not abort the SCTP connection. \r\n\r\nOutside of the scope of this document it would be desirable that the following happened.\r\n\r\nSCTP-AUTH update (RFC4895bis) that implements the following:\r\n- Updates the mandatory to implement algorithms and recommended priorities between them.\r\n- Define additional algorithms e.g. SHA-384, SHA-512, SHAKE128, SHAKE256\r\n\r\nSCTP Socket API update\r\n - Improved functionality for prioritizing algorithms and control action or verify choice after handshake.\r\n\r\nDoes anyone see an issue with simply continue with the current method of simply mandating the algorithm support? ",
          "createdAt": "2021-06-23T09:58:08Z",
          "updatedAt": "2021-06-23T09:58:08Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with updating RFC 4895bis, but we currently have RFC 4960bis and the NAT document in TSVWG. My experience is, that TSVWG can handle one SCTP document at a time well. More are difficult. So it may take a while until we can work on 4895bis.\r\n\r\nRFC 4895bis does specify SHA-256 and the Socket API can handle it. It can also handle priorities of different algorithms. So we just need to use a working that SHA-256 must be supported and negotiated. Right now, we can't avoid SHA-1 also to be listed as supported. So setting SHA-256 with higher priority is  covered (and default in FreeBSD). We just need a way to check what SHA-256 will actually be used. I think we can add the required socket API stuff in this document. This is simple to do and I'm willing to propose the `Socket API Considerations` section. Then we are completely covered without relying on other documents. OK?\r\n",
          "createdAt": "2021-06-23T11:30:06Z",
          "updatedAt": "2021-06-23T11:30:06Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Yes, I am fine with adding a SocketAPI consideration. ",
          "createdAt": "2021-06-23T13:04:55Z",
          "updatedAt": "2021-06-23T13:04:55Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "\"RFC6083bis can mandate that one uses a SCTP-AUTH implementation that supports SHA-256 and that it prioritize that over SHA-1.\r\n\r\nThe socket API is lacking functionality to verify that SHA-256 was chosen to be used, but technically this specification can mandate that one verify that choice and if not abort the SCTP connection.\"\r\n\r\nAllowing negotiation of SHA-1 and then abort if it is chosen seems a bit werid. That is also what the current draft says.\r\n\r\nWouldn't it be better to say that when RFC6083bis is used, then SHA-1 shall not be in the HMAC-ALGO parameter? ",
          "createdAt": "2021-07-09T15:31:13Z",
          "updatedAt": "2021-07-09T15:31:13Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> \"RFC6083bis can mandate that one uses a SCTP-AUTH implementation that supports SHA-256 and that it prioritize that over SHA-1.\r\n> \r\n> The socket API is lacking functionality to verify that SHA-256 was chosen to be used, but technically this specification can mandate that one verify that choice and if not abort the SCTP connection.\"\r\n> \r\n> Allowing negotiation of SHA-1 and then abort if it is chosen seems a bit werid. That is also what the current draft says.\r\n> \r\n> Wouldn't it be better to say that when RFC6083bis is used, then SHA-1 shall not be in the HMAC-ALGO parameter?\r\n\r\nTo avoid interoperability problems, SHA-1 is a MUST to implement and offer. See [RFC 4895](https://datatracker.ietf.org/doc/html/rfc4895#section-3.3) for the protocol and you can also not disabled it via the API as specified in [RFC 6458](https://datatracker.ietf.org/doc/html/rfc6458#section-8.1.17). If you are not listing `SCTP_AUTH_HMAC_ID_SHA1`, the `IPPROTO_SCTP` level socket option `SCTP_HMAC_IDENT` will fail to set the parameters.\r\n\r\nSo we need to do the negotiate with `SCTP_AUTH_HMAC_ID_SHA1` dance and lateron check that we are only using `SCTP_AUTH_HMAC_ID_SHA256`.",
          "createdAt": "2021-07-09T16:07:56Z",
          "updatedAt": "2021-07-09T16:07:56Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWU4MTE2MDU1MTk=",
      "title": "Fallback?",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/17",
      "state": "CLOSED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tuexen"
      ],
      "labels": [],
      "body": "```\r\nIf the peer replies with an INIT-ACK not containing all DTLS/SCTP\r\nMandatory Options, the Client can decide to keep on working with\r\nRFC 6083 fallaback, plain data only, or to ABORT the association.\r\n```\r\nHow does this work? If the `RANDOM`, `CHUNKS`, or `HMAC-ALGO` parameter is missing, RFC 6083 does not work. So the only possibility is that `ADAPTATION-LAYER-INDICATION` is\r\nmissing or only SHA-1 is offered. That would mean RFC 6083 is used in combination with DTLS 1.2 or DTLS 1.3. I would vote for ABORTing. In the other cases, aren't we providing a way for downgrade attacks (SHA-256 -> SHA-1)? ",
      "createdAt": "2021-02-19T01:27:25Z",
      "updatedAt": "2021-02-22T15:58:46Z",
      "closedAt": "2021-02-22T15:58:46Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So, I  would note that the first section discuss the risks of fallback and recommend against it and requiring an explicit policy setting to enable it. Yes, it implies risking downgrade. \r\n\r\nThis section discusses how an endpoint supporting this specification can fallback to follow the DTLS/SCTP behavior in RFC 6083. It is recommended to define a setting that represents the policy to allow fallback or not. However, the possibility to use fallback is based on the ULP can operate using user messages that are no longer than 16383 bytes. Fallback is NOT RECOMMEND to be enabled as it enables downgrade to weaker algorithms and versions of DTLS.\r\n\r\nHowever, there are likely some transition cases that are going to need this. So doing RFC6083 with DTLS 1.2 or 1.3 is clearly possible. But the text do need a bit of update due to the change. ",
          "createdAt": "2021-02-19T15:35:43Z",
          "updatedAt": "2021-02-19T15:35:43Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Simplified the text to be more correct. I think the high level is correct now. ",
          "createdAt": "2021-02-22T15:58:46Z",
          "updatedAt": "2021-02-22T15:58:46Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU4MTE2MjMxMDg=",
      "title": "Usage of SHA-1 in RFC 6083",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/19",
      "state": "CLOSED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Why is\r\n```\r\nFor an RFC 6083 client it is likely that the preferred HMAC-ALGO indicates SHA-1.\r\n```\r\ntrue? RFC 6083 does not make a statement...",
      "createdAt": "2021-02-19T02:15:31Z",
      "updatedAt": "2021-02-22T15:57:48Z",
      "closedAt": "2021-02-22T15:57:48Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So that statement is based on that SHA-1 is mandatory to implement in 4895 and thus will be included in the algorithm list.",
          "createdAt": "2021-02-19T15:37:12Z",
          "updatedAt": "2021-02-19T15:37:12Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You are correct, that SHA-1 is the only mandatory to implement algorithm, but SHA-256 is also defined. FreeBSD supports both and prefers SHA-256. So when using only FreeBSD machines with RFC 6083, SHA-256 will be used. Linux only implements SHA-1. So if a FreeBSD machine talks to a Linux machine, SHA-1 will be used. There is no statement in RFC 6083 or RFC 4895 that SHA-1 is preferred. The point is: RFC 6083 make no statement and leaves the choice to the SCTP stack.",
          "createdAt": "2021-02-19T18:23:24Z",
          "updatedAt": "2021-02-19T18:23:24Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Understand then lets change this sentence.",
          "createdAt": "2021-02-22T09:19:37Z",
          "updatedAt": "2021-02-22T09:19:37Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "PR merged that addresses this issue.",
          "createdAt": "2021-02-22T15:57:48Z",
          "updatedAt": "2021-02-22T15:57:48Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU4MTE3MTI3NzA=",
      "title": "Rekeying in DTLS 1.2",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/22",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Renegotiation seems to be disables in a lot of libraries.\r\n\r\nhttps://security.stackexchange.com/questions/24554/should-i-use-ssl-tls-renegotiation/230327#230327\r\n\r\nMight be ok as long as RFC 5746 is used,\r\n\r\nhttps://tools.ietf.org/html/rfc5746\r\n\r\nbut there are still attacks and weaknesses remaining. Not sure how severe the attacks are. But that the feature seems to be disables by default is quite bad. Such corners of the code base is not reviewed much and might contain other bugs and implementation weaknesses....\r\n\r\n\r\n",
      "createdAt": "2021-02-19T05:42:27Z",
      "updatedAt": "2021-06-30T10:55:37Z",
      "closedAt": "2021-06-30T10:55:37Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I think this issue has been handled. \r\n@emanjon can this issue be closed?",
          "createdAt": "2021-06-23T09:47:57Z",
          "updatedAt": "2021-06-23T09:47:57Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU4MTE3MTQ5NjQ=",
      "title": "Rekying in DTLS 1.3",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/23",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "DTLS 1.3 removed renegotiation and replaces it with symmetric Post-Handshake KeyUpdate.\r\n\r\nKeyUpdate provides less security properties than rerunning Diffie-Hellman. This might be ok, but the properties are below what government requirements stipulate for IPsec.\r\n\r\nKeyUpdate in DTLS 1.3 does not update the exporter_master_secret. Any update of keys for SCTP-AUTH needs to be done by adding some information to the exporter label.....",
      "createdAt": "2021-02-19T05:46:45Z",
      "updatedAt": "2021-06-30T10:55:46Z",
      "closedAt": "2021-06-30T10:55:46Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "@emanjon can this issue be closed?",
          "createdAt": "2021-06-23T09:47:26Z",
          "updatedAt": "2021-06-23T09:47:26Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So what do we do with the keys used by SCTP AUTH, which are based on data from an exporter?",
          "createdAt": "2021-06-23T10:41:51Z",
          "updatedAt": "2021-06-23T10:41:51Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Is this last issue resolved by #43? ",
          "createdAt": "2021-06-29T14:23:29Z",
          "updatedAt": "2021-06-29T14:23:29Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "MDU6SXNzdWU4MTE3MjAyOTI=",
      "title": "Limitation for key material lifetime",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/24",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "emanjon"
      ],
      "labels": [
        "Needs PR"
      ],
      "body": "DTLS 1.2 (from RFC 5246):\r\n  \"An upper limit of 24 hours is suggested for\r\n   session ID lifetimes, since an attacker who obtains a master_secret\r\n   may be able to impersonate the compromised party until the\r\n   corresponding session ID is retired.\"\r\n\r\nDTLS 1.3 (from RFC 8446):\r\n  \"It is RECOMMENDED that\r\n   implementations place limits on the total lifetime of such keying\r\n   material; these limits should take into account the lifetime of the\r\n   peer's certificate, the likelihood of intervening revocation, and the\r\n   time since the peer's online CertificateVerify signature.\"\r\n\r\n64-bit sequence numers should not be a problem as they require 2^32 records every second for 136 years to overflow. They also reset after KeyUpdate or renegotiation. \r\n\r\nI assume DTLS/SCTP need to override the DTLS 1.2 lifetime of 24 hours.\r\n\r\n\r\n",
      "createdAt": "2021-02-19T05:56:37Z",
      "updatedAt": "2021-06-30T09:21:59Z",
      "closedAt": "2021-06-30T09:21:59Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "How long lived would the DTLS/SCTP connections be? days, weeks, months, years?\r\n",
          "createdAt": "2021-02-19T06:16:19Z",
          "updatedAt": "2021-02-19T06:16:19Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Likely months or years.\r\n\r\n- We need to state explicitly we are not following the DTLS 1.2 suggestion. Can be motivated by the fact that DTLS 1.3 removes it.\r\n- We need to discuss and maybe give recommendations for how often to require authentication, rekeying, and ECDHE, and any lifetime restrictions on key material apply.\r\n\r\nIn DTLS 1.2,\r\nRenegotiation gives authentication, rekeying, and ECDHE\r\n\r\nIn DTLS 1.3,\r\nPost-Handshake KeyUpdate at any time gives rekeying\r\nPost-Handshake authenticated  can be done at any time\r\nECDHE cannot be done inside the conenction and require resumption, which might cause disruptions.      \r\n\r\n",
          "createdAt": "2021-02-19T11:04:05Z",
          "updatedAt": "2021-02-19T11:04:05Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "3GPP protocols are semipermanent and assumes a standing association between nodes.",
          "createdAt": "2021-02-19T11:06:51Z",
          "updatedAt": "2021-02-19T11:06:51Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Might be possible to extend TLS 1.3 with a PSF Post-Handshake rekeying mechanism in the future.\r\n",
          "createdAt": "2021-02-19T11:17:13Z",
          "updatedAt": "2021-02-19T11:17:13Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I assume DTLS/SCTP need to override the DTLS 1.2 lifetime of 24 hours.\r\n\r\nIsn't it a statement about the lifetime of the session ID when used for session resumption and not a statement about the lifetime of a TLS connection?\r\n",
          "createdAt": "2021-02-19T11:45:45Z",
          "updatedAt": "2021-02-19T11:45:45Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "\"An upper limit of 24 hours is suggested for\r\nsession ID lifetimes, since an attacker who obtains a master_secret\r\nmay be able to impersonate the compromised party until the\r\ncorresponding session ID is retired.\"\r\n\r\nThe text is stated in the resumption section, but I don't think the sentence itself is about resumption. In TLS 1.2 the session ID is created in the full handshake and reused in all resumption. So the session ID lifetime could span several connections. I don't think it matters if you do resumption from a security perspective (but I would have to reread TLS 1.2 resumption).\r\n\r\nMight be that I am interpreting the sentence wrong, but the session ID lifetimes in DTLS/SCTP would be months or ever years.",
          "createdAt": "2021-02-19T12:40:23Z",
          "updatedAt": "2021-02-19T12:40:23Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So you are basically saying that in particular no TLS connection can live longer that 24 hours?\r\n",
          "createdAt": "2021-02-19T13:13:44Z",
          "updatedAt": "2021-02-19T13:13:44Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think RFC 5216 \"suggsts\" that. But it is not a normative SHOULD or MUST.\r\n",
          "createdAt": "2021-02-19T14:15:11Z",
          "updatedAt": "2021-02-19T14:15:11Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think RFC 5216 \"suggsts\" that. But it is not a normative SHOULD or MUST.\r\n\r\nSure. But it is the basic message... Wasn't aware of that limitation. Thanks for the clarification.",
          "createdAt": "2021-02-19T14:38:22Z",
          "updatedAt": "2021-02-19T14:38:22Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I would think we can close this issue now, if @emanjon you agree, please close it.",
          "createdAt": "2021-06-23T09:46:36Z",
          "updatedAt": "2021-06-23T09:46:36Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I would think we can close this issue now, if @emanjon you agree, please close it.\r\n\r\nHow do we update the key material used by SCTP-AUTH in case of DTLS 1.3? I think the PR doesn't describe this.",
          "createdAt": "2021-06-23T10:18:49Z",
          "updatedAt": "2021-06-23T10:18:49Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "You don't change the key, you will have to terminate the session if you run out usages of the key for signing. If your application layer can't handle that, then you will have to use DTLS 1.2 for now until a future solution is defined. ",
          "createdAt": "2021-06-23T12:14:14Z",
          "updatedAt": "2021-06-23T12:14:14Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can we make that clear in the text? Basically, if you are using long living SCTP associations, use DTLS 1.2 for now.",
          "createdAt": "2021-06-23T15:50:09Z",
          "updatedAt": "2021-06-23T15:50:20Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Yes, I think that is a sentence or two to clarify that if you need this property then use DTLS 1.2. ",
          "createdAt": "2021-06-24T06:24:00Z",
          "updatedAt": "2021-06-24T06:24:00Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWU4MTIwMDU3NTI=",
      "title": "Epoch handling",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/25",
      "state": "CLOSED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tuexen",
        "emanjon"
      ],
      "labels": [
        "Needs PR"
      ],
      "body": "Section 4.8 describes the epoch handling and relies on the methods described for example in Section 4.2.1 to avoid message loss within the DTLS layer. I don't think that this works. One reason is that it is assumed that after an MSL no messages from an older epoch can be received anymore. How can this be concluded?\r\n\r\n1. Even RFC 793 states for MSL: Arbitrarily defined to be 2 minutes.\r\n2. For making sure that no TCP segments from an old TCP connection are in the network anymore, TCP waits twice as long.\r\n3. We need to consider the time time-interval between the DTLS layer at the sending side passes the message to its lower layer and the DTLS layer at the receiving side get the message from its lower layer. When using DTLS/UDP and assuming that the UDP and IP layer do not buffer messages, this time interval can be approximated by the MSL. However when considering DTLS/SCTP, we also need to consider the time a message can be buffered in the SCTP layer. This can not be bound by an MSL.\r\n\r\nTherefore I think we need to do the draining game also used for DTLS 1.0/SCTP. Or am I missing anything?",
      "createdAt": "2021-02-19T13:03:00Z",
      "updatedAt": "2021-07-12T15:05:42Z",
      "closedAt": "2021-07-12T15:05:42Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "First of all I think draining needs to be avoided due to its impact on the application. We can't wait multiple RTT to ensure that the data for all DTLS records with one epoch to be successfully delivered before sending anyone with the new epoch. So I think we need to find a solution that works robustly but also don't cause long delays in finishing this. \r\n\r\nSo on the sender side there is to my knowledge no issue. The sender switches epoch and simply uses the new keys associated with that epoch and never switches back for all future DTLS records it does protection operation. And to my understanding this can occur in the middle of user message without issues. \r\n\r\nIt is on the receiver the problem arises when to determine when all DTLS record with the old epoch has been delivered. I think we want to assume the worst case here for this interaction. I think two factors that would be bad are I-DATA combined with a sender implementation that allows sender side buffering between the DTLS protection operation and the SCTP API send call. What I am fearing here is that a large user message have been processed by the DTLS protection operation, but not given to the SCTP stack to send, and in the process of scheduling this buffered user message with old epoch another user message contains DTLS records with new epoch are scheduled and prioritized for transmission. \r\n\r\nSo from the receiver perspective an epoch changes are initiated by receiving the first DTLS record with the new epoch. So when are the receiver certain that all old epoch DTLS records have been delivered and processed by the DTLS layer? So from a receiver perspective I think this is hard to guarantee due to that the receiver does not know if there are user message on streams that it has not yet seen. My conclusion is that we either have a robust mechanism based on timers and one simple mechanism as proposed below, or we need to have an explicit mechanism for the sender to indicate that it has sent all. I don't think the explicit mechanism is aligning with the goal to finish this work this year. So lets consider if the below proposal is robust enough to be acceptable.\r\n\r\nThe proposal has these components.\r\n\r\n1) A recommendation that the receiver do keep the keep the prior epoch keys longer than maybe usually in other use cases with motivation. My suggestion would be to not drop any key prior to 5 minutes after the last seen DTLS record with that epoch. And for communication scenarios with high RTT or low bandwidth where some low priority user messages may get stuck on the sender side to have this configurable to even higher values. \r\n\r\n2) To recommend against to rapid key changes, i.e. keep keys at least for 15+ minutes. And to support more rapid key changes mandate a limitation on the sender to not switch to a new key (epoch) until it has confirmed that all DTLS records on a the prior epoch has been delivered to the receiver. A small hold over just to ensure that the receiver process all the received DTLS records before dropping the key may be needed. This enables the receiver to not need to store more than the latest epoch and the epoch before that for any durations. This requirement pushes the complexity of tracking the user messages and what epoch they have been protected with onto the sender that want to do rapid re-keying. QUIC implements a similar limitation to prevent the key-updates to be out of synch as it uses a single bit to indicate key-phase between the endpoints.\r\n\r\n3) As this is timer a failure is not guaranteed to never occur, but I think to be extremely unlikely that we have a case where the receiver will fail to decrypt a DTLS Record because of old epoch. For SCTP user messages that are reliable, and where the sender thinks that the user message was received and the message fails to completely be delivered we need to abort the DTLS connection to signal this so that the application is aware of the failure and can restart the interaction. I think one can be clear that to avoid this from happening one could raise the time for 1) to infinity and only use 2) and have that be implemented. \r\n\r\nSo I think this is robust enough and can work without draining. It clearly need some text changes to be described and with clear motivation why SCTP makes this hard to determine than in many DTLS applications. \r\n",
          "createdAt": "2021-06-23T09:41:44Z",
          "updatedAt": "2021-06-23T09:41:44Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> First of all I think draining needs to be avoided due to its impact on the application. We can't wait multiple RTT to ensure that the data for all DTLS records with one epoch to be successfully delivered before sending anyone with the new epoch. So I think we need to find a solution that works robustly but also don't cause long delays in finishing this.\r\n\r\nOK. RFC 6083 relies on that. So we need something else. However, I'm not sure if DTLS implementations support sending user messages which a renegotiation is in process.\r\n\r\n> \r\n> So on the sender side there is to my knowledge no issue. The sender switches epoch and simply uses the new keys associated with that epoch and never switches back for all future DTLS records it does protection operation. And to my understanding this can occur in the middle of user message without issues.\r\n\r\nI just doubled checked the RFC, and from a receiver perspective you are right. You can use multiple shared secrets for a single user message. When you only consider [RFC 4895](https://datatracker.ietf.org/doc/html/rfc4895), you are right, too. However, if you have an SCTP implementation using the socket API as specified in [RFC 6458](https://datatracker.ietf.org/doc/html/rfc6458), you are using a single shared key identifier for a user message. The same shared key identifier is also used for retransmissions. That is the reason why you can de-activate a share key (see [RFC 6458](https://datatracker.ietf.org/doc/html/rfc6458#section-8.3.4)) and delete one (see [RFC 6458](https://datatracker.ietf.org/doc/html/rfc6458#section-8.3.5) if it is deactivated and not used anymore by the SCTP stacks, indicated by an `SCTP_AUTH_FREE_KEY` indication (see [RFC 6458](https://datatracker.ietf.org/doc/html/rfc6458#section-6.1.8).\r\n\r\n> \r\n> It is on the receiver the problem arises when to determine when all DTLS record with the old epoch has been delivered. I think we want to assume the worst case here for this interaction. I think two factors that would be bad are I-DATA combined with a sender implementation that allows sender side buffering between the DTLS protection operation and the SCTP API send call. What I am fearing here is that a large user message have been processed by the DTLS protection operation, but not given to the SCTP stack to send, and in the process of scheduling this buffered user message with old epoch another user message contains DTLS records with new epoch are scheduled and prioritized for transmission.\r\n\r\nI think user messages must no span multiple epochs... I would say that all messages sent by the application before triggering a re-negotiation must be handled in the old epoch. All messages sent by the application after the re-negotiation has been completed must be handled by the new epoch. This leaves out the messages sent after the re-negotiation has be triggered, but has not been completed. If we want to allow them to be sent, they can only use the old epoch. But I'm not sure how flexible DTLS implementations are...\r\n\r\nHandling of the AUTH shared keys are simple on the sender side.\r\n\r\n> \r\n> So from the receiver perspective an epoch changes are initiated by receiving the first DTLS record with the new epoch. So when are the receiver certain that all old epoch DTLS records have been delivered and \r\nprocessed by the DTLS layer? So from a receiver perspective I think this is hard to guarantee due to that the receiver does not know if there are user message on streams that it has not yet seen. My conclusion is that we either have a robust mechanism based on timers and one simple mechanism as proposed below, or we need to have an explicit mechanism for the sender to indicate that it has sent all. I don't think the explicit mechanism is aligning with the goal to finish this work this year. So lets consider if the below proposal is robust enough to be acceptable.\r\n\r\nWe do have to make sure that the receiver configured a new shared secret before a packet is received, which uses it. If we fail, the packet will be dropped.\r\n\r\n> \r\n> The proposal has these components.\r\n> \r\n> 1. A recommendation that the receiver do keep the keep the prior epoch keys longer than maybe usually in other use cases with motivation. My suggestion would be to not drop any key prior to 5 minutes after the last seen DTLS record with that epoch. And for communication scenarios with high RTT or low bandwidth where some low priority user messages may get stuck on the sender side to have this configurable to even higher values.\r\n\r\nWe need to distinguish between what the DTLS layer does with the key material it uses and what the DTLS layer with the key material SCTP uses and is configured by the DTLS layer.\r\n\r\n> 2. To recommend against to rapid key changes, i.e. keep keys at least for 15+ minutes. And to support more rapid key changes mandate a limitation on the sender to not switch to a new key (epoch) until it has confirmed that all DTLS records on a the prior epoch has been delivered to the receiver. A small hold over just to ensure that the receiver process all the received DTLS records before dropping the key may be needed. This enables the receiver to not need to store more than the latest epoch and the epoch before that for any durations. This requirement pushes the complexity of tracking the user messages and what epoch they have been protected with onto the sender that want to do rapid re-keying. QUIC implements a similar limitation to prevent the key-updates to be out of synch as it uses a single bit to indicate key-phase between the endpoints.\r\n> 3. As this is timer a failure is not guaranteed to never occur, but I think to be extremely unlikely that we have a case where the receiver will fail to decrypt a DTLS Record because of old epoch. For SCTP user messages that are reliable, and where the sender thinks that the user message was received and the message fails to completely be delivered we need to abort the DTLS connection to signal this so that the application is aware of the failure and can restart the interaction. I think one can be clear that to avoid this from happening one could raise the time for 1) to infinity and only use 2) and have that be implemented.\r\n> \r\n> So I think this is robust enough and can work without draining. It clearly need some text changes to be described and with clear motivation why SCTP makes this hard to determine than in many DTLS applications.\r\n\r\n",
          "createdAt": "2021-06-29T17:03:17Z",
          "updatedAt": "2021-06-29T17:03:17Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "@tuexen yes you are completely correct that we need to distinguish between renegotiations that change the SCTP-AUTH key and what is key update in DTLS layer. It was the later that I was thinking of when writing this. Because these operations can be fairly frequent compared to the actual need for the renegotiations. Very few process will exhaust the SCTP-AUTH keys usage limitations within the timespan you want to do these renegotiations for the reason of re-authenticating the endpoints and ensuring PFS. This later appear to be recommended to be done on 1-2 hour basis and in that time you would have to have an extremely high-rate application to exhaust HMAC with SHA-256. However, the AES-GCM keys may have to change more frequently than that due to the more limited key-usage limits. ",
          "createdAt": "2021-06-30T07:54:14Z",
          "updatedAt": "2021-06-30T07:54:14Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Author discussion conclusion was:\r\n- SCTP-AUTH key is bound to user message in socket API.\r\n- Basic rule is that old key will be retired when yet another renegotiation happens. \r\n   *  Sender will have to verify that user messages with oldest key has fully been sent before initiating and accepting a renegotiation.\r\n   * This is an actual limitation on the user of the stack they need to follow.\r\n   * Receiver may retire a key earlier if it is certain that it no longer in use.  \r\n - Risk of retiring a SCTP-AUTH key to early in receiver is that the user message will never be delivered, any retransmission will be dropped by receiver. Needs some type of handling",
          "createdAt": "2021-06-30T09:18:49Z",
          "updatedAt": "2021-06-30T09:18:49Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OK, I tried to address this issue in https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/55.\r\n\r\nHowever, two points are open:\r\n\r\n* I don't know how to implement:\r\n  ```\r\n   Prior to processing a received ClientHello message or ServerHello\r\n   message, all other received SCTP user messages that are buffered in the\r\n   SCTP layer and can be delivered to the DTLS layer MUST be read and\r\n   processed by DTLS.\r\n  ```\r\n  The only way I so to do this, is to read SCTP messages until the receive buffer is empty. But what if the sender keeps sending faster than the receiver can read? The receiver can't say something like \"I want only read messages which where in the receiver buffer before the the ClientHello arrived\".\r\n\r\n* For DTLS 1.3 the sender stops sending when an KeyUpdate is sent until it receives an Ack message.",
          "createdAt": "2021-07-12T03:36:14Z",
          "updatedAt": "2021-07-12T03:36:14Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Closing this and instead tracking remaining issue with much more specific issues #59, #60 and #62 ",
          "createdAt": "2021-07-12T15:05:42Z",
          "updatedAt": "2021-07-12T15:05:42Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU4MTIwOTMwNzY=",
      "title": "Strange sentence",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/27",
      "state": "CLOSED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\nDATA chunks that are received before DTLS handshake will be silently discarded.\r\n```\r\nNeeds to be changed.",
      "createdAt": "2021-02-19T15:01:01Z",
      "updatedAt": "2021-02-22T16:27:57Z",
      "closedAt": "2021-02-22T16:27:57Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Yes, that needs to be addressed. So in difference with RFC 6083, if one intended to use DTLS, no unprotected user messages should be sent. So what can arrive are either protected user messages or DTLS handshake messages on Stream 0. So stating that any data that has been sent will be ignored is not really protection against anything other than preventing misuse. But, it really ends up a question what the DTLS layer does with things that aren't DTLS records. ",
          "createdAt": "2021-02-19T15:46:19Z",
          "updatedAt": "2021-02-19T15:46:19Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How do you handle a starttls like setup used for example in [RFC 3788](https://tools.ietf.org/html/rfc3788)? I think the point is that once an SCTP association is handled by an DTLS implementation, the DTLS implementation should terminate the SCTP association if it can't parse the record.",
          "createdAt": "2021-02-19T15:52:17Z",
          "updatedAt": "2021-02-19T15:52:17Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I will review RFC 3788. From a layering perspective, I do agree that it is DTLS that needs to terminate the SCTP association. So maybe the way forward here is to state that once the DTLS over SCTP adapation layer interaction have gone both ways, we can mandate that all SCPT user messages will pass the DTLS layer, and thus it needs to be either DTLS messages (one stream 0) or protected user messages in DTLS records. If the DTLS stack receives anything else it can terminate the association. \r\n",
          "createdAt": "2021-02-22T09:18:46Z",
          "updatedAt": "2021-02-22T09:18:46Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Closing this issue after having created #35 and #37 to address two remaining aspects of the changes done in the PR #36.",
          "createdAt": "2021-02-22T16:27:56Z",
          "updatedAt": "2021-02-22T16:27:56Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWU4MTIxNDA3ODY=",
      "title": "Handling of partial reliable protected user messages",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/28",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "So the partial delivery of user messages will create situation where some DTLS records in a sequence of a protected used message will not be delivered in its entirety. Thus, I think we need to add some words on how one handles this situation. \r\n\r\nFirst, there is the question of ensuring that any buffer containing data that contains partial DTLS record are flushed. \r\nSecondly, if one have a partial delivery API towards the application, then that needs to get a error indication that this user message was not delivered in its entirety. \r\n\r\nThese issues are much more significant for this spec than it was for RFC 6083, where the DTLS record needed to be complete to decrypt and pass integrity. In this case one or more DTLS records from the start might be delivered.\r\n\r\n",
      "createdAt": "2021-02-19T16:01:15Z",
      "updatedAt": "2021-07-01T14:59:23Z",
      "closedAt": "2021-07-01T14:59:23Z",
      "comments": [
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Question: Why do we need to deal with the upper layer API of DTLS at all? Normally the IETF doesn't do it at all and, I think, doing the socket API for SCTP was a special thing.",
          "createdAt": "2021-02-19T16:28:54Z",
          "updatedAt": "2021-02-19T16:28:54Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Doesn't imply\r\n```\r\nDTLS/SCTP, automatically fragments and reassembles user messages\r\n```\r\natomic `send()`/`recv()` calls?",
          "createdAt": "2021-02-19T16:35:29Z",
          "updatedAt": "2021-02-19T16:35:29Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I am concerned with the SCTP<-> DTLS interactions due to partially receiving protected user message. The DTLS layer with the current definition is dependent on the in sequence delivery of the DTLS records and also the indication that the complete protected user message. \r\n\r\nIn cases where not all DTLS records of a protected user messages is delivered it is vital that the DTLS layer knows that and either delivers nothing (atomic operations) or indicates that only partial delivery have occurred if some parts of the user message has been decrypted and delivered. ",
          "createdAt": "2021-02-19T16:58:18Z",
          "updatedAt": "2021-02-19T16:58:18Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure, I agree.",
          "createdAt": "2021-02-19T21:33:17Z",
          "updatedAt": "2021-02-19T21:33:17Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "Text has been adapted for covering both the case where partial delivery is supported and where it isn't.",
          "createdAt": "2021-06-17T12:26:15Z",
          "updatedAt": "2021-06-17T12:26:15Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So this is being resolved by #40. ",
          "createdAt": "2021-06-22T08:41:32Z",
          "updatedAt": "2021-06-22T08:41:32Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "To my understanding this can be closed. In #48 a paragraph was added to also ensure that PR-SCTP don't result in terminated SCTP association when failures. ",
          "createdAt": "2021-07-01T14:59:23Z",
          "updatedAt": "2021-07-01T14:59:23Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWU4MTIzNDI4MjA=",
      "title": "main_secret",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/29",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://www.ietf.org/rfcdiff?url2=draft-ietf-tls-rfc8446bis-01\r\n\r\nRemoves \"master\" in TLS 1.2 and 1.3. This will very likey be the future terminology so we should probably use the term \"main secret\".",
      "createdAt": "2021-02-19T20:57:19Z",
      "updatedAt": "2021-02-22T09:55:53Z",
      "closedAt": "2021-02-22T09:55:53Z",
      "comments": []
    },
    {
      "number": 31,
      "id": "MDU6SXNzdWU4MTI4OTE2NDY=",
      "title": "Only client Post-Handshake authentication is specified for DTLS 1.3",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/31",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Post-Handshake frequent client authentication is possible, just like in DTLS 1.2, but Post-Handshake server authentication is not possible.\r\n\r\n",
      "createdAt": "2021-02-21T16:20:51Z",
      "updatedAt": "2021-06-22T08:01:21Z",
      "closedAt": "2021-06-22T08:01:21Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "This change was published in the WG -00 so we can close this one. ",
          "createdAt": "2021-06-22T08:01:21Z",
          "updatedAt": "2021-06-22T08:01:21Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWU4MTM2MzcxNjU=",
      "title": "Support for STARTTLS",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/35",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "So part of the discussion in #27 brought up the case of STARTTLS. I think that needs more consideration as due to even RFC 6083 requirement to have SCTP-AUTH, one can't move from a plain SCTP association to one with DTLS. Instead one actually need to create an association with the intent to use DTLS. So are there any point in attempting to support STARTTLS like for services that use TLS/TCP where it works. ",
      "createdAt": "2021-02-22T16:05:33Z",
      "updatedAt": "2021-07-01T13:37:31Z",
      "closedAt": "2021-07-01T13:37:31Z",
      "comments": [
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I only know about [RFC 3788](https://tools.ietf.org/html/rfc3788), which requires setting up the SCTP association appropriately, then exchanges the START-TLS and START-TLS-ACK message in the clear and then do TLS. [RFC 6083](https://tools.ietf.org/html/rfc6083) did not exist at that time.\r\n\r\nThe reason [RFC 3788](https://tools.ietf.org/html/rfc3788) was written is that there were some SIGTRAN specifications already published and they only specified the unsecured protocol. We requested separate port numbers for the protocols over TLS, but IANA declined that. So we had to do the START-TLS dance.\r\n\r\nTo be honest, in my limited testing I have done for a German mobile operator, I have never seen SIGTRAN over TLS... So I don't have a problem with not supporting START-TLS, we just need to be clear about it.",
          "createdAt": "2021-02-22T16:43:31Z",
          "updatedAt": "2021-02-22T16:43:31Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I think the way forward here is to explicitly note that STARTTLS will not work with this specification. ",
          "createdAt": "2021-05-10T08:56:56Z",
          "updatedAt": "2021-05-10T08:56:56Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "The note that STARTTLS will not work with this specification has been added.",
          "createdAt": "2021-06-17T12:27:10Z",
          "updatedAt": "2021-06-17T12:27:10Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The way forward and the added note looks good.",
          "createdAt": "2021-06-21T11:19:08Z",
          "updatedAt": "2021-06-21T11:19:08Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "The note has been reformulated in the PR due to that it was contextual problematic. We may want to further improve the style of it in the future. ",
          "createdAt": "2021-06-22T07:58:03Z",
          "updatedAt": "2021-06-22T07:58:03Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU4MTM2NTU4MDI=",
      "title": "Reaction to plain text prior or during DTLS connection",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/37",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "So currently any plain text prior or during a DTLS connection is considered a protocol violation. The reaction to this protocol violation is that it is allowed to do a SCTP association termination (ABORT). This issue is to track two aspect of this, while a related issue is #35 that impacts if plain text occur. But assuming that it can't we should clarify two things.\r\n\r\n1. Is MAY the right level or should this be RECOMMENDED or MUST?\r\n2. Should there be a particular error for this being sent back to peer?\r\n\r\n",
      "createdAt": "2021-02-22T16:27:10Z",
      "updatedAt": "2021-06-17T12:28:09Z",
      "closedAt": "2021-06-17T12:28:09Z",
      "comments": [
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "The cases where a protocol violation are detected SHOULD be answered with ABORT. \r\nText has been updated.",
          "createdAt": "2021-06-17T12:28:09Z",
          "updatedAt": "2021-06-17T12:28:09Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWU4MTM3MTQwMDI=",
      "title": "The maximum message size parameter",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/38",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "gloinul"
      ],
      "labels": [],
      "body": "This document defines a maximum message size SCTP parameter to allow peers to indicate some limitations in the receiver implementation. Currently this is defined in a DTLS/SCTP specific way. However, it appears that this could be a parameter that could be generalized and thus possible one should work to ensure that the parameter is not specific to DTLS/SCTP and instead can be used by other usages to indicate limitations. \r\n\r\nLet us discuss if it would make sense to generalize this, or keep it DTLS/SCTP specific. ",
      "createdAt": "2021-02-22T17:38:21Z",
      "updatedAt": "2021-07-01T15:01:35Z",
      "closedAt": "2021-07-01T15:01:35Z",
      "comments": [
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What kind of use case do you have in mind? Limiting the record size could be done using [RFC 8449](https://tools.ietf.org/html/rfc8449). So isn't the suggested extension useful for transport protocols, which are message oriented and support large messages using multiple records. Right now I don't see any, which would carry DTLS.",
          "createdAt": "2021-02-22T19:43:29Z",
          "updatedAt": "2021-02-22T19:43:29Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So our draft currently defines a SCTP parameter \"dtls_over_sctp_maximum_message_size\" that provides a limit on the total user message size for the upper layer protocol. This is defined prior to DTLS fragmentation and expansion due to the DTLS record overhead. So this parameter is basically to provide the peer indication of implementation limits in handling certain messages sizes. \r\n\r\nFrom a upper layer protocol perspective this challenge exists in general independently if DTLS is used or not. That is why I am asking if this should be generalized as mechanism so that it could be applied even if this DTLS/SCTP was not used. However, with DTLS in the mix the supported maximum message size becomes a combination of several factors. What the ULP is capable of buffering and processing assuming that the lower layers (DTLS and SCTP) is not the limiting factor. And if DTLS or SCTP or combination if implementation is the limiting factor the limit for that combination. \r\n\r\nSo limitations that could arise without making assumption on implementation are:\r\n\r\n- Buffering in DTLS sender or receiver if the ULP to DTLS API does not support partial message handling. \r\n- SCTP buffering if its API does not support partial message handling\r\n\r\nI hope this makes it clear that I think we have limitations if the implementations all the way are optimal, and even in this case we might want a method for the ULP to express limitations to the peer. \r\n\r\n",
          "createdAt": "2021-02-23T11:12:10Z",
          "updatedAt": "2021-02-23T11:12:10Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "Limitations due to implementation or the execution environment and the relationship with the SCTP User are implementation specific and not covered by the present recommendation.\r\nText has been added for this.",
          "createdAt": "2021-06-17T12:29:47Z",
          "updatedAt": "2021-06-17T12:29:47Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "To me it would make sense to define this SCTP parameter as \"sctp_maximum_message_size\" instead. ",
          "createdAt": "2021-06-21T11:22:21Z",
          "updatedAt": "2021-06-21T11:22:21Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So to make it clear. The currently in text proposed parameter is an DTLS parameter for maximum message size in this SCTP context. So I think the question, one that we likely should ask the WG for input about if we are not all on one side is.\r\n\r\nA) Have a DTLS parameter specifically for this contexts Maximum Message Size\r\n\r\nB) Have a generic SCTP User Message Size parameter defined as an SCTP parameter agreed on during handshake.\r\n\r\nSo B) is generic and could be used in any context also not for DTLS. However, we would need to provide a interpretation here for the value in regards to the DTLS overhead, which for A) is obviously message size above DTLS. Secondly when defining B) we would need to have more consideration for third party attacks. In the DTLS context we could consider verifying the value. But, it is a potential Denial of Service threat by third party to reduce the value. \r\n\r\nSo I do wonder if going down the general SCTP route here is the best. But lets discuss and I think this issue can be worth an email the the TSVWG mailing list. ",
          "createdAt": "2021-06-22T07:56:35Z",
          "updatedAt": "2021-06-22T07:56:35Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> So to make it clear. The currently in text proposed parameter is an DTLS parameter for maximum message size in this SCTP context. So I think the question, one that we likely should ask the WG for input about if we are not all on one side is.\r\n> \r\n> A) Have a DTLS parameter specifically for this contexts Maximum Message Size\r\n> \r\n> B) Have a generic SCTP User Message Size parameter defined as an SCTP parameter agreed on during handshake.\r\n> \r\n> So B) is generic and could be used in any context also not for DTLS. However, we would need to provide a interpretation here for the value in regards to the DTLS overhead, which for A) is obviously message size above DTLS. Secondly when defining B) we would need to have more consideration for third party attacks. In the DTLS context we could consider verifying the value. But, it is a potential Denial of Service threat by third party to reduce the value.\r\n> \r\n> So I do wonder if going down the general SCTP route here is the best. But lets discuss and I think this issue can be worth an email the the TSVWG mailing list.\r\n\r\nBut what is the semantic of the SCTP parameter? SCTP supports transferring arbitrary large user messages by using the partial delivery API. So this might be an upper layer issue. Why should SCTP care? Also DTLS only processes DTLS messages.  DTLS only has to pass through the `MSG_EOR`. This can be use by some reassembly layer on top of the application or just by the application itself. The message size limit is a property of the reassembly layer or the application. Basically what sits on top of DTLS.\r\n\r\nSCTP would just pass the parameter through.\r\n\r\nWhat is the application we are considering? Diameter? Does Diameter have a message size limit negotiated at the beginning?",
          "createdAt": "2021-06-22T08:11:20Z",
          "updatedAt": "2021-06-22T08:11:20Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So the first issue is the partial delivery requirement. That is not mandated but clearly good to have when the ULP message size goes up. However, if one doesn't have partial delivery then one are in the hands of the combination of receiver window and the application's stream and user message pattern. \r\n\r\nSo from SCTPs stand point the parameter is not needed as it is ULPs problem. With DTLS we have a shim security layer that interacts between the SCTP API and the ULP capabilities and that could cause issues if there are true limitations on the RFC 6083bis reassembly layer if the ULP is not supporting partial delivery of user messages also, or on a granularity that doesn't match DTLS record sizes. \r\n\r\nSo from my perspective I think a DTLS level parameter for RFC6083bis message sizes do make sense as this is the layer in the stack where the interaction becomes problematic and it has the possibility to communicate both upwards and downwards to agree on restrictions. \r\n\r\nIf we move it down, the message size limitation could possible be re-used by ULPs that forgot to include it in the ULP protocol and later realizes that it needs to know limitations. \r\n\r\nI think an important aspect of this is the fact that we end up in a situation where we might not be able to provide a feedback signal that the receiver failed to decrypt the message because it run out of memory so the original sender needs to resend the message. Once the receiver have cumulative ACKed the data the sender will assume that we have provided the data to the ULP. With this reassembly and decryption this can in fact fail. \r\n\r\nI haven't dug into the 3GPP Specs for the various protocols that can theoretically hit the DTLS limit in future deployments. But the 3GPP interface protocols that we are talking about are: F1, E1, Xn, NG-C.\r\n\r\nSo I have no strong opinion if the message size limit should be in SCTP or DTLS, but to my understanding we need the signalling. ",
          "createdAt": "2021-06-22T12:34:42Z",
          "updatedAt": "2021-06-22T12:34:42Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have been contemplating about this for a while...\r\n\r\nIf I understand the issue correctly, we are discussing the introduction of a message (at the SCTP layer, the DTLS layer, or at higher layers), which indicate the maximum size a receiver is willing to accept.\r\nWhat are the consequences of having it?\r\n* For the receiver I do not see any. It has to deal with receiving larger messages anyway and protect itself. The peer can not honour the limit due to bugs or even intentionally. So I guess it has to monitor things and abort the communication if the peer sends messages being too large.\r\n* For the sender I'm not sure. Either the size is sufficient, then there is no impact. Or it might not be. Then the sender can perform the communication and had to stop once it has to send a message exceeding the limit.\r\n\r\nSo in both cases the result is the same as in the case where the receiver only protects itself, which it has to do anyway.\r\nFrom an implementation perspective, SCTP supports arbitrary large user messages using the partial delivery API. DTLS has not that much of a problem, since it has to deal with about 16 KB messages. So the simplest implementation at that layer would be to parse for DTLS records and just pass the `MSG_EOR` flag from the SCTP to the upper layer of DTLS.\r\nSo it comes to the application layer. If looking, for example, at Diameter/TLS/TCP, the Diameter layer has to protect it self (or support messages up to 16 MB). This is not done by TCP or TLS.\r\n\r\nIn summary, I think the layer at the receiver doing the reassembly of the application layer message MUST protect itself and terminate the communication if its limits are reached. Adding signalling of this limit, does not make the receiver simpler. So I would vote for not adding such a limit to any layer...\r\n\r\n",
          "createdAt": "2021-06-28T14:08:59Z",
          "updatedAt": "2021-06-28T14:09:13Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "@tuexen I would also prefer to avoid this message if possible. However, I think we have two issues. The first is that there so far has been limited support for mandating the implementation of the partial delivery. Maybe that was a misunderstanding of why and was removed for being poorly motivated. \r\n\r\nHowever, if one does not mandate that one can end up in a situation where the DTLS receiver layer gets stuck with the data and can't hand it over properly to the higher layer. There are two issues here, the first the question of what API there exist between the DTLS layer and the ULP on the receiver side. That is implementation dependent and if that is not partially delivery then the buffering happens in the DTLS layer.  \r\n\r\nSecondly we have the issue with the signalling related to the partially delivered messages. So on the receiver side and when the DTLS layer reads an MSG_EOR, yes then it knows that it should be able to complete the decrypt and integrity verification and provide the message upwards and if that is successful then it clearly can give the ULP a MSG_EOR also. However, the issue I am worried here is related to if the failure occur in the receiver DTLS Layer when it attempts to read from the SCTP but runs out of memory. How does it gracefully deal with this situation if you overrun the receivers capability. I think there are two cases here. The first if it can't read more from a user message due to memory limitations and needs to drop the message. What error are exchanged and can the sender determine that this has happend? The other case is if the DTLS layer would be able to read all of the protected user message from the lower layer, but be unable to complete the deprotection operation and need to drop the message. Are there any way out of this other than terminating the association to force the ULP to recover the state? \r\n\r\nThese issues are mainly the reason I see a need to introduce a message size limitation to help avoid failures. I think this issue needs further discussion. \r\n\r\n",
          "createdAt": "2021-06-28T15:06:23Z",
          "updatedAt": "2021-06-28T15:06:23Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @tuexen I would also prefer to avoid this message if possible. However, I think we have two issues. The first is that there so far has been limited support for mandating the implementation of the partial delivery. Maybe that was a misunderstanding of why and was removed for being poorly motivated.\r\n\r\nLets look at buffering within the SCTP stack. We need to distinguish two cases:\r\n\r\n1. Using DATA chunks: If the stack does not support partial delivery, the maximum message size is basically the advertised receiver window (modulo chunk overhead). Such a stack will have a very limited performance in transferring maximum sized packets and is has to use reneging. RFC 4960 says:\r\n```\r\nNote: If the data receiver runs out of buffer space while still\r\nwaiting for more fragments to complete the reassembly of the message,\r\nit should dispatch part of its inbound message through a partial\r\ndelivery API (see Section 10), freeing some of its receive buffer\r\nspace so that the rest of the message may be received.\r\n```\r\nRFC 4960bis will change the should to a SHOULD. Please note that all general purpose implementations I'm aware of support partial delivery.\r\n\r\n2. Using I-DATA chunks: It gets very hard to implement a stack which does not support partial delivery and does not deadlock. That is why you interleave messages from different streams per default. See [RFC 8260](https://datatracker.ietf.org/doc/html/rfc8260#section-4.3.1).\r\n\r\nSo I see no reason not to require the support of partial delivery.\r\n\r\n> \r\n> However, if one does not mandate that one can end up in a situation where the DTLS receiver layer gets stuck with the data and can't hand it over properly to the higher layer. There are two issues here, the first the question of what API there exist between the DTLS layer and the ULP on the receiver side. That is implementation dependent and if that is not partially delivery then the buffering happens in the DTLS layer.\r\n\r\nMessages must be reassembled by either the DTLS layer or the application layer. Lets call the layer, which is doing this, the reassembly layer.\r\n\r\nSince there is no specified upper layer API specified for DTLS, we need to be generic here. Either the reassembly layer is DTLS and the application gets complete messages or the reassembly layer is the application layer and the application gets fragments, an indication which fragments belong together (like the incoming SID) and an indication if the fragments are the final one of a message. But don't have to specify anything, we just need to be sure it can be done.\r\n\r\n> \r\n> Secondly we have the issue with the signalling related to the partially delivered messages. So on the receiver side and when the DTLS layer reads an MSG_EOR, yes then it knows that it should be able to complete the decrypt and integrity verification and provide the message upwards and if that is successful then it clearly can give the ULP a MSG_EOR also. \r\n\r\nI think the only thing the DTLS receiver needs to do, is\r\n\r\n1. Verify that a DTLS record ends at the end of the message.\r\n2. Pass the end indication up to the application if DTLS is not the reassembly layer.\r\n\r\nIf the first check does not pass, one could use a DTLS Alert message to signal this a gracefully terminate the SCTP association. Maybe we should register a message via IANA.\r\n\r\n> However, the issue I am worried here is related to if the failure occur in the receiver DTLS Layer when it attempts to read from the SCTP but runs out of memory. How does it gracefully deal with this situation if you overrun the receivers capability. I think there are two cases here. The first if it can't read more from a user \r\nmessage due to memory limitations and needs to drop the message. What error are exchanged and can the sender determine that this has happend? The other case is if the DTLS layer would be able to read all of the protected user message from the lower layer, but be unable to complete the deprotection operation and need to drop the message. Are there any way out of this other than terminating the association to force the ULP to recover the state?\r\n> \r\n\r\nThere can be two issues as you mention:\r\n\r\n1. DTLS encounters an issue while processing a record. We can signal this with an DTLS Alert and gracefully shutdown the association.\r\n2. The reassembly layer runs out of resources. We need to terminate the association. I'm not sure about the usefulness of a specific error message. One could use an DTLS Alert or send an SCTP ABORT with a User Initiated abort cause.\r\n\r\n> These issues are mainly the reason I see a need to introduce a message size limitation to help avoid failures. I think this issue needs further discussion.\r\n\r\nYes, let us discuss this tomorrow. I just wrote up the above to have a base for the discussion.\r\n",
          "createdAt": "2021-06-29T20:26:17Z",
          "updatedAt": "2021-06-29T20:26:17Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Author discussion conclusion:\r\n- Require SCTP partial delivery support. \r\n- Remove message size limitation signalling\r\n- Make clear that if receiver fails to reassembly it MUST to detect it. Receivers reaction may include aborting the SCTP association. \r\n- In case there is a missmatch between SCTP user message end and DTLS record end, this also needs to be handled. This should be signalled likely in the DTLS record, with an Alert. Find a matching or defining a new. ",
          "createdAt": "2021-06-30T08:37:47Z",
          "updatedAt": "2021-06-30T08:37:47Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I would appreciate if someone took a look at the PR #48 as it is quite big before we merge it. I think it address all that was agreed on. ",
          "createdAt": "2021-07-01T13:36:29Z",
          "updatedAt": "2021-07-01T13:36:29Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done. I provided concrete suggestions. Please go through the comments, address them if you find them appropriate. Then I'm fine with the PR being merged.",
          "createdAt": "2021-07-01T14:11:01Z",
          "updatedAt": "2021-07-01T14:11:01Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I will merge the PR, but for your information I did rewrite one sentence significantly. I also added a paragraph in \"Mapping of DTLS Records\" section on PR-SCTP. ",
          "createdAt": "2021-07-01T14:54:48Z",
          "updatedAt": "2021-07-01T14:54:48Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWU5MzM3NDc1Njk=",
      "title": "Version of DTLS",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/46",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "gloinul"
      ],
      "labels": [],
      "body": "Based on that we don't have feature parity between DTLS 1.2 and 1.3 I think the Version of DTLS section needs to be rewritten a bit to make it clear that this spec is defining usage of both and maybe have a upfront discussion of the limitations?",
      "createdAt": "2021-06-30T14:05:44Z",
      "updatedAt": "2021-07-07T12:38:02Z",
      "closedAt": "2021-07-07T12:38:02Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I will take an initial stab in doing this. ",
          "createdAt": "2021-07-06T08:02:13Z",
          "updatedAt": "2021-07-06T08:02:13Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWU5MzM3ODIzNDA=",
      "title": "Section 4.1: Mapping of DTLS Records",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/47",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "gloinul"
      ],
      "labels": [],
      "body": "\"The DTLS Connection ID SHOULD NOT be negotiated (Section 9 of [I-D.ietf-tls-dtls13]). If DTLS 1.3 is used, the length field MUST NOT be omitted and a 16 bit sequence number SHOULD be used.\"\r\n\r\nCan this be rewritten to no use double negative form.  \"the length field MUST NOT be omitted\" -> the length field MUST be included\"?\r\n\r\n",
      "createdAt": "2021-06-30T14:39:43Z",
      "updatedAt": "2021-07-01T15:08:32Z",
      "closedAt": "2021-07-01T15:08:32Z",
      "comments": []
    },
    {
      "number": 52,
      "id": "MDU6SXNzdWU5NDA4ODI0MTM=",
      "title": "DTLS 1.3 Post-Handshake rekeying and reauthentication.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/52",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is not necessarily an issue for RFC6083bis, but it is likely good to have a discussion regarding the topic sooner rather than later. Deployment of DTLS 1.3 (still a draft) is several years behind TLS 1.3 but in the not-so-distant future, DTLS 1.2 should be phased out.\r\n\r\nDTLS 1.3 is not suitable for semi-permanent connections required to be up and running for years. DTLS 1.3 removes the DTLS 1.2 renegotiation and does not replace the functionality. DTLS/SCTP relies heavily on DTLS 1.2 renegotiation. I think this needs to be fixed in DTLS 1.3 before DTLS 1.3 is suitable for semi-permanent connections. The TLS working group does likely not want renegotiation in DTLS 1.3. I see two ways forward.\r\n\r\n1. A slimmed down post-Handshake \"authentication and key exchange\" that performs a Diffie-Hellman key exchange, updates the exporter_secret, and performs client and server authentication without renegotiation of any parameters (except the ephemeral keys and potentially new certs with the same identities).\r\n\r\n2. Doing resumption in parallel with the existing connection together with post-handshake client authentication and post-handshake server authentication. Resumption performs a Diffie-Hellman key exchange and updates the exporter_secret. Post-handshake server authentication would have to be specified. With DTLS connectionID several connections can be sent over the same 5-tuple at the cost of 1 extra byte (note that the DTLS 1.3 record layer is significantly smaller than the DTLS 1.2 record layer). While resumption was not designed to be used in parallel with the original connection, I don\u2019t think it is forbidden anywhere.\r\n",
      "createdAt": "2021-07-09T15:52:02Z",
      "updatedAt": "2021-10-22T15:29:29Z",
      "closedAt": "2021-10-22T15:29:29Z",
      "comments": [
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looking at DTLS 1.3 as specified right now:  Which messages must be received at the client side and the server side, after which we can compute the exporter_secret at earliest time?\r\n",
          "createdAt": "2021-07-09T16:13:42Z",
          "updatedAt": "2021-07-09T16:13:42Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "A new exporter_secret can only be computed after resumption. You need to send the following to set up a new connection\r\n\r\n```\r\n          ClientHello\r\n          + key_share*\r\n          + pre_shared_key          -------->\r\n                                                          ServerHello\r\n                                                     + pre_shared_key\r\n                                                         + key_share*\r\n                                                {EncryptedExtensions}\r\n                                                           {Finished}\r\n                                    <--------     [Application Data*]\r\n          {Finished}                -------->\r\n\r\n```\r\nThis cannot be done over the old connection but could maybe be done in parallel with the old connection.",
          "createdAt": "2021-07-09T16:57:55Z",
          "updatedAt": "2021-07-09T16:57:55Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What about the initial handshake?When can the exporter_secret be computed? I would like to understand when the AUTH keys can be deployed to avoid the receiver dropping packets because it does not know the AUTH keys yet...",
          "createdAt": "2021-07-09T17:39:53Z",
          "updatedAt": "2021-07-09T17:39:53Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I am starting to think that for DTLS 1.3 we should already from the beginning specify that rekeying is done by setting up a new DTLS 1.3 connection in paralell with the old one. The new connection can use resumption or be a full handshake. By using DTLS Connection ID there can be any number of DTLS connections on a single 5-tuple. Connection ID adds one byte to the record header but DTLS 1.3 record layer is significantly smaller than DTLS 1.2. In DTLS 1.3 the record overhead is 19-24 bytes compared to 37 bytes in DTLS 1.2. So even with 1 byte Connection ID, the DTLS record layers are significantly smaller than DTLS 1.2. KeyUpdate could be forbidden.\r\n\r\nGiven that DTLS/SCTP has to keep track of the DTLS epochs, I don't see that changing epochs to connections would complicate things much (at least not if we simply forbid KeyUpdate), but maybe I miss something.\r\n\r\nDoing the above would solve a lot (all?) of the problems with DTLS/SCTP 1.3:\r\n- No Diffie-Hellman rekeying\r\n- No post-handshake server authentication\r\n- No rekeying of the exporter_secret\r\n- 2^40.5 packets limit\r\n- 2 minute MSL requirement\r\n\r\nThis might be the final suggestion from the TLS WG anyway. I am not sure they would like to standardize a \"renegotiation\"-light as that might invalidate the security proofs of TLS 1.3.",
          "createdAt": "2021-07-16T17:02:11Z",
          "updatedAt": "2021-07-16T17:02:11Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "One way forward could be to remove DTLS 1.3 from the document and specify that in a later document which would allow time to discuss with the TLS WG. 3GPP will likely start with using DTLS 1.2 as DTLS 1.3 is not an RFC yet and not supported by libraries.\r\n\r\nI am not happy with the currect specification which specifies a quite bad and lacking solution for DTLS 1.3. I think that (D)TLS 1.3 or DTLS/SCTP 1.3 has to be modified. Unless modifying DTLS/SCTP 1.3 to use connection instead of epoch cause any major problems, that seems like an easier way forward.",
          "createdAt": "2021-07-18T09:18:10Z",
          "updatedAt": "2021-07-18T09:18:10Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I am starting to think that for DTLS 1.3 we should already from the beginning specify that rekeying is done by setting up a new DTLS 1.3 connection in paralell with the old one. The new connection can use resumption or be a full handshake. By using DTLS Connection ID there can be any number of DTLS connections on a single 5-tuple. Connection ID adds one byte to the record header but DTLS 1.3 record layer is significantly smaller than DTLS 1.2. In DTLS 1.3 the record overhead is 19-24 bytes compared to 37 bytes in DTLS 1.2. So even with 1 byte Connection ID, the DTLS record layers are significantly smaller than DTLS 1.2. KeyUpdate could be forbidden.\r\n> \r\n> Given that DTLS/SCTP has to keep track of the DTLS epochs, I don't see that changing epochs to connections would complicate things much (at least not if we simply forbid KeyUpdate), but maybe I miss something.\r\n> \r\n> Doing the above would solve a lot (all?) of the problems with DTLS/SCTP 1.3:\r\n> \r\n> * No Diffie-Hellman rekeying\r\n> * No post-handshake server authentication\r\n> * No rekeying of the exporter_secret\r\n> * 2^40.5 packets limit\r\n> * 2 minute MSL requirement\r\n> \r\n> This might be the final suggestion from the TLS WG anyway. I am not sure they would like to standardize a \"renegotiation\"-light as that might invalidate the security proofs of TLS 1.3.\r\n\r\nI read this as: We keep DTLS/SCTP simple, but enforcing limitations and require the application to deal with it by managing multiple DTLS connections. Wether they map them on the same SCTP association or not is up to the application and, in particular, the DTLS implementation used. Especially, enforcing sequencing constraints between the different DTLS connections would be left to the application.\r\n\r\nFrom a point of standardising DTLS/SCTP this is fine, since it is the simplest possible way. As an implementer of an application my view would be different...",
          "createdAt": "2021-07-18T14:25:36Z",
          "updatedAt": "2021-07-18T14:25:36Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> One way forward could be to remove DTLS 1.3 from the document and specify that in a later document which would allow time to discuss with the TLS WG. 3GPP will likely start with using DTLS 1.2 as DTLS 1.3 is not an RFC yet and not supported by libraries.\r\n> \r\n\r\nThat is definitely a way forward. However, I don't know how happy TSVWG and in particular the IESG would be to deal with two RFCs instead of one.\r\n\r\n\r\n> I am not happy with the currect specification which specifies a quite bad and lacking solution for DTLS 1.3. I think that (D)TLS 1.3 or DTLS/SCTP 1.3 has to be modified. Unless modifying DTLS/SCTP 1.3 to use connection instead of epoch cause any major problems, that seems like an easier way forward.\r\n\r\nIn my view we can only specify how DTLS 1.3 (whatever that is) can be used over SCTP. This would mean right now, how to support keyupdates.\r\n\r\nA separate question would be whether DTLS can be used in particular use cases... This might require some work on DTLS 1.3 or just the statement, that particular use cases are not supported... Depending on the interest within the TLS WG on these use cases.",
          "createdAt": "2021-07-18T14:32:55Z",
          "updatedAt": "2021-07-18T14:32:55Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "@tuexen I am not interpreting @emanjon in the same way. Where we currently defining renegotiation for DTLS 1.2 to do key-updates. We would instead define a procedure that initiates a new DTLS connection over the same SCTP association. For each new DTLS connection one would export a new SCTP-AUTH key.  With each DTLS record identifying the connection though an ID, we can basically do the same things as for DTLS 1.2 when it comes to handling and draining. \r\n\r\nSo all is targeting the same use cases, we just specify the additional DTLS 1.3 procedures to get a PFS solution also there and get feature compatibility. \r\n\r\nI would suggest that we write this up in an PR so that we have something more tangible and also when doing that can see if we have missed anything. ",
          "createdAt": "2021-07-19T06:52:09Z",
          "updatedAt": "2021-07-19T06:52:09Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@gloinul My understanding is that we specify what happens for DTLS 1.2/SCTP, when the upper layer of DTLS triggers a re-negotiation, since re-negotiation is a feature of DTLS 1.2. For this, it doesn't matter why the upper layer is doing this.\r\n\r\nDTLS 1.3 does support key updates and therefore we should define how that works when DTLS 1.3 is used over SCTP.\r\n\r\nUsing DTLS 1.3 in a specific way to provide additional features is conceptually different from the above in my view.",
          "createdAt": "2021-07-19T07:12:56Z",
          "updatedAt": "2021-07-19T07:18:42Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "It is conceptually different, but fills the same functionality, and is within the same boundaries that current DTLS/SCTP functionality has. It has a top API to ULP, it interacts with an DTLS implementation and sends and receive things over SCTP. It just that the DTLS interaction that is reshuffled. ",
          "createdAt": "2021-07-19T08:18:48Z",
          "updatedAt": "2021-07-19T08:18:48Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It is conceptually different, but fills the same functionality, and is within the same boundaries that current DTLS/SCTP functionality has. It has a top API to ULP, it interacts with an DTLS implementation and sends and receive things over SCTP. It just that the DTLS interaction that is reshuffled.\r\n\r\nFor an ULP perspective, there happens much more under the hood as one would expect. The ULP initiates a DTLS connection und under the hood a lot of DTLS connections are initiated.\r\n\r\nFor me this looks like a shim layer on top of DTLS 1.3, which allows you to realise a feature that DTLS does not provide (anymore). If I understand the proposal correctly, you could do the same for DTLS 1.3/UDP. So for me this is not something like *How do I use DTLS 1.3 over SCTP?*, but more *How to  I realise a particular features not provide by DTLS 1.3?* and in addition to that *How do I do that over SCTP?*.\r\n\r\nIn my view, the scope of the document is to provide guidance on *How do I use DTLS 1.[23] over SCTP?*, at least this was the scope of RFC 6083.",
          "createdAt": "2021-07-19T09:42:05Z",
          "updatedAt": "2021-07-19T09:42:05Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we going to add this, we should\r\n\r\n1. Describe in a separate section the general concept and make crystal clear that there is no relation to DTLS/SCTP. Doesn't that concept apply not only to DTLS 1.3/UDP but also to TLS 1.3/TCP?\r\n2. Describe in text not contained in the above section, how to hide the connection management in case of DTLS 1.3/SCTP.\r\n\r\nWhen implementing this feature, I expect some conceptually different problems from the ones one has to address when implementing DTLS/SCTP support, since you need to hide some stuff normally exposed via the API.",
          "createdAt": "2021-07-19T10:17:59Z",
          "updatedAt": "2021-07-19T10:17:59Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Earlier comments from the TLS WG when I brought up these issues was that (D)TLS 1.3 should not reintroduce renegotiation and that long-lasting interfaces need to use several DTLS connections. I think setting up several connections is the (D)TLS 1.3 replacement for renegotiotion. KeyUpdate can be seen as a new feature required by the new AEAD limits. The more I think about it, the more I think that the current specification of DTLS/SCTP with DTLS 1.3 is not acceptable from a security perspective. I also don't think the TLS WG will not fix the issues for us unless we can show that using several connections is impossible for some reason. Let's start making a Pull Request, that should give us an idea of how well this works or not. If it works well, that is great. It something does not work we have better arguments why the TLS WG needs to do something.",
          "createdAt": "2021-07-19T10:34:28Z",
          "updatedAt": "2021-07-19T10:34:28Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": ">  If I understand the proposal correctly, you could do the same for DTLS 1.3/UDP.\r\n\r\nYes, I this is a general problem for semi-permanent use of (D)TLS 1.3 over any layer. One option would be to have a RFC in the TLS WG that says that for semi-permanent interfaces lasting years you set up several connections. But from a TLS 1.3 perspective that would more or less be everything there is to say, expect making sure that the identities stays the same. I Waiting for such a document would likely not be worth it. The info would likely be quite obvious, and DTLS/SCTP would still have to add a lot of details of how to do key derivation for SCTP-AUTH, how to sync keys between DTLS and SCTP-AUTH, and when old keys can be deleted.\r\n\r\nDTLS/SCTP already seems much more than use DTLS over SCTP. DTLS/SCTP specifies how to derive keys for SCTP-AUTH, how to link SCTP-AUTH keys and DTLS keys, how to deviate from the DTLS key lifetime, how identities across renegotiations needs to stay the same etc... ",
          "createdAt": "2021-07-19T10:45:08Z",
          "updatedAt": "2021-07-19T10:45:08Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Earlier comments from the TLS WG when I brought up these issues was that (D)TLS 1.3 should not reintroduce renegotiation and that long-lasting interfaces need to use several DTLS connections. I think setting up several connections is the (D)TLS 1.3 replacement for renegotiotion. KeyUpdate can be seen as a new feature required by the new AEAD limits. The more I think about it, the more I think that the current specification of DTLS/SCTP with DTLS 1.3 is not acceptable from a security perspective. I also don't think the TLS WG will not fix the issues for \r\n\r\nWhy is DTLS 1.3/SCTP broken from a security perspective? That would imply that TLS 1.3/TCP is also broken.\r\n\r\nI do understand that DTLS 1.3/SCTP can not be used for a specific use case, since the DTLS 1.3 does not support it anymore and that this breakage is intentionally. But if you stay within the limits of DTLS 1.3, I don't see how DTLS 1.3/SCTP is broken. Can you elaborate on that?\r\n\r\nI think we should describe how to use DTLS 1.3 (including key updates) over SCTP for use cases which are within the limits of DTLS 1.3.\r\n\r\nIn addition to that, we can describe how to use DTLS 1.3 for long living connections by tying together multiple DTLS connections. But let us be clear that this is a separate concept.\r\n\r\n> us unless we can show that using several connections is impossible for some reason. Let's start making a Pull Request, that should give us an idea of how well this works or not. If it works well, that is great. It something does not work we have better arguments why the TLS WG needs to do something.\r\n\r\n\r\n\r\n",
          "createdAt": "2021-07-19T12:15:23Z",
          "updatedAt": "2021-07-19T12:15:23Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > If I understand the proposal correctly, you could do the same for DTLS 1.3/UDP.\r\n> \r\n> Yes, I this is a general problem for semi-permanent use of (D)TLS 1.3 over any layer. One option would be to have a RFC in the TLS WG that says that for semi-permanent interfaces lasting years you set up several connections. But from a TLS 1.3 perspective that would more or less be everything there is to say, expect making sure that the identities stays the same. I Waiting for such a document would likely not be worth it. The info would likely be quite obvious, and \r\n\r\nYes you are right. For DTLS/UDP and TLS/TCP there is not much more to say.\r\n\r\nSo I agree that only for DTLS/SCTP one has to do something to enforce the sequencing and reliability constraints.\r\n\r\nSo make that a separate section in this document, and I'm fine with this.\r\n\r\n> DTLS/SCTP would still have to add a lot of details of how to do key derivation for SCTP-AUTH, how to sync keys between DTLS and SCTP-AUTH, and when old keys can be deleted.\r\n> \r\n> DTLS/SCTP already seems much more than use DTLS over SCTP. DTLS/SCTP specifies how to derive keys for SCTP-AUTH, how to link SCTP-AUTH keys and DTLS keys, how to deviate from the DTLS key lifetime, how identities across renegotiations needs to stay the same etc...\r\n\r\n",
          "createdAt": "2021-07-19T12:17:56Z",
          "updatedAt": "2021-07-19T12:17:56Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "The main issue here should now be resolved by #70. ",
          "createdAt": "2021-10-22T15:26:49Z",
          "updatedAt": "2021-10-22T15:26:49Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "MDU6SXNzdWU5NDE1MzIwNzM=",
      "title": "RFC 6083 Fallback Issues",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/54",
      "state": "CLOSED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "tuexen"
      ],
      "labels": [
        "Needs PR"
      ],
      "body": "* Why Fallback when the correct adaptation layer indication has been received, but the HMAC or CHUNKS parameter is not as expected. Shouldn't we handle this as a protocol violation? An old implementation will not send the adaptation layer indication...\r\n* Should we describe what to do if the adaptation layer indication is received, but DTLS version 1.0 is indicated?",
      "createdAt": "2021-07-11T21:05:27Z",
      "updatedAt": "2021-07-12T11:50:14Z",
      "closedAt": "2021-07-12T11:50:14Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe we should have have a reference to RFC 8996. According to RFC 8996 (that updates RFC 6083) DTLS 1.0 is always a fatal error. Maybe we should have some more text.\r\n\r\n\"DTLS 1.0 are formally deprecated and prohibited to negotiate and use [RFC8996].\"",
          "createdAt": "2021-07-12T04:35:26Z",
          "updatedAt": "2021-07-12T04:35:26Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Maybe we should have have a reference to RFC 8996. According to RFC 8996 (that updates RFC 6083) DTLS 1.0 is always a fatal error. Maybe we should have some more text.\r\n> \r\n> \"DTLS 1.0 are formally deprecated and prohibited to negotiate and use [RFC8996].\"\r\n\r\nWe already has similar text in `Version of DTLS`. I added the reference.\r\n\r\nI also tweaked the text such that we only consider the missing of the adaptation layer indication as a possibility for a fallback.\r\n\r\nBut why are we restricting this to the client side? A new client can talk to an old server (using DTLS 1.2). @gloinul Why not also allow an old client talking to a new server?",
          "createdAt": "2021-07-12T07:56:03Z",
          "updatedAt": "2021-07-12T08:00:21Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "MDU6SXNzdWU5NDIxMjMxMDY=",
      "title": "DTLS 1.3 Epoch handling",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/59",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "Needs PR"
      ],
      "body": "Currently DTLS 1.3 key update procedure relies on a form of draining which is limiting and can impact the upper layer protocol application as they can't send new user messages during key update procedures.. Thus a better solution should be found. \r\n\r\n",
      "createdAt": "2021-07-12T14:27:11Z",
      "updatedAt": "2021-10-22T15:27:58Z",
      "closedAt": "2021-10-22T15:27:58Z",
      "comments": [
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm. A hack: When changing the epoch, change also the Shared Key ID, but use it (for now) with the same shared key. That way we should get DTLS 1.3 on par with DTLS 1.2 considering the drain game. Then we only have to solve #60...",
          "createdAt": "2021-07-12T14:40:07Z",
          "updatedAt": "2021-07-12T14:40:07Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "We discussed this on today's meeting and our proposal for going forward are the following:\r\n\r\n1. We want to re-run the TLS expoerter with an DTLS epoch related input to generate a new key. Preferably this should be a defined procedure in DTLS 1.3. And it makes sense if one have relatively long lived streams and rekey a lot, as the consuming function may need to derive new keys also due the limit in key-length. If not possible to do in DTLS 1.3 spec, we will define the procedure in the DTLS over SCTP spec. This gives us SCTP-AUTH key updates in synch with the DTLS key-updates.\r\n\r\n2. Use the same method for not having more than one older key present as for DTLS 1.2 also for 1.3.\r\n\r\n",
          "createdAt": "2021-07-16T09:33:08Z",
          "updatedAt": "2021-07-16T09:33:08Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "> Hmm. A hack: When changing the epoch, change also the Shared Key ID, but use it (for now) with the same shared key\r\n\r\nDoes just changing the SCTP-AUTH keyID but using the same key lead to any security problems? I don't know the details of SCTP-AUTH. If the Shared Key ID is integrity protected, I think we are fine. If it is not an attacker can change the Shared Key ID which would likely lead to attacks on availability.\r\n\r\nProbably good to derive new keys anyway using the context.",
          "createdAt": "2021-07-16T10:26:28Z",
          "updatedAt": "2021-07-16T10:26:28Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The keyid is just used to let the receiver know which key to use for processing. So I see no issue right now...",
          "createdAt": "2021-07-16T11:02:05Z",
          "updatedAt": "2021-07-16T11:02:05Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a new DTLS 1.3 issue regarding the lack of exporter rekeying\r\n\r\nhttps://github.com/tlswg/dtls13-spec/issues/253",
          "createdAt": "2021-07-16T11:04:50Z",
          "updatedAt": "2021-07-16T11:04:50Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there another issue needed for the following text in DTLS 1.3?\r\n\r\n\"Implementations\r\nSHOULD discard records from earlier epochs, but MAY choose to retain\r\nkeying material from previous epochs for up to the default MSL\r\nspecified for TCP [RFC0793] to allow for packet reordering.\"\r\n\r\nMy understanding is that RFC6083bis must and will violate this. If that is the case it would be good to soften the text in the DTLS 1.3 draft a bit.",
          "createdAt": "2021-07-16T11:07:10Z",
          "updatedAt": "2021-07-16T11:07:10Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree.",
          "createdAt": "2021-07-16T11:15:39Z",
          "updatedAt": "2021-07-16T11:15:39Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "This issue should not any longer be relevant with the changes in #70. ",
          "createdAt": "2021-10-22T15:27:52Z",
          "updatedAt": "2021-10-22T15:27:52Z"
        }
      ]
    },
    {
      "number": 60,
      "id": "MDU6SXNzdWU5NDIxMjQ1NDk=",
      "title": "DTLS 1.2 rengegotation: Implementation challenges to follow recommendation. ",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/60",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "gloinul"
      ],
      "labels": [],
      "body": " @tuexen don't know how to implement:\r\n```\r\nPrior to processing a received ClientHello message or ServerHello\r\nmessage, all other received SCTP user messages that are buffered in the\r\nSCTP layer and can be delivered to the DTLS layer MUST be read and\r\nprocessed by DTLS.\r\n```\r\nThe only way I so to do this, is to read SCTP messages until the receive buffer is empty. But what if the sender keeps sending faster than the receiver can read? The receiver can't say something like \"I want only read messages which where in the receiver buffer before the the ClientHello arrived\".",
      "createdAt": "2021-07-12T14:28:39Z",
      "updatedAt": "2022-06-14T13:20:00Z",
      "closedAt": "2022-06-14T13:19:59Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "We discussed this today and the text may need minor tweaks to be as clear as possible. However, there is a receiver side tracking issue. And @tuexen will write an API extension proposal for a receiver side tracking of when all user messages that hasn't been completed are no longer on the previous key, so that the DTLS layer can determine that it can process the key-update without stranding any data in its receiver buffer that was protected with the old key (n-1) when it generates key n+1. ",
          "createdAt": "2021-07-16T09:36:06Z",
          "updatedAt": "2021-07-16T09:36:06Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So with #70 the implementation issues have changed. Now we use the close_notify alert to tell the receiver that the key is no longer needed. But, it is up to the sender to verify reception of the packet. Under some API implementations this might be a challenge to do fully reliable. ",
          "createdAt": "2021-10-22T15:39:44Z",
          "updatedAt": "2021-10-22T15:39:44Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So I am closing this issue as the DTLS parallel connection rekeying can be implemented to my understanding on top of a RFC 6458 API. The issue of knowing when one have drained the old DTLS connection properly can be implemented with a timer based that is equal to the time it would take to consider the SCTP Association failing due to lack of progress on the TSN. \r\n\r\nThe shutdown procedure described in #94 deals with shutdown in a way using the API's drained indication. \r\n\r\nSo to my understanding this issue is resolved. ",
          "createdAt": "2022-03-03T11:28:29Z",
          "updatedAt": "2022-03-03T11:28:29Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> So I am closing this issue as the DTLS parallel connection rekeying can be implemented to my understanding on top of a RFC 6458 API. The issue of knowing when one have drained the old DTLS connection properly can be implemented with a timer based that is equal to the time it would take to consider the SCTP Association failing due to lack of progress on the TSN.\r\n\r\nThere is no such timer. It is completely valid that the peer closes its `rwnd` for an unlimited amount of time.\r\n\r\n> \r\n> The shutdown procedure described in #94 deals with shutdown in a way using the API's drained indication.\r\n> \r\n> So to my understanding this issue is resolved.\r\n\r\n",
          "createdAt": "2022-03-03T11:31:32Z",
          "updatedAt": "2022-03-03T11:31:44Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "There is no such timer. It is completely valid that the peer closes its rwnd for an unlimited amount of time.\r\n\r\n@tuexen doesn't a call of sendmsg actually have to have receiver window available for the call to succeed? Or there is this assumption that the kernel will have buffer space that is beyond what is available in receiver window?\r\n\r\nAnd the timer doesn't exist I agree, but an upper bound can be calculated for making progress on a TSN or the association fails prior to this. The time is Association.Max.Retrans * RTO.max and it will be minutes per default. \r\nBut, if you can commit data to the kernel per RFC6458 API without it making it into a transmission buffer that fits within the Receiver window then I agree this doesn't work. But, then the API description appears incomplete.",
          "createdAt": "2022-03-03T11:43:10Z",
          "updatedAt": "2022-03-03T11:43:10Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> There is no such timer. It is completely valid that the peer closes its rwnd for an unlimited amount of time.\r\n> \r\n> @tuexen doesn't a call of sendmsg actually have to have receiver window available for the call to succeed? Or there is this assumption that the kernel will have buffer space that is beyond what is available in receiver window?\r\n\r\nWhether a `sendmsg()` call succeeds depends on the size of the send buffer, if the atomic operations are used. But it does not depend on the size of the receive buffer of the peer. You can actually send user messages larger what fits in the receive buffer of the peer. That is why a partial delivery API is needed. WIthout that, the association would end up in a deadlock. This is described in [RFC 4960](https://datatracker.ietf.org/doc/html/rfc4960#section-6.9):\r\n```\r\nNote: If the data receiver runs out of buffer space while still\r\nwaiting for more fragments to complete the reassembly of the message,\r\nit should dispatch part of its inbound message through a partial\r\ndelivery API (see [Section 10]), freeing some of its receive buffer\r\nspace so that the rest of the message may be received.\r\n```\r\n\r\n> \r\n> And the timer doesn't exist I agree, but an upper bound can be calculated for making progress on a TSN or the association fails prior to this. The time is Association.Max.Retrans * RTO.max and it will be minutes per default. But, if you can commit data to the kernel per RFC6458 API without it \r\n\r\nThat is not true. That limit applies, if the peer does not respond anymore; you can provide an upper limit for detecting a dead peer. But don't you want to limit the time a user message is processed within the SCTP stack (time between it was provided by a `sendmsg()` call and it the last DATA chunk of it is acknowledged in a non-renegable way)? I do not see any way to provide an upper limit for that.\r\n\r\n> making it into a transmission buffer that fits within the Receiver window then I agree this doesn't work. But, then the API description appears incomplete.\r\n\r\nNot sure what is incomplete. Just to be clear:\r\n\r\n* `sendmsg()` calls are atomic unless explicit end of record marking is enabled. See [SCTP_EXPLICIT_EOR](https://datatracker.ietf.org/doc/html/rfc6458#section-8.1.26). Please note that this is an optional API feature and is not always implemented and it is only specified in the socket API, not in the generic API defined in [RFC 4960](https://datatracker.ietf.org/doc/html/rfc4960#section-10.1) This feature allows sending user messages larger than the send buffer size.\r\n\r\n* `recvmsg()` calls are not atomic, you always have to check the `MSG_EOR` flag. This is a mandatory feature and allows in particular handling user messages larger than the receive buffer size. This is mandatory since it is required to avoid deadlocks. That is why the partial delivery API is already covered in [RFC 4960](https://datatracker.ietf.org/doc/html/rfc4960#section-6.9), and not only in the Socket API specification, which is informational.",
          "createdAt": "2022-03-03T14:08:40Z",
          "updatedAt": "2022-03-03T14:08:40Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Okay sorry for unclear formulations. I believe I understand the difference here between sender buffer and the receiver buffer you are noting. So in this case we are back to the issue that unless you have an richer API that allows you to either query the stack specifically in relation to a user message, or some other abstraction that determines if user messages has been delivered you will not be certain that all messages has been delivered. \r\n\r\nThis will work in a very large percentage of the cases as it is such a long hold over time beyond when the last data sent with the old keys where committed to the SCTP association and when one closes the DTLS connection. However, it is not certain, and that requires the above API extensions.",
          "createdAt": "2022-03-03T14:46:29Z",
          "updatedAt": "2022-03-03T14:46:29Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So the new PR corrects the text in the draft to not make false claims. So this is clearly implementable by even an RFC 6458 API assuming tracking user messages sent prior to key change for SCTP-AUTH, although draining will be required.",
          "createdAt": "2022-03-03T15:31:37Z",
          "updatedAt": "2022-03-03T15:31:37Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "What I can judge now this issue is resolved. There are no claims on the timer based methods. There are API requirements and also a way for the sender to ensure that all has been delivered by draining the SCTP association. And for better performance you are going to need more advanced API. There are a potential for an SCTP-AUTH key drained API extension for the RFC 6458 API. ",
          "createdAt": "2022-06-14T13:19:59Z",
          "updatedAt": "2022-06-14T13:19:59Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWU5NDIxNDIxMjc=",
      "title": "Practical user message limitations due to renegotiation and key-update",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/62",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "gloinul"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "The current SCTP API spec have limited a user message to be authenticated by a single key. This leads to a limitation in that a single large user message needs to finish before more than one SCTP-AUTH key update happens. This results in a practical limitation of how big user messages that can be supported. This practical limits results in user messages that are much smaller than the theoretical upper limit. So depending on how often one target renegotiation, and what key life time one has on the used ciphers. The desire to rekey for PFS reasons are likely more restricting than the HMAC-SHA256 key life time.\r\n\r\nAlso for DTLS 1.3 key update the document is not clear if it can support multiple key epoch within a single user messages.\r\n\r\nSo at a minimal this limitation needs to be made clear. Alternatively we can enable user messages to use multiple epoch to support large user messages or user messages used as byte streams. However, that will likely come at a higher cost in implementation and tighter integration between DTLS and SCTP. So this likley need more investigation and discussion. ",
      "createdAt": "2021-07-12T14:47:41Z",
      "updatedAt": "2022-03-07T10:53:23Z",
      "closedAt": "2022-03-07T10:53:23Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "We discussed some alternative for this issue as potential direction we can continue. So this issue is only impacting very large user messages. For example an attempt to use a single user message as a continuous byte stream that is long lived will have issues. \r\n\r\n1. Accept the limitations and that user messages of sizes that are close to take the magnitude of the rekeying interval in transferring or the AEDA key byte limit in size will not work well with this. Continue to track the DTLS rekeying events based on SCTP-AUTH keys on the user level.\r\n\r\n2. That one require another API than the currently defined one. Then one can both use multiple different SCTP-Auth keys for a single user message. However, one would need to track which key(s) are using in which packets for a user messages so that one can determine when all packets with an older key have been delivered to the receiver so that one can rekey. \r\n\r\n3. Change the mapping between ULP user messages and its DTLS records to underlying SCTP user messages. If one track the fragmentation over SCTP user messages and when an ULP user messages is at its end then one can continue to use SCTP API as currently defined and enable rekeying in the middle of ULP user messages. \r\n\r\nBased on the known applications and API limitations in existing implementations, we think that alternative 1 is the one to recommend. However, if you have an SCTP using application that would have issues with the limitations: User messages can't be as long as the AEAD single key value limiations. The transfer of these uses messages must complete within a key-update period. \r\n\r\nWe will discuss this design choice with the WG. ",
          "createdAt": "2021-07-16T09:47:29Z",
          "updatedAt": "2021-07-16T09:47:29Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "With #70 the limitation is SCTP-AUTH API only. So for an API that does not allow one to change the SCTP-AUTH key for a message the maximum length is what can be transferred in the period between each periodic rekeying.",
          "createdAt": "2021-10-22T15:43:30Z",
          "updatedAt": "2021-10-22T15:43:30Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So if one uses RFC 6458 defined API for setting the SCTP-AUTH key. Then one can only set it on the start of the user message. That means that the rekeying using multiple DTLS connections will be affected. The impact to enable this to function are:\r\n- Allow that one continue to use old SCTP-Auth key ID after having created a new one for user messages that started with the old key. \r\n- The shutdown of the old DTLS connection will be delayed until all user messages using the corresponding SCTP-auth key have been sent. Then apply the normal hold period to avoid issues. \r\n- The above leads to recommendations that user message sizes should be kept short enough to avoid blocking rekeying, i.e. user messages must be completed within a small fraction of the expected rekeying interval. \r\n",
          "createdAt": "2022-02-22T16:54:35Z",
          "updatedAt": "2022-02-22T16:54:35Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "PR #93 notes the API limitation and notes the fact that message sizes needs to be such that transfer complete in short  time frame after rekeying to not block future rekeying.",
          "createdAt": "2022-02-28T16:50:38Z",
          "updatedAt": "2022-02-28T16:50:38Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWU5NDIxNTUyNTc=",
      "title": "DTLS-SCTP Association lifetime",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/63",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "We may need text for the fact that DTLS 1.2 and 1.3 is limited to 65535 rekeyings and then the DTLS assocation needs to be terminated and restarted in that case. This produces a limited association lifetime that may need to be made explicit in the document. ",
      "createdAt": "2021-07-12T15:01:34Z",
      "updatedAt": "2021-10-22T15:44:29Z",
      "closedAt": "2021-10-22T15:44:29Z",
      "comments": [
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe add to section 1.1.2.\r\n\r\nUsing DTLS 1.2 or DTLS 1.3 instead to using DTLS 1.0 limits the lifetime of a DTLS connection and the data volume which can be transferred over a DTLS  connection. Especially:\r\n* The number of renegotations in DTLS 1.2 is limited to 65534 compared to unlimited in DTLS 1.0.\r\n* The number of KeyUpdates in DTLS 1.3 is limited to 65532 and renegotiations are not supported.",
          "createdAt": "2021-07-12T15:13:46Z",
          "updatedAt": "2021-07-12T15:13:46Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Yes, I think that would make sense to add. Can you (@tuexen) create a PR for it? ",
          "createdAt": "2021-07-12T15:17:48Z",
          "updatedAt": "2021-07-12T15:17:48Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yepp, give me an hour or so...",
          "createdAt": "2021-07-12T15:38:51Z",
          "updatedAt": "2021-07-12T15:38:51Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Following the ANSSI recommendation and doing one rekeying once per hour it takes 7.5 years to reach epcoh 2^16 so that will not be a problem. But rekeying after 2^24.5 records could maybe be a problem. You can only send 2^40.5 DTLS AES-GCM records on a connection in DTLS 1.3.",
          "createdAt": "2021-07-12T15:47:58Z",
          "updatedAt": "2021-07-12T15:47:58Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So the maximum amount of data that can be sent is then on the order of  2^56.5 bytes under that ciphers limitation as we can at least send 2^16-1 bytes per DTLS record, happy we are not using IP MTU DTLS records.  ",
          "createdAt": "2021-07-12T16:57:39Z",
          "updatedAt": "2021-07-12T16:57:39Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So #64 has been merged, but lets think if we need in the next version to relate those numbers to actual limitation discussed in this thread? ",
          "createdAt": "2021-07-12T16:59:20Z",
          "updatedAt": "2021-07-12T16:59:20Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> So the maximum amount of data that can be sent is then on the order of 2^56.5 bytes under that ciphers limitation as we can at least send 2^16-1 bytes per DTLS record, happy we are not using IP MTU DTLS records.\r\n\r\nYou are correct, but in case the application is sending small user messages you end up using small DTLS records...",
          "createdAt": "2021-07-12T20:26:19Z",
          "updatedAt": "2021-07-12T20:26:19Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Following the ANSSI recommendation and doing one rekeying once per hour it takes 7.5 years to reach epcoh 2^16 so that will not be a problem. But rekeying after 2^24.5 records could maybe be a problem. You can only send 2^40.5 DTLS AES-GCM records on a connection in DTLS 1.3.\r\n\r\nDon't the same limits apply for DTLS 1.2 when using the same crypto algorithms? Just using renegotiations instead of key updates?",
          "createdAt": "2021-07-12T20:27:29Z",
          "updatedAt": "2021-07-12T20:27:29Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> So #64 has been merged, but lets think if we need in the next version to relate those numbers to actual limitation discussed in this thread?\r\n\r\nYepp, makes sense...\r\n",
          "createdAt": "2021-07-12T20:28:46Z",
          "updatedAt": "2021-07-12T20:28:46Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a DTLS 1.3 issue of this. Seem quite likely that it will be fixed\r\n\r\nhttps://github.com/tlswg/dtls13-spec/issues/249",
          "createdAt": "2021-07-14T22:31:53Z",
          "updatedAt": "2021-07-14T22:31:53Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a PR for DTLS 1.3\r\n\r\nhttps://github.com/tlswg/dtls13-spec/pull/250\r\n\r\n@gloinul @tuexen Is uint32 epoch enough? I.e. 2^56.5 AES-GCM records?",
          "createdAt": "2021-07-15T08:59:11Z",
          "updatedAt": "2021-07-15T08:59:11Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is there are reason why the epoch can't wrap around?",
          "createdAt": "2021-07-15T09:16:59Z",
          "updatedAt": "2021-07-15T09:16:59Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So uint32 epoch would be sufficient for time and total number of bytes when using large messages. So lets check if there is an issue if that each user message consumes one DTLS record. \r\n\r\nSo if an application sends a 200 byte user message (assume 250 bytes with overhead) and sends a lot of them to fill a 1 GBPS link. Then we can send 500,000 messages per second which is almost 2^19 messages. Which would deplete the range in 2^37.5, which is 6000 years. So if the user messages are 1 byte + overhead (25 bytes?) and the processing is capable of keeping up with 10 Gbps then we are down in the range of  below 10 years. So maybe to be certain a uint64 would be safer. As it is not needed to be sent, and if there are no limitations that is relevant for number of key derivations then I don't see an issue with going safe and declare it a unit64 instead. \r\n\r\n\r\n",
          "createdAt": "2021-07-15T10:29:10Z",
          "updatedAt": "2021-07-15T10:29:10Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So if we are going with outlined solution in #59 for how to deal with epoch changes, then wrap around is not the best, and we would prefer a sufficient long epoch. unit64 would be better to ensure long term safety, even if uint32 likely is sufficient. \r\n\r\nWhen the DTLS spec has been updated we need to reflect these changes in our spec so that limitations are correctly described. ",
          "createdAt": "2021-07-16T09:51:32Z",
          "updatedAt": "2021-07-16T09:51:32Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "DTLS 1.3 will go for a modulo solution with a 64 bit epoch of which 16 bits used in the record plaintext\r\n\r\nhttps://github.com/tlswg/dtls13-spec/pull/255\r\n\r\nThis PR has been approved but is not yet merged.",
          "createdAt": "2021-09-14T09:17:41Z",
          "updatedAt": "2021-09-14T09:17:41Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "With #70 this issue does no longer exist. ",
          "createdAt": "2021-10-22T15:44:29Z",
          "updatedAt": "2021-10-22T15:44:29Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWU5NDg0MDM0MjA=",
      "title": "Refer to RFC 7624 and discuss dynamic key exfiltration instead of static key exfiltration.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/65",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "RFC 7624 defines good terminology and discusses the problems with key exfiltration. We should refer to this document and add a few sentences about this (might replace some existing text in the security consideration).\r\n",
      "createdAt": "2021-07-20T08:04:15Z",
      "updatedAt": "2021-10-24T11:32:12Z",
      "closedAt": "2021-10-24T11:32:12Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The text from RFC 7624:\r\n\r\n   Key Exfiltration:  The transmission of cryptographic keying material\r\n      for an encrypted communication from a collaborator, deliberately\r\n      or unwittingly, to an attacker.\r\n\r\n The term \"key exfiltration\" refers to the transfer of keying material\r\n   for an encrypted communication from the collaborator to the attacker.\r\n   By \"static\", we mean that the transfer of keys happens once or rarely\r\n   and that the transferred key is typically long-lived.  For example,\r\n   this case would cover a web site operator that provides the private\r\n   key corresponding to its HTTPS certificate to an intelligence agency.\r\n\r\n   \"Dynamic\" key exfiltration, by contrast, refers to attacks in which\r\n   the collaborator delivers keying material to the attacker frequently,\r\n   e.g., on a per-session basis.  This does not necessarily imply\r\n   frequent communications with the attacker; the transfer of keying\r\n   material may be virtual.  For example, if an endpoint were modified\r\n   in such a way that the attacker could predict the state of its\r\n   pseudorandom number generator, then the attacker would be able to\r\n   derive per-session keys even without per-session communications.\r\n\r\n In this sense, static exfiltration has a lower risk profile than\r\n   dynamic.  In the static case, the attacker need only interact with\r\n   the collaborator a small number of times, possibly only once -- say,\r\n   to exchange a private key.  In the dynamic case, the attacker must\r\n   have continuing interactions with the collaborator.  As noted above,\r\n   these interactions may be real, such as in-person meetings, or\r\n   virtual, such as software modifications that render keys available to\r\n   the attacker.  Both of these types of interactions introduce a risk\r\n   that they will be discovered, e.g., by employees of the collaborator\r\n   organization noticing suspicious meetings or suspicious code changes.\r\n",
          "createdAt": "2021-07-22T07:43:16Z",
          "updatedAt": "2021-07-22T07:43:16Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "We should maybe also define PFS better.\r\n\r\nAs RFC 4949 writes about Perfect Forward Secrecy:\r\n\r\n\"while preparing this Glossary,\r\n we found this to be a muddled area. Experts did not agree. For all\r\n practical purposes, the literature defines \"perfect forward\r\n secrecy\" by stating the Diffie-Hellman-Merkle algorithm.\"\r\n\r\nWe should make sure to define what we mean. Useful text in RFC 4949 are:\r\n\r\n\"compromise of \"this\"\r\nencryption key is not supposed to compromise the \"next\" one.\r\nThere also is the idea that compromise of a single key will\r\ncompromise only the data protected by the single key.\"\r\n\r\nFrequent use of Diffie-Hellman in IKEv2 and DTLS 1.2 renegotiation limits\r\nthe effects of key compromise. In DTLS 1.3. a compromise of application_traffic_secret_N\r\ncompromise _all_ future application_traffic_secrets which make it unsuitable for\r\nsemi-permanent connections lasting years. Current ANSSI requirement for IPsec\r\nis to rerun Diffie-Hellman every hour.\r\n\r\n\r\n\r\n",
          "createdAt": "2021-07-22T07:43:58Z",
          "updatedAt": "2021-07-22T07:43:58Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "#70 security consideration section contains a bit of this. Is this fully resolved or are further improvements needed @emanjon.",
          "createdAt": "2021-10-22T15:45:47Z",
          "updatedAt": "2021-10-22T15:45:47Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it is done now",
          "createdAt": "2021-10-24T11:32:12Z",
          "updatedAt": "2021-10-24T11:32:12Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "I_kwDOEtjg5s47aQNl",
      "title": "Authentication",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/67",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The document is vary vague on authentication. The TLS spec unfortunatly give the idea it provides authentication. It does not. It provides proof of possesion of a key and provides information to enable the application to do authentication.\r\n\r\nSCTP/DTLS is very similar to HTTPS in this aspect. HTTPS clearly states how to do the identity authentication: The server certificate MUST contains a domain name in a subjectAltName field of type DNSname. The application MUST check that the  subjectAltName field of type DNSname is equal to the host name.\r\n\r\nWould it be possible to give more details to the implementation here. These are things that has to be done. Right now it is up to every implementation/deployment to specify this.\r\n\r\nCould we say that in case X.509 certificates are used, the client and server identity SHALL be stored in subjectAltName as DNSname or IPaddress and that the other party MUST check that the received identity is within a small restricted set of identities.",
      "createdAt": "2021-09-15T07:12:35Z",
      "updatedAt": "2021-10-25T09:25:21Z",
      "closedAt": "2021-10-25T09:25:21Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "#66",
          "createdAt": "2021-09-15T07:12:53Z",
          "updatedAt": "2021-09-15T07:12:53Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "We should maybe give some info on certificate lifetime. Certificate lifetime recommendations has drastically been lowered the last years. CAB Forum now has a maximum of 13 months and a lot of drive to shorten this further.\r\n\r\nhttps://www.globalsign.com/en/blog/maximum-ssltls-certificate-validity-now-one-year\r\nhttps://letsencrypt.org/2015/11/09/why-90-days.html\r\n\r\nThis is important as we want year long connections that might span many server certificates.",
          "createdAt": "2021-09-17T08:39:57Z",
          "updatedAt": "2021-09-17T08:39:57Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm wondering if this specification is the right place for it. I see this specification more as one which describes the combination of DTLS and SCTP. The point you raise is related to DTLS (and TLS), so I would say it would belong to the DTLS specification...",
          "createdAt": "2021-09-17T08:48:14Z",
          "updatedAt": "2021-09-17T08:48:14Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I don't think we need to discuss certificate lifetime in this. I think we simply need to ensure that we can handle fairly short life times. Which I think the parallel DTLS connection #70 do handle nicely as you can use the renewed certificate in the next DTLS handshake. There are even some basic requirement on ensuring that one have a concept for what is equal identity between the DTLS connections. \r\n",
          "createdAt": "2021-10-22T13:03:47Z",
          "updatedAt": "2021-10-22T13:03:47Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree, I think the draft should just notify the reader that these are things that need to be considered. DTLS/SCTP should not determine any details of the certificate, that is up to the application using DTLS/SCTP.\r\n",
          "createdAt": "2021-10-24T11:29:15Z",
          "updatedAt": "2021-10-24T11:29:15Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I removed the text that DTLS/SCTP MUST do certificate chain validation, and slightly reformulated the text in a new PR\r\n\r\nhttps://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/72\r\n\r\nAfter that is merged, this can be closed.",
          "createdAt": "2021-10-24T12:15:49Z",
          "updatedAt": "2021-10-24T12:15:49Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "#72 has been merged, lets close.",
          "createdAt": "2021-10-25T09:25:21Z",
          "updatedAt": "2021-10-25T09:25:21Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "I_kwDOEtjg5s49WUF1",
      "title": "Text on stream usage needs improvement",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/68",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "gloinul",
        "teiclap"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "\"DTLS records of content type \"application_data\", which carries the protected user messages, SHOULD use multiple streams other than stream 0; they MAY use stream 0. On stream 0 protected user messages as well as any DTLS messages that aren't record protocol will be mixed, thus the additional head of line blocking can occur.\"\r\n\r\nThis text appear to be a poor way of saying.  The ULP stream choice for a user message are to be maintained when the messages are protected by DTLS. However, the ULP could use Stream 0 for its messages, therefore could be a head of line blocking due to the DTLS conneciton messages when they are sent. Thus the ULP is RECOMMENDED to use other streams than Stream 0.",
      "createdAt": "2021-10-18T15:15:16Z",
      "updatedAt": "2022-03-04T17:21:45Z",
      "closedAt": "2022-03-04T17:21:45Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Some improvement are in PR #74 ",
          "createdAt": "2021-10-25T18:39:24Z",
          "updatedAt": "2021-10-25T18:39:24Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "There is also maybe need to clarify how DTLS messages for handshakes etc, i.e. non DTLS records for protected application data are handled in relationship to SCTP messages. If those are always sent in their own SCTP messages. ",
          "createdAt": "2021-10-25T18:41:09Z",
          "updatedAt": "2021-10-25T18:41:09Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "I_kwDOEtjg5s49roRV",
      "title": "DTLS 1.2 Rengotiation and parallel DTLS connections",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/73",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The current text on parallel DTLS connections do allow DTLS 1.2 Renegotiation However, we should consider forbidding the use of DTLS 1.2 renegotiation for several reasons. \r\n\r\n * Creates potential race condition between initiating new DTLS Connection and a renegotiation\r\n * With renegotiation we end up two different cases that creates SCTP-AUTH keys and the process needs to ensure that both sides installs the keys with the same key-ids or things will fail. \r\n * The renegotiation have draining requirement that works worse than new DTLS connection as there are no explicit indication when the old epoch has been fully delivered, and thus the key can be retired which increases exposure. \r\n * DTLS 1.2 Renegotiation is often disabled in implementations due to security concerns in non-mutual authenticated usages. \r\n\r\nAs we have a situation where a new DTLS connection can fulfill all that DTLS 1.2 renegotiation can do and it works for both DTLS 1.2 and 1.3 it would be simpler to use only new DTLS connections and not allow DTLS renegotiation to avoid the above issues. ",
      "createdAt": "2021-10-25T08:42:57Z",
      "updatedAt": "2021-11-02T13:08:12Z",
      "closedAt": "2021-11-02T13:08:12Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "We authors did make the choice to disallow renegotiation to avoid these issues making things simpler. ",
          "createdAt": "2021-11-02T13:08:12Z",
          "updatedAt": "2021-11-02T13:08:12Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "I_kwDOEtjg5s4-r2gQ",
      "title": "Security area recommends not using the term PFS",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/75",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See the following mail thread in SAAG.\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/saag/6ImeENhteXGdLsnaJHRoN6LW1zk/\r\n\r\nI think we should rephrase to talk about \"forward secrecy\" and protection against different kinds of key exfitration.",
      "createdAt": "2021-11-12T08:01:06Z",
      "updatedAt": "2021-12-24T07:30:25Z",
      "closedAt": "2021-12-24T07:30:25Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is done and can be closed.",
          "createdAt": "2021-11-20T15:51:41Z",
          "updatedAt": "2021-11-20T15:51:41Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "I_kwDOEtjg5s4-wUWZ",
      "title": "Resumption",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/76",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "emanjon"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "I looked into resumption a bit more and made an issue and a PR for RFC8446bis.\r\n\r\nThe question is if a ticket issued in connection N can be used in the parallel connection N+1. I see no reason why not except for the name \"resumption\".\r\n\r\nRFC8446 is clear on that a ticket issued in connection N can be used to set up the connections N+2 and N+3 in parallel.\r\n\r\nhttps://github.com/tlswg/tls13-spec/issues/1243\r\nhttps://github.com/tlswg/tls13-spec/pull/1244",
      "createdAt": "2021-11-14T05:45:14Z",
      "updatedAt": "2022-02-22T10:44:20Z",
      "closedAt": "2022-02-22T10:44:20Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The PR explainnig that resumption is allowed has been merged to RFC8446bis. ",
          "createdAt": "2021-11-15T06:03:12Z",
          "updatedAt": "2021-11-15T06:03:12Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I planned to do a PR but accidently commited directly to master. 28fa16d\r\nMaybe it can be reviewed in master.\r\n\r\n",
          "createdAt": "2021-11-15T08:55:05Z",
          "updatedAt": "2021-11-15T08:55:05Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I noted that the document does not give any guidance on tickets, but maybe this is ok or even the best solution.\r\nI don't think we need to say anything about ticket reuse in addition to what RFc8446 says.\r\nRight now there can be any number of tickets issues in any connections.\r\nIf a connection uses resuption, the ticket can come from any previous connection.\r\n\r\nAs a bit of an crazy example, something like the following is allowed by TLS 1.3:\r\n\r\nCon 1. Full handshake\r\nCon 2. Resumption with ticket 1A from Con 1\r\nCon 3. Resumption with ticket 1A from Con 1 \r\nCon 4. Full handshake\r\nCon 5. Resumption with ticket 2A from Con 2\r\nCon 6. Resumption with ticket 3A from Con 4\r\nCon 7. Resumption with ticket 1B from Con 1\r\nCon 8. Resumption with ticket 3A from Con 4\r\n\r\nFrom a TLS standpoint connections 1,2,3,5,7 would be connected and separate from connections 4,6,8\r\n",
          "createdAt": "2021-11-15T09:02:08Z",
          "updatedAt": "2021-11-15T09:21:28Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I think the changes looks good. With the many options regarding using tickets to do resumption for the new it is likely a feature. I think the only think we maybe need to think more about if there are interoperability issues here, so that one implementation do one set of resumption and the others only support another set and that results in failures. But if there are no such risks as the DTLS server roles will accept all, then I don't see an issue.\r\n\r\nAlso, do we need to clarify that if a resumption fails a full handshake fallback will be done, but I thought that this is implicit?\r\n",
          "createdAt": "2021-11-15T10:08:47Z",
          "updatedAt": "2021-11-15T10:08:47Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it never results in failure. The only thing that can happen is that one of the parties throws away the ticket.\r\n - If the client does not have a ticket, the client does not offer resumption.\r\n - If the client offers resumption but also supply a \"key_share\" (RFC8446 says SHOULD do that) the server rejects resumption and a full handshake is performed.\r\n - If the client offers resumption but did not supply a \"key_share\", I think the server will send a HelloRetryRequest and the handshake will continue with the client sending a new clientHello with a \"key_share\".\r\n\r\nI think TLS explains most of this, but maybe we would some clarification?\r\n",
          "createdAt": "2021-11-15T10:32:06Z",
          "updatedAt": "2021-11-15T10:32:06Z"
        }
      ]
    },
    {
      "number": 78,
      "id": "I_kwDOEtjg5s4_FTp8",
      "title": "SCTP API Considerations",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/78",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "gloinul"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "We need to consider if the API specification that is currently is at all useful with the updated. \r\nSecondly, if a more high level API Consideration for potentially missing functionality is more useful so that those that both future socket API specifications and proprietary APIs can consider what functionality simplifies supporting this specification. ",
      "createdAt": "2021-11-19T10:06:39Z",
      "updatedAt": "2022-03-07T11:09:26Z",
      "closedAt": "2022-03-07T11:09:26Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So I will make a proposal for a general API consideration section. \r\n\r\nI will leave the Socket API extension in place for now, even if the current functionality of that API is not really relevant awaiting to see if the API functionality discussed in #60 on how to determine that all packets related to a particular SCTP-auth key have been acked in a non-renegable way. ",
          "createdAt": "2022-03-04T13:29:25Z",
          "updatedAt": "2022-03-04T13:29:25Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "I_kwDOEtjg5s4_IbOs",
      "title": "More clarification on reauthentication",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/79",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current text lack any mention of sending updated revocation information, i.e. OSCP stapling. ",
      "createdAt": "2021-11-20T15:53:42Z",
      "updatedAt": "2021-12-24T07:29:46Z",
      "closedAt": "2021-12-24T07:29:46Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we can close this ",
          "createdAt": "2021-12-24T07:29:46Z",
          "updatedAt": "2021-12-24T07:29:46Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "I_kwDOEtjg5s5ApXND",
      "title": "Use PPID = 0 for DTLS handshake messages",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/80",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "teiclap"
      ],
      "labels": [],
      "body": "For DTLS messages that are not protected ULP user messages, it is not clear which PPID should be used in SCTP for these messages. @teiclap and I think using ppid=0 is fine for this as the DTLS/SCTP layer will be able to identify these messages based on the message itself. \r\n\r\nWe should also verify that it is clear the ULP protected messages shall use the PPID that was provided by the upper layer protocol.",
      "createdAt": "2021-12-20T09:57:29Z",
      "updatedAt": "2022-02-22T13:47:42Z",
      "closedAt": "2022-02-22T13:47:42Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Resolved by PR #95. ",
          "createdAt": "2022-02-22T13:47:42Z",
          "updatedAt": "2022-02-22T13:47:42Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "I_kwDOEtjg5s5BhWL4",
      "title": "Improve description of how fallback to RFC6083 works",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/81",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "gloinul"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "Li Yan commented on the TSVWG mailing list that backwards compatibility which really is fallback to RFC 6083 behavior needs to be better considered. Maybe the issue is that the description of this is not clear enough. \r\n\r\nPropose that we look over the text and clarify.",
      "createdAt": "2022-01-11T14:55:42Z",
      "updatedAt": "2022-03-07T10:43:24Z",
      "closedAt": "2022-03-07T10:43:24Z",
      "comments": []
    },
    {
      "number": 82,
      "id": "I_kwDOEtjg5s5BhXEC",
      "title": "Supplementary Note on Fragment reassembly",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/82",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "emanjon"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "From Li Yan:\r\n\r\nIt is better to add more description in section 4.1 in the current draft.\r\nThe description about how to reassemble the fragemented user message in the DTLS layer is not clear enough, and may cause confusion for readers.It is recommended to add further description about it.\r\nFor example\uff1a\r\nOn the receiving side, after getting the user_message\u2019 from SCTP,  DTLS makes use of the length field in the DTLS record header to decrypt the content of the first DTLS record to get m0, then m1......\r\nThe length field in DTLS record header is very import for decryption of each DTLS record.According to the length field, the receiving side knows the end of decryption of one DTLS record and the start of the next DTLS record.\r\nDetemining which DTLS record is the last one needs to use the overall length of the user_message\u2019 from SCTP to minus the lenght of each DTLS record.\r\nAfter the last DTLS record is decrypted, the user_message is reassembled: user_message = m0 | m1 | m2......",
      "createdAt": "2022-01-11T14:58:48Z",
      "updatedAt": "2022-02-22T10:44:06Z",
      "closedAt": "2022-02-22T10:44:06Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems good to add some more information on how different length fields are used in Fragment reassembly. Something as suggested above is likely helpful for the reader.",
          "createdAt": "2022-01-12T15:03:41Z",
          "updatedAt": "2022-01-12T15:03:41Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "> On the receiving side DTLS is used to decrypt the individual records. \r\n\r\nThis gives the wrong impression. Should also state that DTLS implentations can take any number of records. DTLS might be fed each record individually, the whole user_message\u2019, or anything in between.\r\n",
          "createdAt": "2022-02-15T11:39:41Z",
          "updatedAt": "2022-02-15T11:39:41Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "DTLS 1.3 states \"The final record in a datagram can omit the length field.\"\r\nWe should probably say something about this as well\r\nForbid this",
          "createdAt": "2022-02-15T11:45:46Z",
          "updatedAt": "2022-02-15T12:12:49Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Daria Ivanova also noted the need for better reassembly description. ",
          "createdAt": "2022-02-15T16:25:56Z",
          "updatedAt": "2022-02-15T16:25:56Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "I_kwDOEtjg5s5D4na_",
      "title": "2^64-1 bytes maximum user message size",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/84",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "gloinul"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "With the changes there might not in fact exist an clear limitation to user messages. Daria Ivanova asked if there was a reason for this limitation. \r\n\r\nSo there are no actual limitation of rekeying operations with the parallel DTLS connection solution. Thus there are no hard limit on SCTP association length. \r\n\r\nThe only reason I see for maintaining a 2^64-1 user message size restriction is to make it clear that you can assume that  64-bit pointers and offset and length fields in handling the data will be sufficient. 2^64 is also a very large number that are extremely unlikely to be consumed. At 1 Tbps it will take almost 4,7 years to transfer 2^64 bytes. And that is for a single user message in a single stream. So this utilizing SCTP like like some type of byte stream. \r\n\r\nI think one alternative is to make it clear that there are no hard limit, but that implementations are not required to support user messages larger than 2^64-1 bytes.",
      "createdAt": "2022-02-15T16:21:57Z",
      "updatedAt": "2022-03-07T10:53:23Z",
      "closedAt": "2022-03-07T10:53:23Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": ">I think one alternative is to make it clear that there are no hard limit, but that implementations are not required to support >user messages larger than 2^64-1 bytes.\r\n\r\nThat seems like a good alternative to me",
          "createdAt": "2022-02-16T09:26:07Z",
          "updatedAt": "2022-02-16T09:26:07Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree.",
          "createdAt": "2022-02-17T14:07:43Z",
          "updatedAt": "2022-02-17T14:07:43Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "I_kwDOEtjg5s5D4oTa",
      "title": "Comparision with DTLS handshake fragmentation",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/85",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "emanjon"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "In Section 4.1:\r\n\r\n\"The fragmentation works similar as the DTLS fragmentation of handshake messages.\" \r\n\r\nDaria Ivanova noted that this comparison is not accurate. It should be rewritten to actually describe the used mechanism. This is a companion issue to #82 which is the reassembly description part needing improved. ",
      "createdAt": "2022-02-15T16:24:57Z",
      "updatedAt": "2022-02-22T10:43:50Z",
      "closedAt": "2022-02-22T10:43:50Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, lets remove this comparison and rewrite it to actually describe the used mechanism. ",
          "createdAt": "2022-02-16T09:27:32Z",
          "updatedAt": "2022-02-16T09:27:32Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "I_kwDOEtjg5s5D4q5Q",
      "title": "DTLS/SCTP is an adaptation layer",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/86",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "gloinul"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "Daria Ivanova noted that there is a potential risk for a race condition between incomming DTLS handshake messages and the DTLS server in the implementations. \r\n\r\nSo this is clearly an implementation issue. From a protocol standpoint the SCTP server has been informed about the DTLS/SCTP adaptation layer usage and agreed to it. Thus, that implementation must be ready for DTLS handshake packets part of received user messages, even if the server instance has not yet brought the DTLS server instance up and is ready with all context. \r\n\r\nSo the question is if there is any need to note this protocol vs implementation detail in the draft?",
      "createdAt": "2022-02-15T16:33:43Z",
      "updatedAt": "2022-02-22T10:52:50Z",
      "closedAt": "2022-02-22T10:52:50Z",
      "comments": [
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "The draft must ensure that an implementation is possible but not how to solve race conditions, on the other hand in the specific the race condition may be due to that implementation.\r\nI wouldn't write something like \"avoid race conditions\" in the draft.",
          "createdAt": "2022-02-17T14:06:54Z",
          "updatedAt": "2022-02-17T14:06:54Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I agree we should not write \"avoid race conditions.\" But one could potentially write something like this. \r\n\r\nWhen the SCTP Association handshake has concluded with successful negotiation of DTLS/SCTP adaptation layer it is assumed that any DTLS message may be sent by either peer. Implementations that does not have a DTLS endpoint immediately ready on SCTP handshake completion will have to ensure correct caching of the messages until the endpoint is ready.\r\n",
          "createdAt": "2022-02-17T15:17:55Z",
          "updatedAt": "2022-02-17T15:17:55Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with the proposed text",
          "createdAt": "2022-02-17T15:26:48Z",
          "updatedAt": "2022-02-17T15:26:48Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "I_kwDOEtjg5s5D415p",
      "title": "DTLS/SCPT interaction with SCTP shutdown need to be clarified",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/87",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "teiclap"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "Daria Ivanova noted some unclarity in the procedures around shutdown. This needs to be clarified and also the implementation implications are relevant. Using a worst case time as might be acceptable for the rekeying with parallel DTLS conencection are not acceptable during graceful shutdown as that will take 10 min then.\r\n\r\nThe application intiaties a shutdown request to the DTLS/SCTP layer. \r\n\r\n1. DTLS/SCTP Flush its buffer and get any DTLS/SCTP layer buffered user data protected and sent to SCTP. \r\n2. SCTP sends data and await SACK from peer to know all has been delivered. Then DTLS/SCTP layer can issue DTLS Close Notify.\r\n3. DTLS/SCTP stack sends CLOSE_notify.\r\n4. SCTP sends DTLS Close_notify to peer. Now the SCTP stack close can be initiated to get the SCTP stack into SHUTDOWN pending state.\r\n5. When peer side get DTLS Close_Notify on the last DTLS connection, that is a signal for shutdown procedure. \r\n6. Then the left does corresponding to 2-4. \r\n7. SCTP association is shutdown. \r\n\r\nSo this needs to be clarified in document. ",
      "createdAt": "2022-02-15T17:07:28Z",
      "updatedAt": "2022-03-07T10:42:29Z",
      "closedAt": "2022-03-07T10:42:29Z",
      "comments": [
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "Do we mean that peer A initiates shutdown, it flushes data, closes DTLS and then waits for peer B to do the same and at the end it will be peer B doing the same and finally asking for SCTP shutdown?\r\n",
          "createdAt": "2022-02-17T14:18:49Z",
          "updatedAt": "2022-02-17T14:18:49Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "> Do we mean that peer A initiates shutdown, it flushes data, closes DTLS and then waits for peer B to do the same and at the end it will be peer B doing the same and finally asking for SCTP shutdown?\r\n\r\nYes, for a controlled shutdown the DTLS stack must have gotten indication that all its data is delivered, i.e. SCTP SACK messages must be received in A to verify the delivery of all user message so that DTLS can be closed. And first when that is achieved and DTLS close_notify has been sent can the shutdown pending happen. There are some asynchronous behavior here and also depending on SCTP API knowing that the data has been delivered can be challenging for fastest possible controlled shutdown. ",
          "createdAt": "2022-02-17T15:11:07Z",
          "updatedAt": "2022-02-17T15:11:07Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that since DTLS/SCTP and SCTP are not tied, it would be better peer A to shutdown the SCTP association once he has sent Close_Notify as it's the actual initiator of the shutdown procedure.",
          "createdAt": "2022-02-17T15:19:30Z",
          "updatedAt": "2022-02-17T15:19:30Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "> I think that since DTLS/SCTP and SCTP are not tied, it would be better peer A to shutdown the SCTP association once he has sent Close_Notify as it's the actual initiator of the shutdown procedure.\r\n\r\nYes, I fail to see what in my description do not indicate that? \r\n\r\nFor peer A DTLS/SCTP to send its close_notify it need to know that all data has been sent by SCTP in peer A at a minimal. I also think for safe controlled close it is required to know that the peer B has actually received the data also, to not result in closing the peers stack can't process any delayed data by the SCTP association encountering packet losses that would be received after the close notify.",
          "createdAt": "2022-02-17T15:26:45Z",
          "updatedAt": "2022-02-17T15:26:45Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I opened the following issue on the DTLS 1.3 draft\r\n\r\nhttps://github.com/tlswg/dtls13-spec/issues/268\r\n",
          "createdAt": "2022-02-22T10:48:38Z",
          "updatedAt": "2022-02-22T10:48:38Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "An error in the above is that the shutdown initiator needs to wait for the DTLS Close notify from the peer before it can enter shutdown-pending. Otherwise the peer's end of the SCTP association will be blocked for sending prior to it having a chance to flush its DLTS/SCTP layer data to SCTP. \r\n\r\n@emanjon also realized that the DTLS 1.3 specification is missing text about that out of order delivery, like between streams and the reception of the DTLS close_notify that is needs will not work well. So from DTLS/SCTP perspective what should happen is that the DTLS stack can process the DTLS Close notify, tell DTLS/SCTP of its repecption, which blocks accepting more data from ULP, flush any pending data and send its close notify. However, the DTLS stack should not be closed down until SCTP shutdown has completed, then the keys for the DTLS Session can be flushed. \r\n\r\n",
          "createdAt": "2022-02-22T10:50:45Z",
          "updatedAt": "2022-02-22T10:50:45Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "@tuexen I think your question in the https://github.com/tlswg/dtls13-spec/issues/268 discussion may be better answered here: \"Just wondering... On the sender side you already have reference counting for keys to implement `SCTP_AUTH_FREE_KEY` in the [SCTP_AUTHENTICATION_EVENT](https://datatracker.ietf.org/doc/html/rfc6458#section-6.1.8). So wouldn't it be a simple extension to add a `SCTP_AUTH_DRY_KEY` way?\"\r\n\r\nI don't see how this helps the implementation in any way. The DTLS/SCTP layer is the one owning the DTLS connections. It will know when these have been closed and thus know when it can do SCTP shutdown. \r\n\r\nIt might be that I am misunderstanding what you propose here so if you want to elaborate? \r\n",
          "createdAt": "2022-03-03T10:02:28Z",
          "updatedAt": "2022-03-03T10:02:28Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Daria pointed out an issue that needs clarifying if the endpoints have two DTLS connections. \r\n\r\n1. Switch over has occurred to the later DTLS Connection, and one is only draining the older one. \r\n\r\n2. In the process of establishing a second DTLS connection and one have not yet switched over. \r\n\r\n\r\nSo in case of 1 and receiving a close notify on the older DTLS connection. Then that endpoint does not yet know if this is a shutdown procedure or simply the closing of the older parallel DTLS conneciton being removed. Thus, it must so far assume that it is close down of the older one only. Only when the close notify is being received on the newer also will one go into shutdown procedure. If one receive the close notify on the newer one but not yet on the older one, I would still not enter shutdown in the remote side although currently it looks like the \"local\" side have no way of sending additional data. The close_notify on the older DTLS Connection needs to be on its way. \r\n\r\nFor case 2. I think we need to clarify if one can abort the DTLS connection establishment, or need to conclude the establishment for then immediately close it. \r\n",
          "createdAt": "2022-03-03T11:18:53Z",
          "updatedAt": "2022-03-03T11:18:53Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "The PR for this issue is #94.",
          "createdAt": "2022-03-03T11:19:26Z",
          "updatedAt": "2022-03-03T11:19:26Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @tuexen I think your question in the [tlswg/dtls13-spec#268](https://github.com/tlswg/dtls13-spec/issues/268) discussion may be better answered here: \"Just wondering... On the sender side you already have reference counting for keys to implement `SCTP_AUTH_FREE_KEY` in the [SCTP_AUTHENTICATION_EVENT](https://datatracker.ietf.org/doc/html/rfc6458#section-6.1.8). So wouldn't it be a simple extension to add a `SCTP_AUTH_DRY_KEY` way?\"\r\n> \r\n> I don't see how this helps the implementation in any way. The DTLS/SCTP layer is the one owning the DTLS connections. It will know when these have been closed and thus know when it can do SCTP shutdown.\r\n> \r\n> It might be that I am misunderstanding what you propose here so if you want to elaborate?\r\n\r\nI was thinking about when to send the CloseNotify message. If you are trying to shut down the last DLTS connection on an SCTP association, you could use the sender dry event to make sure all other user messages have been received by the peer. But if you want to shut down a DTLS connection and still have other DTLS connections being active (and you don't want to affect them), you would need an indication that all user messages belonging to the DTLS connection you try to shutdown have been received by the peer, you could use a (to be defined) key dry event.\r\n\r\nI want to delay the sending of the CloseNotify message until all messages belonging to the DTLS connection about to be shut down have been received by the peer.\r\n\r\nDoes that makes things clearer? Or am I misunderstanding something?\r\n",
          "createdAt": "2022-03-03T14:53:55Z",
          "updatedAt": "2022-03-03T14:53:55Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Thanks @tuexen I now understand. I am not used to thinking in this API. But, to paraphrase. One way is to define an event that fires ones all user messages with a specific SCTP-AUTH key ID has been sent.\r\n",
          "createdAt": "2022-03-03T15:34:38Z",
          "updatedAt": "2022-03-03T15:34:38Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes. To be more precisely: an event that fires if no user message in the SCTP stack using this key ID is available anymore.\r\n\r\nIt is not about \"has been sent\" but more \"has been acked in a non-renegable way\".\r\n\r\nIf you are willing to include this in the document, I'm willing to provide text as long as that stuff will not be covered by an IPR owned by Ericsson. This would allow me to implement it in the FreeBSD stack.",
          "createdAt": "2022-03-03T17:18:08Z",
          "updatedAt": "2022-03-03T17:18:23Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "The PR #94 has been updated to address the case of ongoing DTLS handshake process. ",
          "createdAt": "2022-03-04T16:18:07Z",
          "updatedAt": "2022-03-04T16:18:07Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "I_kwDOEtjg5s5D43hu",
      "title": "Only applies to initial handshake. ",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/88",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "gloinul"
      ],
      "labels": [
        "PR exists"
      ],
      "body": " The initial DTLS connection will be used to establish a new shared\r\nsecret as specified per DTLS version below, and which MUST use shared\r\nkey identifier 1.  After sending the DTLS Finished message, the\r\nactive SCTP-AUTH key MUST be switched to the new one.  Once the\r\ninitial Finished message from the peer has been processed by DTLS,\r\nthe SCTP-AUTH key with Shared Key Identifier 0 MUST be removed.\r\n\r\nSome unclarity apparently exist related to the above paragraph. Middle sentence can be clarified to say that one must switch from key-id 0 to key-id 1 which is will occur for the initial DTLS handshake. \r\n\r\n",
      "createdAt": "2022-02-15T17:13:35Z",
      "updatedAt": "2022-02-22T10:43:31Z",
      "closedAt": "2022-02-22T10:43:31Z",
      "comments": []
    },
    {
      "number": 100,
      "id": "I_kwDOEtjg5s5FJKRi",
      "title": "Ensuring same DTLS connection for SCTP-AUTH and SCTP User message in Data Chunk",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/100",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "gloinul"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "In #60 there was the proposal of defining a new SCTP Socket API feature that allows one to determine when the sending stack has had all SCTP packets with a specific SCTP-AUTH key-id having been ACKed in a non-renegable way. \r\n\r\nIf that is going to be a good indicator that all ULP protected user message DTLS records for the corresponding DTLS connection that exported the SCTP-AUTH key some additional rules appear to be required. The current rule and a RFC6458 implementation has no way of sending SCTP packets with a newer DTLS connection SCTP-AUTH key than what has been used. So as long as the DTLS/SCTP implementation starts using the new DTLS connection to protect new ULP user messages and possibly also to complete ongoing ones, there will never be any DTLS records for the old connection in a SCTP packet with the newer SCTP-AUTH key. \r\n\r\nHowever, a more flexible API could follow the current text and switch SCTP-AUTH key immediately while still having DTLS records for the old DTLS connection in the packet. Thus, I think a clarification is necessary that the SCTP-AUTH key used must never be newer than the DTLS records being carried. It is okay to use the old key in SCTP-AUTH for newer DTLS records. \r\n",
      "createdAt": "2022-03-04T20:33:40Z",
      "updatedAt": "2022-06-21T07:57:30Z",
      "closedAt": "2022-06-21T07:57:29Z",
      "comments": []
    },
    {
      "number": 103,
      "id": "I_kwDOEtjg5s5FNoXV",
      "title": "Different close_notify behaviour in DTLS 1.2 and DTLS 1.3",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/103",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "gloinul"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "The draft is written to align with (D)TLS 1.3 behaviour. DTLS 1.2 do however have a different behaviour. DTLS 1.2 will soon be obsolete but likely needs to be supported short-time.\r\n\r\nSection 6.1 of RFC 8446 explains the differences:\r\n\r\n```\r\n   Each party MUST send a \"close_notify\" alert before closing its write\r\n   side of the connection, unless it has already sent some error alert.\r\n   This does not have any effect on its read side of the connection.\r\n   Note that this is a change from versions of TLS prior to TLS 1.3 in\r\n   which implementations were required to react to a \"close_notify\" by\r\n   discarding pending writes and sending an immediate \"close_notify\"\r\n   alert of their own.  That previous requirement could cause truncation\r\n   in the read side.  Both parties need not wait to receive a\r\n   \"close_notify\" alert before closing their read side of the\r\n   connection, though doing so would introduce the possibility of\r\n   truncation.\r\n```\r\n",
      "createdAt": "2022-03-07T10:21:41Z",
      "updatedAt": "2022-06-21T07:57:31Z",
      "closedAt": "2022-06-21T07:57:31Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I can think of two likely reasonable solutions to this issue.\r\n\r\nA) Require DTLS 1.3 as that avoids the issue with the DTLS 1.2 Close Notify alert behavior. It also avoids version related negotiation issues at this stage of the protocol but they can resurface with a DTLS 1.4. Also it requires DTLS 1.3 stack immediately.\r\n\r\nB) We define a DTLS/SCTP message and registers a PPID for it and identify it that way. Thus the initiating party tells the peer that it want to close and have stopped incoming and have drained its queue. When peer process this message on DTLS/SCTP layer it will close for more incoming data and drain its buffer. When that is accomplished it sends the close_alert that is then echoed back by the original requesting endpoint. \r\n\r\nSo lets consider the impact of the options and make a recommendation to the WG. ",
          "createdAt": "2022-03-28T13:51:24Z",
          "updatedAt": "2022-03-28T13:51:24Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "I_kwDOEtjg5s5FOuOZ",
      "title": "Negotiating DTLS version between 1.2 and 1.3",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/104",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "emanjon"
      ],
      "labels": [],
      "body": "The specification is supporting both DTLS 1.2 and DTLS 1.3. Do we need a discussion how an client or server can negotiate which DTLS version to use and are there a downgrade risk here. And can that be handled in other ways that having the ULP mandate particular versions?\r\n",
      "createdAt": "2022-03-07T14:23:52Z",
      "updatedAt": "2022-06-21T12:01:17Z",
      "closedAt": "2022-06-21T12:01:16Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I assume the DTLS version negotiation is handled by the DTLS handshake and that nothing more is needed, or? If both sides support DTLS 1.3, they will never negotiate anything lower.\r\n\r\nWe should definitly explain how the negotiation of the DTLS version is done.",
          "createdAt": "2022-03-16T14:00:33Z",
          "updatedAt": "2022-03-16T14:00:33Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So the reason i was raising this issue are the interoperability issues, and the relationship to usage of DTLS/SCTP for various ULPs.\r\n\r\nFirst of all we have no discussion of the fact that in the generic case one endpoint can support version X and the other Y and that can lead to failure. \r\n\r\nSecondly, there exist potential for downgrade attacks if one version is weaker than the other and supporting both on server side. \r\n\r\nThird, the possible need for an ULP to be actually dictate what applies for DTLS/SCTP usage for that particular ULP. This I assume will be the norm for the 3GPP protocols where 3GPP Specs will define which DTLS version(s) is to be used and supported.",
          "createdAt": "2022-03-18T12:36:03Z",
          "updatedAt": "2022-03-18T12:36:03Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, looks like we should have some discussion about this. We should maybe also say more about fallback to RFC 6083 and the interoperability and downgrade attacks there.\r\n\r\n> First of all we have no discussion of the fact that in the generic case one endpoint can support version X and the other Y and that can lead to failure.\r\n\r\nYes, should acknoledge that there might be failure. One option could be to mandate one or more versions. For 3GPP use cases, 3GPP would like to follow the 3GPP TLS profile, which takes care of interoperability between releases. so I don't thing it is needed for 3GPP.\r\n\r\n> Secondly, there exist potential for downgrade attacks if one version is weaker than the other and supporting both on server side.\r\n\r\nFor DTLS there are no downgrade attacks. DTLS protects against that. There are likely downgrade attacks when falling back to RFC 6083\r\n\r\nWe should say that the same DTLS version SHALL be used when setting up a new DTLS connection in the same SCTP association. I think that is missing.\r\n",
          "createdAt": "2022-06-14T10:12:24Z",
          "updatedAt": "2022-06-14T10:12:24Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Fallback to RFC 6083 and downgrade attacks are alrady described. Closing this issue.",
          "createdAt": "2022-06-21T12:01:16Z",
          "updatedAt": "2022-06-21T12:01:16Z"
        }
      ]
    },
    {
      "number": 106,
      "id": "I_kwDOEtjg5s5FQHHv",
      "title": "Inconsistent statement about DTLS 1.3 Epochs",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/106",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "emanjon"
      ],
      "labels": [],
      "body": "The procedures of Section 4.2.1 of [I-D.ietf-tls-dtls13] are irrelevant. When receiving DTLS packets using epoch n, no DTLS packets from earlier epochs are received.\r\n\r\nFrom a parallel stream perspective I think there exist a probability that the DTLS connection will be asked to handle DTLS records out of order and over epoch boundaries.\r\n\r\nIn general I think we should shorten Section 4.9, and also as we are not using this procedures, should the section saying don't use these rather be in Section 3? \r\n\r\n",
      "createdAt": "2022-03-07T19:49:20Z",
      "updatedAt": "2022-06-22T15:28:21Z",
      "closedAt": "2022-06-22T15:28:20Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "One idea would be to remove 4.9 and put informatioin in 3 and 4.8\r\n\r\n`\"Epochs will not be used as renegotiation is disallowed.\"\r\n`\r\nThis is not correct, DTLS start with epoch 0 and then changes to 1 in the middle of the handshake",
          "createdAt": "2022-06-21T10:32:41Z",
          "updatedAt": "2022-06-21T10:32:41Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "My understanding is that\r\n- DTLS 1.2 will use epochs 0 and 1\r\n- DTLS 1.3 will use epochs 0,2,3 (if KeyUpdate is used then 4,5,6,....) ",
          "createdAt": "2022-06-21T11:06:42Z",
          "updatedAt": "2022-06-21T11:06:42Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Epoch 0 is unencrypted so that is not a problem. In DTLS 1.3 the Client Finished will use epoch=2, everything after that will use epoch=3.\r\n\r\n```\r\n\r\n   Client                                             Server\r\n   ------                                             ------\r\n\r\n    Record 0\r\n    ClientHello\r\n    (epoch=0)\r\n                               -------->\r\n                                                        Record 0\r\n                               <--------       HelloRetryRequest\r\n                                                       (epoch=0)\r\n    Record 1\r\n    ClientHello                -------->\r\n    (epoch=0)\r\n                                                        Record 1\r\n                               <--------             ServerHello\r\n                                                       (epoch=0)\r\n                                           {EncryptedExtensions}\r\n                                                       (epoch=2)\r\n                                                   {Certificate}\r\n                                                       (epoch=2)\r\n                                             {CertificateVerify}\r\n                                                       (epoch=2)\r\n                                                      {Finished}\r\n                                                       (epoch=2)\r\n    Record 2\r\n    {Certificate}              -------->\r\n    (epoch=2)\r\n    {CertificateVerify}\r\n    (epoch=2)\r\n    {Finished}\r\n    (epoch=2)\r\n                                                        Record 2\r\n                               <--------                   [ACK]\r\n                                                       (epoch=3)\r\n    Record 3\r\n    [Application Data]         -------->\r\n    (epoch=3)\r\n                                                        Record 3\r\n                               <--------      [Application Data]\r\n                                                       (epoch=3)\r\n\r\n```\r\n",
          "createdAt": "2022-06-21T11:59:36Z",
          "updatedAt": "2022-06-21T11:59:36Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Merged PR removed sections 4.9. Some statements in 4.9 were incorrect and 4.9 did not fill any purpose. The same topics are handled in other sections.",
          "createdAt": "2022-06-22T15:28:20Z",
          "updatedAt": "2022-06-22T15:28:20Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "I_kwDOEtjg5s5F3UWb",
      "title": "Do we need better recommendations for Receiver Buffer sizing?",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/107",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "gloinul"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "Daria raised a potential issues: \r\n\r\n\"Retransmission negatively impacts on performance. So, it would be good to recommend to set receiver buffer side at least to 2*(2048 + 13(or more because header of message with CID is longer than usual header of DTLS record) + 2^14 )  for such traffic.\" \r\nThis is for traffic that does not support I-DATA but send multiple messages at the same time but in continuous TSN ranges to fit the whole message. \r\n\r\nSo I think we need to consider if it should be clarified how to interact with the SCTP receiver buffer. ",
      "createdAt": "2022-03-17T09:25:55Z",
      "updatedAt": "2022-06-21T07:56:51Z",
      "closedAt": "2022-06-21T07:56:51Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't know where the numbers above come from (except 2^14), but note that DTLS 1.2 has quite varying overhead based on the cipher suite.\r\n\r\nhttps://datatracker.ietf.org/doc/html/draft-mattsson-uta-tls-overhead\r\n\r\n\r\n",
          "createdAt": "2022-06-14T10:01:21Z",
          "updatedAt": "2022-06-14T10:01:21Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So to start with these numbers. I think the 2048 is actually to ensure a complete SCTP packet fits, where 2048 would be plenty for common MTU. The 13 is DTLS overhead and as stated it might be more than 13. 2^14 is clearly the maximum DTLS record. The two times I would say is to avoid the stalling of SCTP as each DTLS record is being processed by DTLS and then the clear text copied/transferred into ULP's memory space.\r\n\r\nHowever, to me it looks like going into detail here might actually result in errors or faulty assumptions. So I think we want to keep the advice general. We already have this text:\r\n\r\n   The security operations and reassembly process requires that the\r\n   protected user message, i.e., with DTLS record overhead, is buffered\r\n   in the receiver. This buffer space will thus put a limit on the\r\n   largest size of plain text user message that can be transferred\r\n   securely. However, by mandating the use of the partial delivery of\r\n   user messages from SCTP and assuming that no two messages received\r\n   on the same stream are interleaved (as it is the case when using\r\n   the API defined in {{RFC6458}}) the required buffering prior to\r\n   DTLS processing can be limited to a single DTLS record per used\r\n   incoming stream. This enables the DTLS/SCTP implementation to\r\n   provide the Upper Layer Protocol (ULP) with each DTLS record's\r\n   content when it has been decrypted and its integrity been verified\r\n   enabling partial user message delivery to the ULP. Implementations\r\n   can trade-off buffer memory requirements in the DTLS layer with\r\n   transport overhead by using smaller DTLS records.\r\n\r\nI would think the clarification here is to avoid retransmissions or flow control stalls due to lack of receiver space it would be good to have more than a single DTLS record with overhead per stream. So I think a minor clarification about the potential impact here of having to little space. ",
          "createdAt": "2022-06-15T11:35:09Z",
          "updatedAt": "2022-06-15T11:35:09Z"
        }
      ]
    },
    {
      "number": 108,
      "id": "I_kwDOEtjg5s5F8vMZ",
      "title": "Mandate non-zero CID values in DTLS",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/108",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "In Section 4.1 of -03 there is this sentence:\r\n\r\n\"Thus, it is RECOMMENDED to not use the zero length CID values and instead use a single common length for the CID values.\"\r\n\r\nDaria commented that to avoid the implementation handling of zero-length case why not mandate that non-zero MUST be used?\r\n\r\nI think that is a valid idea, especially as non-zero is not suitable and only result in extra issues in this usage.",
      "createdAt": "2022-03-18T12:41:01Z",
      "updatedAt": "2022-04-22T10:17:41Z",
      "closedAt": "2022-04-22T10:17:41Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems like a good idea to me.",
          "createdAt": "2022-03-21T11:40:15Z",
          "updatedAt": "2022-03-21T11:40:15Z"
        }
      ]
    },
    {
      "number": 111,
      "id": "I_kwDOEtjg5s5IQAFM",
      "title": "Removing SCTP Socket API extension? ",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/111",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "PR exists"
      ],
      "body": "There was discussion on the TSVWG mailing list about RFC 4895 bis. I that happens the socket API extension would make more sense to have in the context of this document. So the question is to assume that this will happen and actually remove the Socket API extension and only maintain a general API Consideration in this document.  ",
      "createdAt": "2022-04-22T10:14:10Z",
      "updatedAt": "2022-06-21T07:57:13Z",
      "closedAt": "2022-06-21T07:57:13Z",
      "comments": []
    },
    {
      "number": 116,
      "id": "I_kwDOEtjg5s5LzkXf",
      "title": "Update references",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/116",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "RFC 4960 has been replaced by RFC 9260. So after current set of PR has been dealt with lets do a change of the references.",
      "createdAt": "2022-06-15T07:43:43Z",
      "updatedAt": "2022-06-21T08:09:06Z",
      "closedAt": "2022-06-21T08:09:06Z",
      "comments": []
    },
    {
      "number": 123,
      "id": "I_kwDOEtjg5s5PKO3c",
      "title": "Key update",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/123",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-1.1.2-4.2 says:\r\n\r\n> Enable DTLS key-change without requiring draining all inflight user message from SCTP.\r\n\r\nI think that you are talking about key updates.  This is a feature of DTLS 1.3, not DTLS 1.2, so it might be worth pointing that out.\r\n\r\n",
      "createdAt": "2022-08-04T05:21:24Z",
      "updatedAt": "2022-09-06T07:54:54Z",
      "closedAt": "2022-09-06T07:54:54Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "No, this is actually not referring to the DTLS 1.3 specific key-update, instead it is referring to the general aspect of key-exchange. RFC 6083 if one is using renegotiation in DTLS 1.2 or DTLS 1.3 Key-update one may in both cases end up in a situation where DTLS handling of old keys results in that the old key is discard prior to all old records having been received and processed. \r\n\r\nWill address this with an update to #157.",
          "createdAt": "2022-09-05T12:11:15Z",
          "updatedAt": "2022-09-05T12:11:15Z"
        }
      ]
    },
    {
      "number": 124,
      "id": "I_kwDOEtjg5s5PKPPT",
      "title": "Consider using `<sup>` for exponents",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/124",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "There are few places you use these and it can be confusing.  For instance, \"2^64-1\" might be obvious, but it would be better as \"2<sup>64</sup>-1\" (`2<sup>64</sup>-1`).\r\n\r\nThis won't change how the text version is rendered in most cases, unless there was a genuine error, such as might occur if `2^64-x` was really supposed to be `2<sup>64-x</sup>`.  xml2rfc has some logic to add parentheses as needed for those cases.",
      "createdAt": "2022-08-04T05:23:47Z",
      "updatedAt": "2022-09-05T12:51:05Z",
      "closedAt": "2022-09-05T12:51:05Z",
      "comments": []
    },
    {
      "number": 125,
      "id": "I_kwDOEtjg5s5PKP_7",
      "title": "\"semi-permanent\" might be better as \"long-lived\"",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/125",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Permanent or not, there is no semi-permanent.  Half of infinity is still infinity.  And in this business, there is no permanent.",
      "createdAt": "2022-08-04T05:28:43Z",
      "updatedAt": "2022-09-05T13:31:00Z",
      "closedAt": "2022-09-05T13:31:00Z",
      "comments": [
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "Semi-permanent is a definition from the telecom world, it's strictly related to the circuit switched network.\r\nA semi-permanent connection is something that once set-up will never be removed.\r\nThe use of \"semi-permanent\" can be explained in the document but it's different from long-lived.",
          "createdAt": "2022-08-16T07:15:04Z",
          "updatedAt": "2022-08-16T07:15:04Z"
        }
      ]
    },
    {
      "number": 126,
      "id": "I_kwDOEtjg5s5PKQT3",
      "title": "Use definition lists for terminology and definitions",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/126",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In markdown this goes from:\r\n\r\n```md\r\nAEAD: Authenticated Encryption with Associated Data\r\n\r\nDTLS: Datagram Transport Layer Security\r\n```\r\n\r\nto:\r\n\r\n```md\r\nAEAD:\r\n: Authenticated Encryption with Associated Data\r\n\r\nDTLS:\r\n: Datagram Transport Layer Security\r\n```\r\n",
      "createdAt": "2022-08-04T05:30:37Z",
      "updatedAt": "2022-09-05T13:31:15Z",
      "closedAt": "2022-09-05T13:31:15Z",
      "comments": []
    },
    {
      "number": 127,
      "id": "I_kwDOEtjg5s5PKQ_H",
      "title": "Overview material is lacking",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/127",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "gloinul"
      ],
      "labels": [],
      "body": "When I got to Section 3.3, I still had no idea how DTLS and SCTP interacted with each other.  So I had no basis for understanding what the text was attempting to say.  Maybe consider adding some material ahead of Section 3 that describes how the two protocols interact at a high level.",
      "createdAt": "2022-08-04T05:34:49Z",
      "updatedAt": "2022-09-07T15:34:46Z",
      "closedAt": "2022-09-07T15:34:46Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "The same applies to connection ID usage.  This is mentioned as being mandatory: \"As this solution requires multiple connection IDs,\" but there is no basis for understanding that claim.",
          "createdAt": "2022-08-04T06:28:38Z",
          "updatedAt": "2022-08-04T06:28:38Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Yes, we clearly should add a section describing how DTLS/SCTP operates as a layer between the ULP and the SCTP stack, and how it uses parallel connections and identifies the incoming DTLS records and messages based on the connection ID. ",
          "createdAt": "2022-09-05T14:04:54Z",
          "updatedAt": "2022-09-05T14:04:54Z"
        }
      ]
    },
    {
      "number": 128,
      "id": "I_kwDOEtjg5s5PKRVc",
      "title": "Plural/singular issues",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/128",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This is a bit challenging for authors who don't speak English natively.  Throughout the document there are numerous cases where a plural was used where a singular was required, and vice versa.  As a native speaker, I found this quite distracting in an otherwise clear document.",
      "createdAt": "2022-08-04T05:36:55Z",
      "updatedAt": "2022-09-06T08:00:30Z",
      "closedAt": "2022-09-06T08:00:30Z",
      "comments": []
    },
    {
      "number": 129,
      "id": "I_kwDOEtjg5s5PKSD0",
      "title": "Key updates mid-message",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/129",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "gloinul"
      ],
      "labels": [
        "Needs PR"
      ],
      "body": "https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-3.3-3 says:\r\n\r\n> Thus, user messages that will be transmitted over periods of time on the order or longer than the interval between rekeying can't be supported.\r\n\r\nI had a little trouble dealing with the implications of this.  I infer that this means that all user messages are sent exclusively with a single key.  If there is a key update, user messages that were initially sent with the old key will be completed using the old key.  Any new user messages will be sent with the new key.\r\n\r\nThis material is right up front, but it is pretty deep stuff.  Your reader is very much unprepared for dealing with this information.  Consider moving this to a later portion of the document.\r\n\r\n",
      "createdAt": "2022-08-04T05:41:05Z",
      "updatedAt": "2022-09-27T09:10:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So, I think we need to consider if we need to pull together a new section where we discuss implementation\r\n limitations impact on the ULP. So keeping this open until we have gone over more of the text and restructuring and clarifications.",
          "createdAt": "2022-09-06T14:47:22Z",
          "updatedAt": "2022-09-06T14:47:22Z"
        }
      ]
    },
    {
      "number": 130,
      "id": "I_kwDOEtjg5s5PKSpV",
      "title": "DTLS record size limit",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/130",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "teiclap"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-3.3-4 says:\r\n\r\n> Implementations can trade-off buffer memory requirements in the DTLS layer with transport overhead by using smaller DTLS records. \r\n\r\nThis is not true unless you use the [record size limit extension](https://datatracker.ietf.org/doc/html/rfc8449) for DTLS (RFC 8449).  The sender determines the record size, but the receiver is the one that has to commit the buffers.  Consider recommending use of RFC 8449 here.",
      "createdAt": "2022-08-04T05:44:30Z",
      "updatedAt": "2022-10-07T08:12:27Z",
      "closedAt": "2022-10-07T08:12:27Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "There is a proposal for how to deal with this issue in #132. ",
          "createdAt": "2022-09-07T14:49:10Z",
          "updatedAt": "2022-09-07T14:49:10Z"
        }
      ]
    },
    {
      "number": 131,
      "id": "I_kwDOEtjg5s5PKTTK",
      "title": "Processing fragments and flow control",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/131",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "gloinul"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-3.3-4 says:\r\n\r\n> However, for efficient operation and avoiding flow control stalls if user message fragments are not frequently and expiendtly moved to upper layer memory buffers, the receiver buffer needs to be larger.\r\n\r\n(Note the typo here: expediently; though there might be a better word to use for this.)\r\n\r\nI don't think that this is good advice.  Or maybe this is unclear and it could be improved.  It would be ideal if the SCTP stack, with its flow control, is used to maintain back-pressure on the sending side.  Pulling data out of buffers in the stack and putting them somewhere (\u00af\\\\\\_(\u30c4)\\_/\u00af) hides the buffering from the flow control mechanism.  I'm pretty sure that you aren't suggesting that, but this might be read as doing that.",
      "createdAt": "2022-08-04T05:48:35Z",
      "updatedAt": "2022-10-07T08:13:44Z",
      "closedAt": "2022-10-07T08:13:44Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So in relation to the text I wrote in #135 I would note that there is a need to move data from the receiver window into the DTLS record reassembly so that they can be timely dispatched. \r\n\r\nThe aspect of back-pressure is possible to do. So that if the ULP don't read buffered decrypted data the DTLS/SCTP layer don't read up new data into the re-assembly buffer to keep the data buffered in the receiver DTLS/SCTP layer limited.\r\n\r\nI think this is part of a re-write around buffering and its implementation to take care of the other aspects that #135 discusses. ",
          "createdAt": "2022-09-07T09:36:32Z",
          "updatedAt": "2022-09-07T09:36:32Z"
        }
      ]
    },
    {
      "number": 132,
      "id": "I_kwDOEtjg5s5PKUOB",
      "title": "DTLS maximum record size",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/132",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "teiclap"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-3.5-1 says:\r\n\r\n> [...] DTLS can send maximum sized DTLS Records.\r\n\r\nThis is almost certainly bad advice.  Some DTLS implementations can't handle arbitrary-sized records, so you might find that things fail if you handshake with 2<sup>14</sup> bytes in a record.  For performance reasons, you probably want smaller records in many cases.  Aligning record sizes to the MTU can make sense as well.  \r\n\r\nSee also my recommendations about RFC 8449 in #130, which addresses a resource protection issue.  In addition to that, you might recommend keeping record sizes small until you know what the size limit is.",
      "createdAt": "2022-08-04T05:54:26Z",
      "updatedAt": "2022-10-07T08:18:15Z",
      "closedAt": "2022-10-07T08:18:15Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Yes, we will have to consider RFC 8449. I can understand how DTLS record size are not expected for really large sizes but, I would have thought this would have been a lesser issue due to the TLS origin where larger records should be common. \r\n\r\nHowever, using IP MTU sized DTLS record just increases the overhead. SCTP provides the re-assembly layer and also the exact data portion per DATA chunk is not necessary static. So that aspect appear to have its downsides too. \r\n",
          "createdAt": "2022-09-07T08:20:44Z",
          "updatedAt": "2022-09-07T08:20:44Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "@martinthomson when you write that some implementation can't handle arbitrary-sized records, do you mean that they have a limitation for example at 4096 bytes records, but is able to handle a sequence of 1239, 3456, 4096, and 56 bytes large records? Or that they all need to be of size X unless it is the last? ",
          "createdAt": "2022-09-07T14:10:02Z",
          "updatedAt": "2022-09-07T14:10:02Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So @teiclap and I did discuss this. I will assume that you mean that Martin meant the first above that implementations don't support larger than a particular size that is less than 2^14. \r\n\r\nBased on how DTLS/SCTP is intended to be used and for interoperability I think the reasonable way forward here is to default to require the DTLS stack do support max sized (2^14) bytes DTLS records. Implementation that want to negotiate a lower maximum DTLS records SHALL use RFC 8449 to accomplish that. Thus, if one want to do any small records for the reasons discussed in the text that was brought up in issue #130 it will also require RFC 8449. \r\n\r\nConsidering that RFC 6083 has required full size DTLS record support also, and that RFC 8449 is additional implementation requirement we propose to not require RFC 8449 support, and if an endpoint is not capable of supporting 2^14 DTLS records and the peer does not support RFC 8449 one will be at an impasse and will have to terminate the SCTP association due to non-interoperability. \r\n\r\nWe also note that to avoid massive implementation complexities the implementations MUST NOT change the maximum DTLS Record size negotiated using the RFC 8449 TLS extension. This as DTLS/SCTP needs to be aware of this limitation to control its data fragmentation process. And forcing a change of the data fragmentation mid message that such a rekeying could result in would result in some complexities.  ",
          "createdAt": "2022-09-07T14:47:37Z",
          "updatedAt": "2022-09-07T14:47:37Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "This seems reasonable.  I would expect some level of recommendation about 8449 support so that you don't get the interop failure.",
          "createdAt": "2022-09-07T23:36:46Z",
          "updatedAt": "2022-09-07T23:36:46Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I think SHOULD/RECOMMENDED support of RFC8449 for general deployments of DTLS/SCTP and some usage of this could simply mandate RFC8449 support. But will think more about this as we draft spec text. ",
          "createdAt": "2022-09-08T06:28:14Z",
          "updatedAt": "2022-09-08T06:28:14Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to DTLS record size, the section 3.5 describes only the PMTU, I think that the current text is proper.\r\nThe description of the interaction between DTLS/SCTP and 8449 has been rewritten in my PR for issue #130 ",
          "createdAt": "2022-09-08T09:37:04Z",
          "updatedAt": "2022-09-08T09:37:04Z"
        }
      ]
    },
    {
      "number": 133,
      "id": "I_kwDOEtjg5s5PKU9U",
      "title": "Buffering and implementation choice",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/133",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "gloinul"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-4.1-7 says:\r\n\r\n> Whether to decrypt individual records, sequences of records, or the whole user_message' is left to the implementation.\r\n\r\nThis might be read to imply that there is some flexibility in how records are constructed, but I don't believe that to be the case.  What this means then is that the receiver can choose to buffer entire user messages before processing them.  This is probably not sensible, unless the receiver knows that it is always able to receive entire messages - and it has a way of handling oversized messages that arrive.",
      "createdAt": "2022-08-04T05:59:07Z",
      "updatedAt": "2022-10-07T08:17:30Z",
      "closedAt": "2022-10-07T08:17:30Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Yes, you are correct, there is an assumption that the re-assembly buffer in DTLS/SCTP will dispatch a DTLS record as soon as it is complete to DTLS processing. So this should be changed. Based on the discussion in #131, #135 I think we need to describe a buffer model that is intended to work any how it enables things like back pressure in case the receiving application is not consuming the data etc. ",
          "createdAt": "2022-09-07T15:34:04Z",
          "updatedAt": "2022-09-07T15:34:04Z"
        }
      ]
    },
    {
      "number": 134,
      "id": "I_kwDOEtjg5s5PKWS6",
      "title": "Connection IDs at the DTLS layer",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/134",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "PR exists"
      ],
      "body": "https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-4.1-11 says:\r\n\r\n> The DTLS Connection ID MUST be negotiated ([[RFC9146](https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#RFC9146)] or Section 9 of [[RFC9147](https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#RFC9147)]). If DTLS 1.3 is used, the length field in the record layer MUST be included in all records.\r\n\r\nThis will result in connection IDs appearing in chunks all over the place as DTLS records are fragmented and sent in different chunks.  Consequently, this will rarely be useful for routing purposes, meaning that it is just wasteful.\r\n\r\nIsn't there a better mechanism within SCTP for labeling chunks with this sort of routing information?  If there isn't why not build one?",
      "createdAt": "2022-08-04T06:06:26Z",
      "updatedAt": "2022-10-07T08:23:08Z",
      "closedAt": "2022-10-07T08:23:08Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "OK, there were a few more clues scattered through Section 4 that hinted at why this is the case.  This is a surprising design, so please take time to consider #127.",
          "createdAt": "2022-08-04T06:35:57Z",
          "updatedAt": "2022-08-04T06:35:57Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So, with PR #166 I think the question of why we use them not to route, but to determine crypto context for the decryption operation should be clear enough. ",
          "createdAt": "2022-09-06T13:48:19Z",
          "updatedAt": "2022-09-06T13:48:19Z"
        }
      ]
    },
    {
      "number": 135,
      "id": "I_kwDOEtjg5s5PKYPd",
      "title": "DTLS 1.3 sequence numbers are too small for this design",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/135",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "gloinul"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-4.1-11 says:\r\n\r\n> A 16-bit sequence number SHOULD be used rather than 8-bit to minimize issues with DTLS record sequence number wrapping.\r\n\r\n(This should be in a separate paragraph.)\r\n\r\nThis is a good requirement, but it needs to be better explained.  I think that the reason for this requirement is that SCTP might retransmit DTLS records that are marked as lost, creating a much longer in-flight time than otherwise.\r\n\r\nThat suggests a genuine problem with this design.  DTLS 1.3 assumes that there is no reliability for the delivery of datagrams, so it adjusts its sequence number size down accordingly.  If retransmissions occur over the course of multiple PTOs, for example, the effective time of flight for a DTLS record increases by a lot more than ever anticipated.  For a high BDP connection, that could be a big problem.\r\n\r\nAs far as I can tell, there is no real constraints on the sequencing of DTLS records into user messages[^1].  You could imagine sequence numbers for the same message being sequential if the message is written out all at once, but you can also imagine messages that are sent progressively over time with non-contiguous sequence numbers being used.  That being the case, you can't really have the receiver take special steps to recover the sequence number.  They have two equally valid frames of reference: the last record received from that user message, the last record received for the connection, or rather the highest sequence number received in each case.\r\n\r\n[^1]: As far as I can tell, you could put sequence numbers in reverse or random order within the same user message as long as you don't double them up.",
      "createdAt": "2022-08-04T06:16:26Z",
      "updatedAt": "2022-10-07T08:24:57Z",
      "closedAt": "2022-10-07T08:24:57Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So this likely should be expanded on in the specification as the implementor has been given something which gives them the potential for screwing up and that the sender actually might have to implement some guard function against overlapping the sequence number. \r\n\r\nFirst of all there are two timescales at play here. One is the API constraints and the especially the limitation on SCPT-AUTH API in RFC6458 that one can't change the AUTH key within a single SCTP user message. That results in that one can't retire a key potentially in timescales measured in minutes if someone uses a user message as something like a byte stream and add a bit of data now and then. This is not how SCTP is being used by an application that I know of, but it could occur. Therefore we have tried to ensure as general support as possible. But, if one use one user message as byte stream and have an RFC 6458 SCTP-AUTH API the SCTP association will be forced to be terminated when one run of key usages on either the first or second DTLS connection. So this forces the parallel DTLS connection need. \r\n\r\nThe other timescale is that of the DTLS records and how they are used in a multi-stream application, even one with large user messages that being gradually expanded on. So the model I have here is that we have several streams which there will be new random sized user messages being sent by the ULP. The DTLS/SCTP layer when it gets a send this (partial) ULP data in a particular user message it will fragment this new data into DTLS Records and then being protected by the DTLS stack. I expect a DTLS implementation to process individual DTLS record data protections to be handled in some for of sequential behaviour to generate a consecutive sequence numbers. Thus the sequence number will represent the order in which the protection operation is request from the DTLS implementation. Thus, even if we have multiple concurrent ULP data send request they will be happen as processing threads request the fragmented data to be protected and then dispatched to the SCTP send function to the different SCTP user messages. So here process scheduling level reordering can occur between data blocks. Then the SCTP stack takes the data and when it schedules it for transmission it will add it to its send buffer, i.e. which is limited by the receiver window. \r\n\r\nWhen transmitting and packet loss occurs these packet loss and the data delivery and delivery of DTLS records to the receiver side DTLS/SCTP processing can in worst case be one complete receiver window out of order. This as even with SACK the receiver window can't progress until the cumulative ACK has happened, which it can't be if the missing data is lost. \r\n\r\nSo on the receiver side if the receiver diligently reads out the data from the SCTP stack and adds it to its buffers and then request decryption as soon as each DTLS Record is complete, the request ordering here is dependent on data arrival and process scheduling between the different streams and user messages. Thus also on this side some variation in order can be added but on this short time scale. \r\n\r\nThus by having an implementation that is avoiding significant variations in how often it reads and process the different message the maximum out of order processing will be in relation to the receiver window. Thus if the sequence number times average used DTLS Record sizes are a couple of multiples of the receiver window there should be no issue. \r\n\r\nBut if the DTLS/SCTP sender buffers a significant amount of data between protection operation and when the data makes it into the send buffer then that increase the risk. This is something a sender side implementation should ensure by tracking the amount of DTLS records in flight to avoid overlapping the sequence number. This is something it anyway needs some capability to do  for the rekeying. The receiver could also buffer unnecessary amount and thus cause issues with out-of-order processing. \r\n\r\nThus, a small anti-replay window is a real issue. However the sequence number space should be not be a real practical problem. However, I see the need to at least point out the need to avoid poor implementation that could result in issues due to overlapping sequence numbers.  ",
          "createdAt": "2022-09-07T09:27:26Z",
          "updatedAt": "2022-09-07T09:27:26Z"
        }
      ]
    },
    {
      "number": 136,
      "id": "I_kwDOEtjg5s5PKZSt",
      "title": "DTLS anti-replay might fail",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/136",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "PR exists"
      ],
      "body": "...spectacularly.\r\n\r\n#135 outlines an issue with sequence numbers, but the problem extends to DTLS replay protection.  Having more records that are effectively in flight means that you need an anti-replay window that is large enough to cover all those messages.  Where DTLS messages might be retransmitted (over multiple PTOs even), that window might need to be very large.  Many DTLS implementations are unable to tune the size of this window (NSS has a fixed 1024-message window), so that will just lead to records failing to be accepted.  \r\n\r\nThis manifests as a decryption failure, which effectively creates a fourth [failure mode](https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-4.1-8.1): where the anti-replay falsely marks a record as being a replay - not because it is, but because the sequence number is outside of the window it is actively tracking.\r\n\r\nGiven how this sort of error results in connections being torn down, that is not likely to produce very good results.\r\n\r\nFWIW, I don't find the analysis [here](https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-4.1-12) compelling.  I think that #130 and #132 already cover the record size assumption; and I don't see a 64kbit anti-replay window as credible.",
      "createdAt": "2022-08-04T06:21:33Z",
      "updatedAt": "2022-10-07T08:24:44Z",
      "closedAt": "2022-10-07T08:24:44Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Yes, that is why we have a put in a requirement to turn that off, see https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#name-replay-protection. If that is not possible then that is an issue that can reduce the amount of stacks available to this usage. \r\n\r\nWill consider the editorial if anti-replay should be listed as a failure mode to with a pointer to where we mandate it as off. \r\n\r\nI will expand the sequence number motivation a bit in #135 to explain why it should work and there is a difference between the sequence number aspect and the key-lifetime. \r\n\r\n",
          "createdAt": "2022-09-07T08:33:26Z",
          "updatedAt": "2022-09-07T08:33:26Z"
        }
      ]
    },
    {
      "number": 137,
      "id": "I_kwDOEtjg5s5PKcvJ",
      "title": "When is a DTLS endpoint ready?",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/137",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-4.2-2 says:\r\n\r\n> Implementations that do not have a DTLS endpoint immediately ready on SCTP handshake completion will have to ensure correct caching of the messages until the DTLS endpoint is ready.\r\n\r\nWhich messages is this talking about?  Is this an attempt to deal with protected user messages that arrive before the DTLS handshake is complete?\r\n\r\nI don't think that \"ready\" is what you are looking for here.  You are seeking to ensure that the DTLS handshake is in a state where application_data records can be accepted.",
      "createdAt": "2022-08-04T06:34:06Z",
      "updatedAt": "2022-09-06T07:54:21Z",
      "closedAt": "2022-09-06T07:54:21Z",
      "comments": []
    },
    {
      "number": 138,
      "id": "I_kwDOEtjg5s5PKdzw",
      "title": "Forced caching",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/138",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This design essentially forces receivers to cache DTLS records for each active DTLS connection establishment.  Because decryption failure is so disastrous, if there is any race between a TLS Finished and records for that connection, a receiver might be stuck caching more than they might ordinarily be prepared to handle.  Does the SCTP flow control manage this properly?",
      "createdAt": "2022-08-04T06:38:43Z",
      "updatedAt": "2022-09-27T08:35:52Z",
      "closedAt": "2022-09-27T08:35:52Z",
      "comments": [
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "SCTP flow control mechanism is based on SACK and prevents caching more than what can be possibly handled.\r\n",
          "createdAt": "2022-09-02T12:16:44Z",
          "updatedAt": "2022-09-07T09:10:49Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So in the bottom we have the SCTP stack and its receiver window which can contain data from various user message in transit at least when I-DATA is used. The protected user messages are either whole (if smaller) or partially read by DTLS/SCTP. As soon as a DTLS/SCTP has a complete DTLS record it can request decryption of it, and then take that part of the ULP data and provide it to the ULP. Thus, the amount of cached data in the DTLS/SCTP layer is one DTLS record per stream. So this caching of data is necessary for the function of DTLS/SCTP. If an receiving ULP does not read the unprotected data and DTLS/SCTP actually would run out of memory to hold that data that would result in a pushback when the receiver buffer fill up as DTLS/SCTP stops consuming data. So from the perspective the flow control aspects do work. \r\n\r\nWhen it comes to DTLS connection closing that is why we have defined a procedure. So the peer will not send a close until it knows that the data have been completely ACKed by the receiver, thus all that data can be read by the receiver application. Thus, ensuring that a receiver will have read up all data protected by the DTLS connection before it can receive Ready_to_Close. So before actually closing the DTLS Connection, the implementation can ensure that all cached records are processed, and then close the connection. \r\n\r\nSo, yes there are a certain amount of minimal buffering required, but it is quite limited to maintain functionality. And the DTLS/SCTP layer will result in back pressure to the sender side if the ULP do not read the data. I hope that answers your concern. ",
          "createdAt": "2022-09-06T14:37:18Z",
          "updatedAt": "2022-09-06T14:37:18Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Closing this as answered as PR #169 should additional clarify this issue. ",
          "createdAt": "2022-09-27T08:35:52Z",
          "updatedAt": "2022-09-27T08:35:52Z"
        }
      ]
    },
    {
      "number": 139,
      "id": "I_kwDOEtjg5s5PKflF",
      "title": "Arbitrary DTLS record, arbitrary stream",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/139",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "question"
      ],
      "body": "https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-4.4-2 says:\r\n\r\n> DTLS records of other types MAY be sent on any stream. \r\n\r\n...except that not always:\r\n\r\n> However, DTLS messages of other types than protected user message MUST be sent reliable, so the DTLS record can only be interleaved in case the ULP user message is sent as reliable.\r\n\r\n(\"protected user message\" is not a thing in DTLS)\r\n\r\nWhy allow this?  This creates a real challenge for managing DTLS connection state if messages that affect it might appear anywhere.\r\n\r\nYou could instead mandate [this](https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-4.4-4):\r\n\r\n> A simple solution avoiding any protocol issue are to send all DTLS messages that are not protected user message fragments is to pick a stream not used by the ULP, send the DTLS messages in their own user messages with in order delivery.  That mimics the RFC 6083 behavior without impacting the ULP. However, it assumes that there are available streams to be used based on the SCTP association handshake allowed streams (Section 5.1.1 of [[RFC9260](https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#RFC9260)]).\r\n\r\nI don't understand the caveat here, but I don't think that it is unreasonable to reserve one stream for handshakes.  The ULP can just allocate one extra stream.  It would be even better if there was a parallel construct (like QUIC's CRYPTO frames) that didn't result in impinging on ULP stream limits, but I can see how that might be considered \"too hard\".",
      "createdAt": "2022-08-04T06:46:57Z",
      "updatedAt": "2022-10-13T07:47:46Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So the issue is that when you retrofitting DTLS security on to SCTP with an ULP that also is well established we want to to avoid changing either in any significant way, only slot in our adaptation layer. Therefore we can't be expect to dictate that we can dictate that stream 0 for example is always used for DTLS messages. \r\n\r\nSo we can't really mandate the good recommendation as that caveat can be real. SCTP negotiates a maximum number of streams. In worst case someone sits on a very purpose built SCTP stack that will negotiate two streams and really only support that because the ULP only needs two streams. So I think mandating using an additional stream may cause issues.\r\n\r\nIt might also be that this looks unnecessary complex. If one disregards any head of line blocking issues and simply ensures to send the DTLS messages not carrying ULP data in individual in-order delivered individual SCTP messages they will be processed in the right order. The DTLS/SCTP implementation simply will get SCTP user message with a DTLS message and process it with DTLS and that will either result in data or some other DTLS stack API result. But it will not really know this when using DTLS 1.3 prior to submitting the data. \r\n\r\nIt was this anyway black box behaviour so from a receiver perspective it doesn't matter on which stream a DTLS Handshake arrive or a DTLS Close_alert. For these control messages all streams are the same stream. It is only for protected user data that the stream and particular user message matters as that maintain the API between DTLS/SCTP and SCTP for the ULP. \r\n\r\nSo any specific reason you think that allowing it to be on any stream creates more headache than having them on a singular stream @martinthomson?",
          "createdAt": "2022-09-07T15:30:06Z",
          "updatedAt": "2022-09-07T15:30:06Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "@martinthomson we plan to close this by draft deadline if no additional feedback is provided. ",
          "createdAt": "2022-10-12T14:47:38Z",
          "updatedAt": "2022-10-12T14:47:38Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "Specific reasons that I can think of:\r\n\r\n1. Stream level flow control with just data + DTLS overheads tends to be fairly predictable in terms of the cost you pay for DTLS protection.  However, if large DTLS messages are send on a stream, like handshakes with certificates, the accounting for that overhead becomes entirely unpredictable.\r\n\r\n2. Processing of DTLS handshake state requires centralized processing, but the processing of the record layer does not.  For an endpoint that distributes processing load for streams, this adds a new sort of overhead.  Rather than engaging with just decryption logic, it has to either engage the centralized DTLS infrastructure for every record (which affects performance) or include logic to manage record protection and then route non-application_data records for further processing.  The first has high contention, the latter requires that you break your DTLS implementation down in new ways.\r\n\r\nThere is an alternative that doesn't consume streams: describe a new message/chunk type to carry DTLS handshake (or non-application_data) records.  The DTLS handshake already supports the fragmentation necessary to avoid the reassembly, retransmission, and other features that streams might provide.",
          "createdAt": "2022-10-12T22:25:42Z",
          "updatedAt": "2022-10-12T22:25:42Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Thanks for elaboration. I think we could go the PPID route here also for separation. But, independently what you are asking for is in facto to make the DTLS control messages explicitly visible where they currently will not be when using DTLS 1.3. This would have not been an issue if DTLS 1.3 hadn't dropped the type field as plain text field, so we are talking about reversing that choice by the TLS WG in this application. ",
          "createdAt": "2022-10-13T07:47:45Z",
          "updatedAt": "2022-10-13T07:47:45Z"
        }
      ]
    },
    {
      "number": 140,
      "id": "I_kwDOEtjg5s5PKhJv",
      "title": "Negotiating the SCTP-AUTH hash",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/140",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "emanjon"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "It seems like you might benefit from setting the SCTP-AUTH hash to the hash function used by the negotiated TLS PRF.  This would allow for stronger authentication that matches the negotiated TLS parameters.",
      "createdAt": "2022-08-04T06:54:22Z",
      "updatedAt": "2022-10-07T08:05:09Z",
      "closedAt": "2022-10-07T08:05:09Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So currently SCTP-AUTH only support SHA-1 and SHA-256, where we require the later. Which to my understanding matches what is the default PRF in DTLS 1.2. I fail to full understand what the algorithms are used by the HKDF in TLS 1.3. \r\n\r\nBut the implication for this specification would be to basically say, prefer to use an SCTP-AUTH hash algorithm that matches hash algorithm used by the TLS PRF and HKDF respectively? ",
          "createdAt": "2022-09-07T15:09:03Z",
          "updatedAt": "2022-09-07T15:09:03Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "> prefer to use an SCTP-AUTH hash algorithm that matches hash algorithm used by the TLS PRF and HKDF respectively?\r\n\r\nI think Martin suggests to have a one-to-one mapping between the hash function in the negotiated TLS cipher suite and the SCTP-AUTH hash algorithm. That is a good idea in theory but I think it has a lot of problems. \r\n- To my understanding SCTP-AUTH is used before the TLS handshake. Can the algorithms even be changed in the middle of an association?\r\n- TLS_AES_256_GCM_SHA384 could not be used as SHA-384 is not defined for SCTP AUTH\r\n- There are discussions to standardize new SCTP AUTH algorithms with 128 bit tags, these would then not be usable by DTLS/SCTP.\r\n\r\nAs long as we forbid SHA-1 to be used, there is currently no practical benefits with securely negotiating the hash function. \r\n\r\nWe could say \"prefer to use an SCTP-AUTH hash algorithm that matches the TLS cipher suite hash algorithm\" as you suggested @gloinul  \r\n\r\n\r\n\r\n",
          "createdAt": "2022-09-15T08:52:31Z",
          "updatedAt": "2022-09-15T08:52:31Z"
        }
      ]
    },
    {
      "number": 141,
      "id": "I_kwDOEtjg5s5PKi5x",
      "title": "User messages are inefficient",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/141",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "wontfix"
      ],
      "body": "Several things here...\r\n\r\nGiven that the content of user messages is protected in pieces, SCTP-AUTH only provides protection for:\r\n\r\n* The mapping of DTLS records to the correct user message\r\n* The order of DTLS records with a user message\r\n* The DTLS record that starts and ends a user message\r\n\r\nIf the content of user messages is limited to application_data, then the only value the enclosed content type adds is the ability to pad each record.\r\n\r\nThe DTLS record header contains redundant information.  Some of this only needs to appear once for each user message:\r\n\r\n* The epoch (apparently key updates cannot occur during a message, I don't know why)\r\n* The connection ID (unless these can change mid-message; I haven't seen requirements regarding that yet)\r\n* The header format (this is effectively fixed)\r\n\r\nDTLS 1.2 records have a useless version and content-type field on top of that.\r\n",
      "createdAt": "2022-08-04T07:02:09Z",
      "updatedAt": "2022-10-07T12:22:19Z",
      "closedAt": "2022-10-07T12:22:19Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Yes, it is inefficient and the reason is that we want to be able to implement this on top of existing SCTP stacks, not having to refactor the SCTP stacks completely. If one would go down a complete refactoring of the protocol one would integrate the packet protection based on the TSN level resulting a single linear packet stream simplifying a lot of the other complexities around key-update etc. \r\n\r\nHowever, if one is doing such a significant change I think I would argue for considering deploying MP-QUIC as transport protocol instead of SCTP.\r\n\r\nMy proposal is to simply accept this and move on. ",
          "createdAt": "2022-09-07T14:58:26Z",
          "updatedAt": "2022-09-07T14:58:26Z"
        }
      ]
    },
    {
      "number": 142,
      "id": "I_kwDOEtjg5s5PKjJ7",
      "title": "Parallel DTLS connections from different versions",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/142",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "teiclap"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "Can you negotiate DTLS 1.2 and DTLS 1.3 concurrently?  Why would you want to allow that?",
      "createdAt": "2022-08-04T07:03:13Z",
      "updatedAt": "2022-10-07T08:22:28Z",
      "closedAt": "2022-10-07T08:22:28Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So I think you mean if it would be okay if one switch DTLS Version when negotiating a second DTLS connection for the purpose of rekeying. I think the short answer is MUST NOT do it. I would motivate it with that even if it would be technically possibly it creates rarely executed code paths and difficult to compare changes in security parameters etc. Thus, it becomes a more likely place for security vulnerabilities and thus it becomes best to forbid it. \r\n\r\nThus, some text should be added to make this clear. ",
          "createdAt": "2022-09-06T08:25:32Z",
          "updatedAt": "2022-09-06T08:25:32Z"
        }
      ]
    },
    {
      "number": 143,
      "id": "I_kwDOEtjg5s5PKjt6",
      "title": "Allow DTLS 1.3 KeyUpdate",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/143",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "gloinul"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "The recommendation against this, plus the requirement to have all messages acknowledged, is not necessary.  DTLS implementations that have support for this feature might use it automatically and I see nothing in the design that would prevent it from being used, nor for the restrictions on use that are levied.",
      "createdAt": "2022-08-04T07:05:32Z",
      "updatedAt": "2022-10-10T09:01:36Z",
      "closedAt": "2022-10-10T09:01:36Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "The answer was hidden in [this mega paragraph](https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-4.7-1).  This might be pulled out into a clearer statement.",
          "createdAt": "2022-08-04T07:07:12Z",
          "updatedAt": "2022-08-04T07:07:12Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Editorial improvement will be looked into. ",
          "createdAt": "2022-09-07T14:52:23Z",
          "updatedAt": "2022-09-07T14:52:34Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Starting to look at the issue here. I think we should consider to move the Section 4.8 on Renegotiation and Key Update into Section 3 instead as it appears to be more a DTLS consideration than actually a SCTP consideration for this solution. I think that section also motivates why Key Update does not work. Also as we not relying on this and instead the parallel DTLS connection it make sense to just clarify the DTLS requirement. Will write a PR proposing such a move and try to focus the text a bit more. \r\n",
          "createdAt": "2022-09-27T12:23:20Z",
          "updatedAt": "2022-09-27T12:23:20Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So having thought more about this and had a bit of discussion among the authors. So we discussed that the issue with KeyUpdate could be resolved by not discarding the earlier keys, that would avoid any issues with expiring keys and the key turn over happening differently on different user messages. However, as DTLS only have the two lowest epoch bits in the packet format, when one have used keyUpdate four times one will have a uncertainty about which key it truly used if all are kept. Otherwise one must ensure that the old key is no longer in use and retire it. Getting us back to the problems that parallel DTLS deals with already. Thus, also this idea requires a DTLS implementation change, compared to just turning off the keyUpdate which appears to be a similar sized issue. So we don't see any benefit in allowing keyUpdate as it forces the requirement onto both side to function. Else one will drop the keys early. \r\n\r\nWhen it comes to draining the transmitter buffer before doing keyUpdate that requires API between the DTLS stack for when keyUpdate will happen so that these operations are synchronised as well as they are interfering with applications message flow during the draining by DTLS/SCTP adaptation layer. \r\n\r\nThus, we conclude that simplest is simply to forbid keyUpdate and make it clear that the usage of parallel DTLS must ensure that the key material life time limits are followed. ",
          "createdAt": "2022-10-07T08:45:21Z",
          "updatedAt": "2022-10-07T08:45:21Z"
        }
      ]
    },
    {
      "number": 144,
      "id": "I_kwDOEtjg5s5PKl4U",
      "title": "DTLS glare",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/144",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "gloinul",
        "emanjon"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-4.7-4 blew my tiny mind:\r\n\r\n> As either endpoint can initiate a DTLS handshake on either side at the same time, either endpoint may receive a DTLS ClientHello when it has sent its own ClientHello. \r\n\r\nThis assumes that both endpoints are authenticating, otherwise you can't swap TLS roles.  This needs a clearer statement about this assumption.\r\n\r\nThe glare resolution method seems fine with the two-connection limit in place, mostly.  If an endpoint is currently a server and it needs to create a new connection for any reason (it is running out of AEAD usage, say) then it can send a ClientHello.  The peer can effectively deny this request by sending its own ClientHello in response, invoking the glare logic.  That seems like a perfectly reasonable response.  But if you allow for that, then it might be better spelled with a SCTP-layer message to request the former client initiate a new handshake; the new DTLS/SCTP control message seems perfect.\r\n\r\nFWIW, I'm not even sure if role swapping is entirely safe.  There might be features that are directional in TLS, which you won't be able to rely on.",
      "createdAt": "2022-08-04T07:14:23Z",
      "updatedAt": "2022-10-20T13:13:11Z",
      "closedAt": "2022-10-20T13:13:10Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So mutual authentication is mandatory: https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#name-authentication-and-policy-d. \r\n\r\nWill have to think more about this second aspect. What is clear is that either endpoint must be able to initiate a rekeying. The DTLS/SCTP control messages is a new thing, and you are right that it can be used to initiate such a request for rekeying. ",
          "createdAt": "2022-09-07T09:42:13Z",
          "updatedAt": "2022-09-07T09:42:13Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "To clarify what DTLS roles endpoints to support, possibly note that you maintain your client role. ",
          "createdAt": "2022-10-12T14:42:25Z",
          "updatedAt": "2022-10-12T14:42:25Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "- We should check if we need to mention that mutual authenticated DTLS (with server and client certificate) in more places. That this was not clear to Martin might indicate that it could be mentioned more. Let's check.\r\n\r\n> What is clear is that either endpoint must be able to initiate a rekeying.\r\nI don't have any strong opinions if this should be done with ClientHello or on the SCTP level. Let's discuss that\r\n\r\n>FWIW, I'm not even sure if role swapping is entirely safe. There might be features that are directional in TLS, which you won't be able to rely on.\r\nFrom a DTLS perspective this is a completely new connection so I don't see any security problems. Directional features in (or outside) TLS that lives between connections would be affected. I see two such features:\r\n1. Resumption. This does not work if you swap roles so a full handshake has to be done. I don't this is a problem for DTLS/SCTP. We should maybe mention this if it is not mentioned.\r\n2. Certificates. To be able to swap roles both parties need certificates possible to use in both client and server roles. This is outside of TLS. DTLS/SCTP could go inte some details but I am not sure it should. We should probably mention this consideration high level. In practice the solution could be to have 1 cert or 2 different cers (for SBA I think 3GPP allows both). In practice a single cert should have both id-kp-serverAuth  and id-kp-clientAuth. To follow RFC6125bis it should likely have a SAN of type DNSname.\r\n",
          "createdAt": "2022-10-14T11:12:29Z",
          "updatedAt": "2022-10-14T11:12:29Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Make PR with implementation, resumption, and certificate considerations.",
          "createdAt": "2022-10-19T11:05:04Z",
          "updatedAt": "2022-10-19T11:05:04Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Resolved this issues. ",
          "createdAt": "2022-10-20T13:13:10Z",
          "updatedAt": "2022-10-20T13:13:10Z"
        }
      ]
    },
    {
      "number": 145,
      "id": "I_kwDOEtjg5s5PKo3R",
      "title": "Ready_To_Close doesn't identify which connection",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/145",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "gloinul",
        "teiclap"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "I'm concerned that the reliability of the Ready_To_Close message relative to DTLS-layer close messages could create some issues.\r\n\r\nLet's say that you decide to send both of these at the same time, but only one arrives.  The peer discards state based on receiving either.  If RTC arrives after, especially if a new connection attempt has been started in the meantime, then it ends up closing the wrong connection.\r\n\r\nI haven't mapped all of this out, but the level of detail in the spec doesn't make me confident that this has been thought through fully.",
      "createdAt": "2022-08-04T07:26:12Z",
      "updatedAt": "2022-10-07T08:17:01Z",
      "closedAt": "2022-10-07T08:17:01Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So, with the limitation of having only two DTLS connections in an association at anytime, at the time one sends the Ready_To_Close there should only be one that is known to be the older. And if you are doing things with both you are entering shutdown. \r\n\r\nBut, I think to avoid any issues adding a field to this message is trivial to carry the DTLS connection ID that would ensure that any missing case in me going through them will not break the protocol.  ",
          "createdAt": "2022-09-07T09:32:05Z",
          "updatedAt": "2022-09-07T09:32:05Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Proposal for how to resolve in #170 ",
          "createdAt": "2022-09-27T09:00:40Z",
          "updatedAt": "2022-09-27T09:00:40Z"
        }
      ]
    },
    {
      "number": 146,
      "id": "I_kwDOEtjg5s5PKq1p",
      "title": "DTLS connection establishment during shutdown",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/146",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "gloinul",
        "teiclap"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-4.10-4.2 says: \r\n\r\n> In case a DTLS connection handshake is ongoing this needs to be aborted conclusively at this step to ensure that the necessary DTLS message exchange happens prior to draining any outstanding data in the SCTP association from this endpoint.\r\n\r\nBecause connections are make-before break (except initially), I don't see why you need to hold the shutdown for the new connection establishment.  The shutdown should be able to proceed with the old keys.\r\n\r\nOr are you concerned that the old keys might wear out?  In that case, you should decouple shutdown from the DTLS connection state entirely.  An extended shutdown might need to involve multiple new DTLS connections (especially if you decide to use CCM_8, which has keys wear out very quickly in this context).\r\n\r\nConsider only the special case of the first DTLS connection, where you should not have any in-flight user data.  For that, you might just tear the connection down without any extended shutdown process.",
      "createdAt": "2022-08-04T07:33:45Z",
      "updatedAt": "2022-10-10T09:02:30Z",
      "closedAt": "2022-10-10T09:02:30Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "In other words, I'm not convinced that there is any special need for a shutdown process that is specific to this adaptation layer.  Provided that the ULP has adequate provisions for shutdown, this adaptation layer should continue to function and provide service until the ULP decides to quit.  At that point, you can just close the association fully.",
          "createdAt": "2022-08-04T07:36:01Z",
          "updatedAt": "2022-08-04T07:36:01Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "If I understand you correctly you say that if one have initiated a handshake, simply don't send the DTLS Finished message and the handshake will never have been completed and thus have no impact. I guess I was unnecessary tidy here and that one can in fact just abandon the handshake. \r\n\r\nSo, I think this might be a hold over from prior to defining the DTLS/SCTP shutdown messages. No, I am not worried that the keys will wear out during the shutdown procedure. Sufficient reserve space should exist when initiating key-exchange anyway to deal with the small amount of additional data an endpoint need to send. \r\n\r\n",
          "createdAt": "2022-09-07T11:48:44Z",
          "updatedAt": "2022-09-07T11:48:44Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "No, I'm suggesting that you operate the two layers independently.  The DTLS connections you make (or not) can continue to be made as needed during shutdown.  If one of those connections is half-way setup, then just abandon it with no further ceremony, it won't be offended.",
          "createdAt": "2022-09-07T23:34:00Z",
          "updatedAt": "2022-09-07T23:34:00Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I think the issue I see is that if you continue and ever start using a new DTLS connection when having entered shutdown progress you have to ensure that any ULP data sent with it has been delivered and handled before doing SCTP level shutdown. Thus, I think abandoning before completing is just fine, but if you ever sent any ULP data you need to close it down. However, as it is on the responsibility of the data sender to verify this I will attempt to clarify that up to this point one can just abandon the DTLS handshake. ",
          "createdAt": "2022-09-08T06:32:48Z",
          "updatedAt": "2022-09-08T06:32:48Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Resolved by #177 ",
          "createdAt": "2022-10-07T12:52:48Z",
          "updatedAt": "2022-10-07T12:52:48Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Resolved by #177 ",
          "createdAt": "2022-10-10T09:02:30Z",
          "updatedAt": "2022-10-10T09:02:30Z"
        }
      ]
    },
    {
      "number": 147,
      "id": "I_kwDOEtjg5s5PKsEL",
      "title": "Acronym transpositions",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/147",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I notice a bunch of transpositions.  Often these are the 3rd and 4th letters of a four-letter acronym, so SCPT or DTSL.  It might be worth a global search and replace.",
      "createdAt": "2022-08-04T07:38:21Z",
      "updatedAt": "2022-09-06T07:53:51Z",
      "closedAt": "2022-09-06T07:53:51Z",
      "comments": []
    },
    {
      "number": 148,
      "id": "I_kwDOEtjg5s5PKsh7",
      "title": "Define how the SCTP-AUTH keys are derived",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/148",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "emanjon"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "There is an exporter defined in the IANA considerations, but no specification for this.\r\n\r\nI'll note that RFC 4895 is pretty poorly specified as well.  It might be worth re-iterating the entire process.",
      "createdAt": "2022-08-04T07:40:12Z",
      "updatedAt": "2022-10-13T05:24:15Z",
      "closedAt": "2022-10-13T05:24:15Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Yes, I believe this is something we can write a detailed description on. ",
          "createdAt": "2022-09-07T11:30:01Z",
          "updatedAt": "2022-09-07T11:30:01Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "There is the following text\r\n\r\n`When a subsequent DTLS connection is setup, a new a 64-byte shared secret is derived using the TLS-Exporter. The shared secret identifiers form a sequence. If the previous shared secret used Shared Key Identifier n, the new one MUST use Shared Key Identifier n+1, unless n = 65535, in which case the new Shared Key Identifier is 1.\r\n`\r\nThis text is basically the same as RFC 6083. It should be clearer defined which label is used and that no context is used.\r\n\r\nThe 64-byte shared secret is quite specific for HMAC-SHA-1 and HMAC-SHA-256 that are the only algorithms currently defined by RFC 4895. HMAC allows any key length to be used but it is recommended to use the same key size as the block size of the hash function. 64-bytes align with the block size for SHA-1 and  SHA-256 but not e.g. SHA-512.\r\n\r\nIf someone registers AES-CMAC a 64 byte key would not work. We might want to say something different than RFC 6083. TSVWG might work on an RFC4895bis in the near future. \r\n\r\n",
          "createdAt": "2022-10-10T14:48:33Z",
          "updatedAt": "2022-10-10T14:48:33Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated text should use the RFC 4895 term \"endpoint pair shared keys\".\r\n\r\n- Just read up on SCTP-AUTH. From the \"endpoint pair shared key\" SCTP-AUTH computes the \"association shared key\" by concatenating the two key vectors (RANDOM parameter, the CHUNKS parameter, and the HMAC-ALGO parameter) from the SCTP handshake. The resulting \"association shared key\" will therefore be larger than 64 bytes.\r\n\r\n- If the key is larger than the block size (which it is in this case as SHA-256 has a block size of 64 bytes), HMAC-SHA-256 will start by deriving a new key K' = SHA-256(K).\r\n\r\n",
          "createdAt": "2022-10-10T15:08:37Z",
          "updatedAt": "2022-10-10T15:08:37Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Reading more in RFC 4895.\r\n\r\nThe SCTP handshake negotiate two lists of HMAC algorithms that can be used. These are included in the association key but the used HMAC algorithm is not included in the key derivation.\r\n\r\nMy understanding of RFC 4895 is that \"The receiver of an HMAC-ALGO parameter SHOULD use the first\r\n   listed algorithm it supports.\" but thre does not seem to be forbidded to change algorithm during the association. Using the same key for several algorithms is generally considered bad design.\r\n   \r\ndraft-westerlund-tsvwg-dtls-over-sctp-bis should probably require that each peer use a  single SCTP-AUTH algorithm during the SCTP association.",
          "createdAt": "2022-10-10T15:34:35Z",
          "updatedAt": "2022-10-10T15:34:35Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The ASCII string \"EXPORTER-DTLS-OVER-SCTP-EXT\" with no terminating NUL.",
          "createdAt": "2022-10-10T15:39:37Z",
          "updatedAt": "2022-10-10T15:39:37Z"
        }
      ]
    },
    {
      "number": 149,
      "id": "I_kwDOEtjg5s5PKtNX",
      "title": "Don't reuse the RFC 6803 exporter label",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/149",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "teiclap"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "This is a different protocol.  Make a new label.  Start it with \"EXPORTER-\" not \"EXPORTER_\" too.",
      "createdAt": "2022-08-04T07:42:58Z",
      "updatedAt": "2022-10-07T08:16:08Z",
      "closedAt": "2022-10-07T08:16:08Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Noted, this also implies an update to the IANA registration section to register the new label in https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#exporter-labels\r\n ",
          "createdAt": "2022-09-06T08:28:07Z",
          "updatedAt": "2022-09-06T08:28:07Z"
        }
      ]
    },
    {
      "number": 150,
      "id": "I_kwDOEtjg5s5PKt70",
      "title": "EC(DHE) -> (EC)DHE",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/150",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Swap the parenthese around.  They indicate that the EC part is optional.  The ephemeral Diffie-Hellman part isn't.",
      "createdAt": "2022-08-04T07:45:39Z",
      "updatedAt": "2022-09-05T12:04:30Z",
      "closedAt": "2022-09-05T12:04:29Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Resolved by #164 ",
          "createdAt": "2022-09-05T12:04:29Z",
          "updatedAt": "2022-09-05T12:04:29Z"
        }
      ]
    },
    {
      "number": 151,
      "id": "I_kwDOEtjg5s5PKvc_",
      "title": "Resumption performance",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/151",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "emanjon"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "[This](https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-9.5-1) is just false:\r\n\r\n> In DTLS/SCTP, there are no significant performance benefits with resumption and an implementation can chose to never issue any tickets.\r\n\r\nThere is definitely a performance advantage.  You avoid one signature that needs to be generated and validated otherwise.  And certificates don't need to be sent (validation of those can still be done, which is what I believe all browsers do on resumption).  Together, that's pretty significant.\r\n\r\nThe advice about a single ticket is good though: you only need enough to create the next connection.  Multiple tickets only help if you are making lots of connections and here you have just two.\r\n\r\nResumption is mutually agreed, so if either endpoint wants another copy of their peer's certificate (maybe to get an updated OCSP staple or a new certificate - if the connection is truly long-lived) they can just refuse to offer or accept a ticket.",
      "createdAt": "2022-08-04T07:51:33Z",
      "updatedAt": "2022-10-12T14:48:09Z",
      "closedAt": "2022-10-12T14:48:09Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So from the expected use cases I think the benefit is limited, but you are strictly right that this is resource consumption save. But, if you rekey approximately once an hour, the cost of that rekeying is fairly insignificant, but we should write incorrect things. We will address the text to be factual correct, and if we want to give any recommendation we will motivate it better. ",
          "createdAt": "2022-09-07T11:37:31Z",
          "updatedAt": "2022-09-07T11:37:31Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's write that resumption has performance benefits for the Web but that these are not really important when setting up the parallel connections in draft-ietf-tsvwg-dtls-over-sctp-bis. The intention was not intended to imply that resumption has no advantages in general.\r\n\r\nA more important aspect based on this comment is that I think the text in draft-ietf-tsvwg-dtls-over-sctp-bis seems to assume that resumption is only used for the  parallel connections. Resuption could also be used for the initial DTLS connection. E.g., if the association is shut down for some reson and has to be restarted. Here resumption could have performance benefits for draft-ietf-tsvwg-dtls-over-sctp-bis",
          "createdAt": "2022-09-15T07:40:52Z",
          "updatedAt": "2022-09-15T07:40:52Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I still think the old text was technically correct for parallel connections. Parallel connection are setup relatively infrequently, the nodes will have a single connection, and latency is not important when setting up a parallel connections. I have a hard time see any significant benefits. However I don't think this sentence need to be in the document at all.\r\n\r\nI removed the sentence and replaced it with a sentence describing that \"Resumption can have significant latency benefits for quickly restarting a broken DTLS/SCTP association.\"\r\n",
          "createdAt": "2022-10-10T13:22:27Z",
          "updatedAt": "2022-10-10T13:22:27Z"
        }
      ]
    },
    {
      "number": 152,
      "id": "I_kwDOEtjg5s5PKvxr",
      "title": "Cryptographic considerations is very long",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/152",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "emanjon"
      ],
      "labels": [
        "Needs PR",
        "Wait for DTLS 1.3 discussion"
      ],
      "body": "There are a few things in [here](https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-9.1):\r\n\r\n* talk about rekeying, post-compromise security, and forward security\r\n* talk about revalidating certificates\r\n\r\nIt might pay to break this down a little.",
      "createdAt": "2022-08-04T07:52:47Z",
      "updatedAt": "2022-10-14T10:05:30Z",
      "closedAt": null,
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "@emanjon will write PR when issue #176 has been decided on. ",
          "createdAt": "2022-10-12T14:35:56Z",
          "updatedAt": "2022-10-12T14:35:56Z"
        }
      ]
    },
    {
      "number": 153,
      "id": "I_kwDOEtjg5s5PKwSR",
      "title": "How do you limit new connections",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/153",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "teiclap"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-9.1-11 says:\r\n\r\n> Allowing new connections can enable denial-of-service attacks. The endpoints SHOULD limit the frequency of new connections.\r\n\r\nHow?",
      "createdAt": "2022-08-04T07:54:41Z",
      "updatedAt": "2022-10-07T08:15:43Z",
      "closedAt": "2022-10-07T08:15:43Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So a solution for this is to refuse to close the old one, thus it would be a protocol violation to open up yet another one. That way if one have a minimal life time that results in an acceptable frequency of new connections. I think we are talking here about holding of closing when someone rekeys every few seconds or more frequently. \r\n",
          "createdAt": "2022-09-07T11:33:32Z",
          "updatedAt": "2022-09-07T11:33:32Z"
        }
      ]
    },
    {
      "number": 154,
      "id": "I_kwDOEtjg5s5PKw12",
      "title": "Mandatory mutual authentication",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/154",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "gloinul"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-9.1-12 says, in a rather offhand manner:\r\n\r\n> This together with mandatory mutual authentication (on the DTLS layer) and a requirement to not accept new identities \r\n\r\nThis is a protocol requirement that should be in the main body of the document, not hidden in [Section 9.4](https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-9.4).",
      "createdAt": "2022-08-04T07:56:51Z",
      "updatedAt": "2022-09-27T09:09:14Z",
      "closedAt": "2022-09-27T09:09:14Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Yes, lets find a better place to make this statement. ",
          "createdAt": "2022-09-07T11:29:07Z",
          "updatedAt": "2022-09-07T11:29:07Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree",
          "createdAt": "2022-09-10T09:14:48Z",
          "updatedAt": "2022-09-10T09:14:48Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "As this was editorial will now close this issue. ",
          "createdAt": "2022-09-27T09:09:14Z",
          "updatedAt": "2022-09-27T09:09:14Z"
        }
      ]
    },
    {
      "number": 155,
      "id": "I_kwDOEtjg5s5PKxWp",
      "title": "Use RFC 7525(bis)",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/155",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "emanjon"
      ],
      "labels": [
        "Needs PR",
        "Wait for DTLS 1.3 discussion"
      ],
      "body": "https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#section-9.1-12 says (amongst other things):\r\n\r\n> When DTLS/SCTP is used with DTLS 1.2 [[RFC6347](https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#RFC6347)], the TLS Session Hash and Extended Master Secret Extension [[RFC7627](https://gloinul.github.io/draft-westerlund-tsvwg-dtls-over-sctp-bis/draft-ietf-tsvwg-dtls-over-sctp-bis.html#RFC7627)] MUST be used to prevent unknown key-share attacks where an attacker establishes the same key on several connections.\r\n\r\nThis sort of stuff is better addressed by [RFC 7525bis](https://datatracker.ietf.org/doc/draft-ietf-uta-rfc7525bis/).  You can probably safely use the -bis rather than the original as it is much more mature than this document.",
      "createdAt": "2022-08-04T07:58:51Z",
      "updatedAt": "2022-10-14T10:05:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, we should probably refer to RFC7525bis, but maybe only to specific parts. We intentionally did not refer to RFC7525 as it was not describing \"best practice\" even when it was published. 3GPP did e.g., discuss RFC7525 but decided to not refer to it as many parts would decrease the security of 3GPP TLS usage rather than strengthening it. E.g allowing thing already forbidden by 3GPP since many years:\r\n\r\n```\r\n   When using RSA, servers SHOULD authenticate using certificates with\r\n   at least a 2048-bit modulus for the public key.  In addition, the use\r\n   of the SHA-256 hash algorithm is RECOMMENDED \r\n```\r\n   \r\n`   Curves of less than 192 bits SHOULD NOT be used.`\r\n\r\nRegarding DTLS versions, it might make sense to just forbid DTLS 1.2 now that DTLS 1.3 is published and supported by several libraries. That would make the part about DTLS 1.2 configuration disappear.",
          "createdAt": "2022-09-10T09:14:18Z",
          "updatedAt": "2022-09-10T09:14:18Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it is good to reference RFC 7525bis but beofre doing any changes we should decide if we want to mandate support of RFC 9147. Mandating support of DTLS 1.3 would be equal to mandating use of DTLS 1.3 or higher meaning that everything DTLS 1.2 could be removed.\r\n",
          "createdAt": "2022-09-15T07:31:52Z",
          "updatedAt": "2022-09-15T07:31:52Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "PR will wait until we have decided on issue #176 ",
          "createdAt": "2022-10-12T14:36:29Z",
          "updatedAt": "2022-10-12T14:36:29Z"
        }
      ]
    },
    {
      "number": 156,
      "id": "I_kwDOEtjg5s5PKzBB",
      "title": "Authenticating fallback to RFC 6083",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/156",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "emanjon"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "This is hard, because RFC 6803 never defined any means of validating itself, but I think that you want to define a fallback signal if you end up using the fallback.  This could be implemented using a TLS extension, with the initiating peer indicating that it chose to fall back in the extension.\r\n\r\nIf there is a downgrade, the responding peer would recognize this extension and abort.  The TLS handshake would then authenticate the inclusion of the extension, making it hard to remove without also breaking TLS authentication.\r\n\r\nSee also [RFC 7507](https://www.rfc-editor.org/rfc/rfc7507.html), where the SCSV idea is not entirely a bad idea if you also enable weak TLS configurations at the same time.  You could maybe even reuse the SCSV and get better downgrade protection, but that might be unwise as that document is headed for the Historic bin.",
      "createdAt": "2022-08-04T08:04:50Z",
      "updatedAt": "2022-10-18T05:18:04Z",
      "closedAt": "2022-10-18T05:18:04Z",
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "First for clarity it is RFC 6083 that defines the previous version of DTLS/SCTP.\r\n\r\nThanks for the idea, this actually looks practically doable which is hard when you are lacking the hooks in the earlier versions. Will discuss with @emanjon about this. ",
          "createdAt": "2022-09-07T11:25:31Z",
          "updatedAt": "2022-09-07T11:25:31Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like an excellent idea. Defining a new TLS extension seems like an easy and clean approach. A suitable solution is probably that the extention does not contain any data and that that presence of the extentions mean support of draft-ietf-tsvwg-dtls-over-sctp-bis. Reusing SCSV seems messy. Regarding DTLS versions, it might make sense to just forbid DTLS 1.2 now that DTLS 1.3 is published and supported by several libraries.",
          "createdAt": "2022-09-10T09:02:08Z",
          "updatedAt": "2022-09-10T09:02:08Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "@gloinul below is a explanation of how the downgrade protection in TLS 1.3 works\r\n\r\nhttps://blog.gypsyengineer.com/en/security/how-does-tls-1-3-protect-against-downgrade-attacks.html\r\n\r\nDTLS 1.3 work the same\r\n\r\n```\r\n  random:  Same as for TLS 1.3, except that the downgrade sentinels\r\n      described in Section 4.1.3 of [TLS13] when TLS 1.2 and TLS 1.1 and\r\n      below are negotiated apply to DTLS 1.2 and DTLS 1.0, respectively.\r\n```\r\n\r\n\r\n",
          "createdAt": "2022-09-14T14:11:15Z",
          "updatedAt": "2022-09-14T14:11:15Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the next step is to define the fallback extention. We could define that the intiator using RFC 6083 but supporting draft-ietf-tsvwg-dtls-over-sctp-bis use the extension but it is likely simpler that a initiator supporting draft-ietf-tsvwg-dtls-over-sctp-bis always use the extension. The responder abort if RFC 6083 is used, the responder supports draft-ietf-tsvwg-dtls-over-sctp-bis, and the draft-ietf-tsvwg-dtls-over-sctp-bis extension was present.\r\n",
          "createdAt": "2022-09-15T07:27:55Z",
          "updatedAt": "2022-09-15T07:27:55Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Does this extention mean that the document updates RFC 6083 after all?",
          "createdAt": "2022-10-11T20:32:11Z",
          "updatedAt": "2022-10-11T20:32:11Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a PR. This is theoretically nice, but is it worth it practically? This requires 3GPP changing the DTLS implementation. I think I will change the PR so that the extension is only send in RFC6083. My understanding is that 3GPP will just forbid fallback. It would then be bad to force more updates to DTLS libraries.",
          "createdAt": "2022-10-14T06:39:36Z",
          "updatedAt": "2022-10-14T06:39:36Z"
        }
      ]
    },
    {
      "number": 176,
      "id": "I_kwDOEtjg5s5THWcF",
      "title": "DTLS 1.3 Only",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/176",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "Need Discussion"
      ],
      "body": "This is an issue to track any GitHub comments for the proposal to only support DTLS 1.3 and remove DTLS 1.2 support from the specification. A call for input has been sent to TSVWG mailing list with a deadline of the 17th of October. ",
      "createdAt": "2022-10-03T09:37:49Z",
      "updatedAt": "2022-10-11T09:44:28Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 178,
      "id": "I_kwDOEtjg5s5TfmiG",
      "title": "Editorial alignment in style of the IANA sub sections needed",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/178",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [
        "PR exists"
      ],
      "body": "",
      "createdAt": "2022-10-07T08:11:14Z",
      "updatedAt": "2022-10-19T11:01:58Z",
      "closedAt": "2022-10-19T11:01:58Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The SCTP Adaptation Layer Indication Code Point is \"TBD\" in the body but \"0x00000002\" in the IANA sectio",
          "createdAt": "2022-10-14T09:43:34Z",
          "updatedAt": "2022-10-14T09:43:34Z"
        }
      ]
    },
    {
      "number": 182,
      "id": "I_kwDOEtjg5s5T0x1T",
      "title": "DTLS considerations need to be clear that AEAD limits MUST be handled by new connection",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/182",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [
        "emanjon"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "Possibly add text next to forbidding keyUpdate",
      "createdAt": "2022-10-12T14:45:47Z",
      "updatedAt": "2022-10-18T05:15:53Z",
      "closedAt": "2022-10-18T05:15:53Z",
      "comments": []
    },
    {
      "number": 183,
      "id": "I_kwDOEtjg5s5T1qgp",
      "title": "Address new vulnerabilities found in SCTP-AUTH",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/183",
      "state": "OPEN",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "emanjon"
      ],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/tsvwg/8EyYbU-L-Tl_aMoUhCOuTV-pQ5c/\r\n\r\nMost of the vulnerabilities seems relatively straightforward to mitigate in draft-ietf-tsvwg-dtls-over-sctp-bis\r\n-Defining different TLS exporter labels for the DTLS client and server\r\n- Require that no more than 2^32 DATA chunks are sent over a single DTLS connection\r\n- Enforce that each sender use a single HMAC Identifier during the association.\r\n\r\nThe issue with replay of ERROR etc. might be trickier to address. A first step is to acknoledge the vulnerability. Maybe the draft could recommend that ERROR and other replayable chunks are sent in the same SCTP packet as DATA. Some chunks might not be possible to send with DATA, but maybe that is limited to INIT etc used in the handshake.\r\n\r\n",
      "createdAt": "2022-10-12T17:39:21Z",
      "updatedAt": "2022-10-24T11:22:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Should the client and server endpoint shared secrets use the same Shared Key ID? Or should they use different?",
          "createdAt": "2022-10-13T07:24:12Z",
          "updatedAt": "2022-10-13T07:24:12Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "> Should the client and server endpoint shared secrets use the same Shared Key ID? Or should they use different?\r\n\r\nI don't think with RFC 4895 and the SCTP-API for it in RFC 6458 that you can have per direction different keys while using only one key-ID. To my understanding one will have to deploy two shared keys from each DTLS connection, intending to use one Key-ID per direction. I think the easiest algorithm is to have the SCTP association use odd number key-ID as there active sending key, and even number as the SCTP association server sending direction. That should be compatible with these specs. However, final wording need to ensure that the roles are watertight in face of simultaneous open of the SCTP association. ",
          "createdAt": "2022-10-13T07:37:13Z",
          "updatedAt": "2022-10-13T07:37:13Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Actually the requirement is a bit different for this \"Require that no more than 2^32 DATA chunks are sent over a single DTLS connection\". I think to be secure the requirement is:\r\n\r\nSenders MUST retire the shared key before 2^32 DATA chunks have been sent since the first SCTP-AUTH protected packet with that key, i.e. before the TSN turns over the shared key that was previously used must no longer be valid to be received when any TSN number protected by that key would be accepted by the SCTP receiver. ",
          "createdAt": "2022-10-13T08:54:04Z",
          "updatedAt": "2022-10-13T08:54:04Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "> Actually the requirement is a bit different for this \"Require that no more than 2^32 DATA chunks are sent over a single DTLS connection\". I think to be secure the requirement is:\r\n> \r\n> Senders MUST retire the shared key before 2^32 DATA chunks have been sent since the first SCTP-AUTH protected packet with that key, i.e. before the TSN turns over the shared key that was previously used must no longer be valid to be received when any TSN number protected by that key would be accepted by the SCTP receiver.\r\n\r\nI changed my original text quite a lot before reading this. The current formulation talks about TSN as there can also be I-DATA chunks. Can you check the new formulation?\r\n\r\n",
          "createdAt": "2022-10-13T11:55:34Z",
          "updatedAt": "2022-10-13T11:55:34Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "```\r\n   DTLS/SCTP does not provide replay protection for authenticated control\r\n   chunks such as ERROR, RE-CONFIG, or SACK when sent in a SCTP packet\r\n   without DATA or I-DATA chunks. Such replay could disrupt the SCTP association\r\n   and could therefore be a denial-of-service attack. To prevent such attacks\r\n   on availability it is RECOMMENDED to send control chunks in SCTP packets that\r\n   also contains DATA or I-DATA chunks. Note that DATA or I-DATA chunks MAY contain\r\n   zero bytes of user data.\r\n```\r\n\r\nIs this good enough? Can we enforce something stronger? Could we mandate DATA chunks for everything except the init and shutdown chunks? Do implementations support sending DATA chunks with zero length? I know that some TLS implementations dont support sending records with zero length even if it is allowed by the spec.    \r\n   ",
          "createdAt": "2022-10-13T11:58:05Z",
          "updatedAt": "2022-10-13T11:58:05Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Thinking more, just placing control chunks in the same packet as DATA does not help. SCTP-AUTH of course just authenticates everything and then SCTP process all of the chunks. Failure in a DATA chunk would not invalidate the ERROR chunk. Such behaivior would be a new processing step. ",
          "createdAt": "2022-10-14T06:31:35Z",
          "updatedAt": "2022-10-14T06:31:35Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "To protect control chunks a sequence number for AUTH chunks is needed. Could be a AUTH2 chunk or it could be a new HMAC algorithm for AUTH that puts the sequence number in the HMAC field. We should analyze the impact of replayed control chunks.",
          "createdAt": "2022-10-14T06:36:41Z",
          "updatedAt": "2022-10-14T06:36:41Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Should the indexes be\r\n- 1 and 2 so that 65535 is never used?\r\n- 2 and 3 so that 1 is never used? ",
          "createdAt": "2022-10-14T11:35:35Z",
          "updatedAt": "2022-10-14T11:35:35Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "In addition to not being possible with the RFC 6458 API, directional keys are actually changing RFC 4895.\r\n\r\n```\r\nReceiving authenticated chunks\r\n\r\n...\r\n\r\nIf the endpoint has at least one endpoint pair shared key for the peer,\r\nit MUST use the key specified by the Shared Key Identifier if a key\r\nhas been configured for that Shared Key Identifier. \r\n```",
          "createdAt": "2022-10-20T07:59:02Z",
          "updatedAt": "2022-10-20T07:59:02Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Leaving issue open until we have had some discussion in the WG if this mitigation is sufficient. But the draft to be releasted (-05) will have text on this.  ",
          "createdAt": "2022-10-24T11:09:25Z",
          "updatedAt": "2022-10-24T11:09:25Z"
        }
      ]
    },
    {
      "number": 184,
      "id": "I_kwDOEtjg5s5T35Jt",
      "title": "DTLS Considerations for Handling of Endpoint Pair Shared Secrets",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/184",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "emanjon"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "Finished and close_notify works differently in DTLS 1.3",
      "createdAt": "2022-10-13T05:21:13Z",
      "updatedAt": "2022-10-24T11:10:55Z",
      "closedAt": "2022-10-24T11:10:55Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I plan to adress #183 and #184 in the same PR as they affect the same clauses.",
          "createdAt": "2022-10-14T14:18:02Z",
          "updatedAt": "2022-10-14T14:18:02Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding DTLS 1.2\r\n\r\nRFC 6083\r\n\r\n```\r\n   Before sending the Finished message, the active SCTP-AUTH key MUST be\r\n   switched to the new one.\r\n\r\n   Once the corresponding Finished message from the peer has been\r\n   received, the old SCTP-AUTH key SHOULD be removed.\r\n```\r\n\r\nIn draft-ietf-tsvwg-dtls-over-sctp-bis-04 this has been changed to\r\n\r\n```\r\n   After sending the DTLS Finished message for the\r\n   initial DTLS connection, the active SCTP-AUTH key MUST be switched\r\n   from key identifier 0 to key identifier 1.  Once the initial Finished\r\n   message from the peer has been processed by DTLS, the SCTP-AUTH key\r\n   with Shared Key Identifier 0 MUST be removed.\r\n\r\n   After sending the DTLS Finished message, the new SCTP-AUTH key can be\r\n   used according to Section 4.7.\r\n```\r\n\r\nI don't understand why this was changed (though I might be responsible...). The abobe text in draft-ietf-tsvwg-dtls-over-sctp-bis-04 seems to contradict other text in draft-ietf-tsvwg-dtls-over-sctp-bis-04\r\n\r\n```\r\n   The 64-byte shared secret MUST be provided to the SCTP stack as soon\r\n   as the computation is possible.\r\n```\r\n\r\n",
          "createdAt": "2022-10-14T14:20:13Z",
          "updatedAt": "2022-10-14T14:20:13Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "`Also, after the completion of the DTLS handshake, a new SCTP-AUTH key will be exported per {{handling-endpoint-secret}}. \r\n`\r\nThis is also different from RFC 6083.\r\n",
          "createdAt": "2022-10-17T04:27:55Z",
          "updatedAt": "2022-10-17T04:27:55Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "We should clarify that no ULP data shall be sent until the peer has been authenticated by the endpoint, as well as having derived the key for SCTP-AUTH.",
          "createdAt": "2022-10-19T11:19:20Z",
          "updatedAt": "2022-10-19T11:19:20Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I do think this issue is now handled with text changes in -05. ",
          "createdAt": "2022-10-24T11:10:55Z",
          "updatedAt": "2022-10-24T11:10:55Z"
        }
      ]
    },
    {
      "number": 186,
      "id": "I_kwDOEtjg5s5T_R9j",
      "title": "Clarify that COOKIE-ECHO and COOKIE-ACK are not authenticated",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/186",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "emanjon"
      ],
      "labels": [
        "PR exists"
      ],
      "body": "`DATA chunks of SCTP MUST be sent in an authenticated way as described in SCTP-AUTH {{RFC4895}}. All other chunks that can be authenticated, i.e., all chunk types that can be listed in the Chunk List Parameter {{RFC4895}}, MUST also be sent in an authenticated way. This makes sure that an attacker cannot modify the stream in which a message is sent or affect the ordered/unordered delivery of the message.\r\n`\r\nCOOKIE-ECHO and COOKIE-ACK are used with SCTP-AUTH but with a well-known key. This detects transmission errors but not attacks. An on-path attacker can modify COOKIE-ECHO and COOKIE-ACK to anything they want. On the other hand there is not much an attacker can do. The Cookie field comes from the INIT ACK and the Chunk Flags are ignore on receipt.\r\n",
      "createdAt": "2022-10-14T10:02:49Z",
      "updatedAt": "2022-10-18T05:17:07Z",
      "closedAt": "2022-10-18T05:17:07Z",
      "comments": []
    },
    {
      "number": 189,
      "id": "I_kwDOEtjg5s5UGwDk",
      "title": "Align terminology with RFC 9260",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/189",
      "state": "CLOSED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "teiclap"
      ],
      "labels": [
        "Needs PR"
      ],
      "body": "As an example, RFC 9260 use \"INIT ACK\" while draft-ietf-tsvwg-dtls-over-sctp-bis use \"INIT-ACK\"\r\n",
      "createdAt": "2022-10-17T07:29:56Z",
      "updatedAt": "2022-10-24T11:08:00Z",
      "closedAt": "2022-10-24T11:08:00Z",
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "We should check terminology alignment with RFC 8446 and RFC 4895 as well\r\n- I removed some \"-\" to align with RFC 4895 but there might be more\r\n- RFC 8446 use ClientHello and KeyUpdate when it talks about the exact name of the message but use Client Hello and key update in other parts.",
          "createdAt": "2022-10-18T05:25:55Z",
          "updatedAt": "2022-10-18T05:25:55Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "ClientHello is a name and Client Hello is a noun. I will check for such cases",
          "createdAt": "2022-10-19T12:09:10Z",
          "updatedAt": "2022-10-19T12:09:10Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "Also I noted that rfc4895 is not aligned with rfc9260 when using INIT-ACK, COOKIE-ECHO etc.",
          "createdAt": "2022-10-19T12:16:51Z",
          "updatedAt": "2022-10-19T12:16:51Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Lets follow RFC 9260 usage as that is the latest spec and current main spec. ",
          "createdAt": "2022-10-19T12:32:07Z",
          "updatedAt": "2022-10-19T12:32:07Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's check for alignment with RFC 4895 as well. The term \"key-id\" is used in one place.",
          "createdAt": "2022-10-19T14:09:33Z",
          "updatedAt": "2022-10-19T14:09:33Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "key-id --> Key Identifier\r\ndone",
          "createdAt": "2022-10-19T14:17:00Z",
          "updatedAt": "2022-10-19T14:17:00Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "There's no SCTP-AUTH in 4895, I replace with SCTP AUTH instead that is locally defined.",
          "createdAt": "2022-10-19T14:18:14Z",
          "updatedAt": "2022-10-19T14:18:14Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "RFC 9260 talks about SCTP-AUTH .....\r\n\r\n`The SCTP Authentication extension SCTP-AUTH [RFC4895]`",
          "createdAt": "2022-10-21T11:58:17Z",
          "updatedAt": "2022-10-21T11:58:17Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "> RFC 9260 talks about SCTP-AUTH .....\r\n> \r\n> `The SCTP Authentication extension SCTP-AUTH [RFC4895]`\r\n\r\nI think actually using SCTP-AUTH would be clearer and I think that is fine if RFC 9260 is using it. Should we revert this change?",
          "createdAt": "2022-10-24T09:33:34Z",
          "updatedAt": "2022-10-24T09:33:34Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, even though rfc4895 uses SCTP AUTH. \r\nRFC9260 has higher prio",
          "createdAt": "2022-10-24T10:26:33Z",
          "updatedAt": "2022-10-24T10:26:33Z"
        }
      ]
    },
    {
      "number": 197,
      "id": "I_kwDOEtjg5s5Urthw",
      "title": "Create DTLS/SCTP Control Message IANA registry",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/197",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "As we have been expanding the usage of the DTLS/SCTP Control Message to multiple uses and it is a general framework we have to consider if we need to define an IANA registry for this. ",
      "createdAt": "2022-10-24T12:23:15Z",
      "updatedAt": "2022-10-24T12:23:15Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 199,
      "id": "I_kwDOEtjg5s5xv-6X",
      "title": "Update solution properties description",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/199",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "In the work around the security issues and interaction with SCTP-AUTH the understanding of this solution's properties needs to be reviewed and updated.",
      "createdAt": "2023-09-22T08:09:20Z",
      "updatedAt": "2023-09-22T08:09:20Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 200,
      "id": "I_kwDOEtjg5s5xwCDA",
      "title": "Add text on how SCTP restart works",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/200",
      "state": "OPEN",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "The solution should document how to perform SCTP Restart in a safe way. Based on what is written in Section 6.3 of RFC 4895 we believe a safe method for restarting is possible. \r\n\r\nThe restarting node need to have stored the SCTP-AUTH key that was in use prior to the restart. Then perform the INIT to initiate the restart per RFC 9260. Then use SCTP-AUTH with the old key in the Cookie-Echo message. That way proving to the peer that this is the same node. After that a new DTLS handshake can/must be done to re-authenticate the nodes on DTLS level, and then user messages can be sent using the new established DTLS connection and its derived SCTP-AUTH key. ",
      "createdAt": "2023-09-22T08:14:54Z",
      "updatedAt": "2023-09-22T08:14:54Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 201,
      "id": "I_kwDOEtjg5s5zdRXj",
      "title": "Overstated Security Properties",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/201",
      "state": "OPEN",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We have overstated the security properties somewhat. For example around replay protection.\r\nWe also need to consider the description related to availability and attacks and describe some implicit assumptions.",
      "createdAt": "2023-10-11T07:29:00Z",
      "updatedAt": "2023-10-11T07:29:00Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI5NTAyNTg1",
      "title": "Teiclap working",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/1",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Added new option and some Use Cases",
      "createdAt": "2020-11-30T12:03:18Z",
      "updatedAt": "2020-11-30T13:16:17Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "2e0c04dc0e950cfb7f6106a2f94bb7c4064399cc",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "teiclap-working",
      "headRefOid": "dacefb07bf711031d45cd64b7d2dbc8a7e44dd75",
      "closedAt": "2020-11-30T13:16:17Z",
      "mergedAt": "2020-11-30T13:16:17Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "14b332047eacd0021d85478d30b6e7923292f2df"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwODk2NzY4",
          "commit": {
            "abbreviatedOid": "dacefb0"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-30T13:16:07Z",
          "updatedAt": "2020-11-30T13:16:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 2,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMwOTYyNjA2",
      "title": "Teiclap working",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/2",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Added new section ## DTLS over SCTP service \r\nClarified the initialization, improved the Use Cases",
      "createdAt": "2020-12-02T11:51:35Z",
      "updatedAt": "2020-12-02T14:07:56Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "7ca2646bb43723b22bae6a7806c7e1317ca8246f",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "teiclap-working",
      "headRefOid": "7761c19f905114b8a144caa6ed4342cd8110bb93",
      "closedAt": "2020-12-02T14:07:56Z",
      "mergedAt": "2020-12-02T14:07:56Z",
      "mergedBy": "teiclap",
      "mergeCommit": {
        "oid": "be21e0fdb148c3daf1b90285876f87b7da68b4a9"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMxMDQ1NzA5",
      "title": "Fixed a double definition",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/3",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Syntax Error",
      "createdAt": "2020-12-02T14:14:24Z",
      "updatedAt": "2020-12-02T14:15:55Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "be21e0fdb148c3daf1b90285876f87b7da68b4a9",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "teiclap-working",
      "headRefOid": "bbe0a3892b2eabbb0011dfc17a2d979703553f2f",
      "closedAt": "2020-12-02T14:15:55Z",
      "mergedAt": "2020-12-02T14:15:55Z",
      "mergedBy": "teiclap",
      "mergeCommit": {
        "oid": "53e96a6cb5a01495376dc10703755a9cce5f0257"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMxODA3NDcw",
      "title": "Change in the \"DTLS Connection Handling\" part",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/4",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Only one DTLS connection during the whole association lifetime.",
      "createdAt": "2020-12-03T14:13:59Z",
      "updatedAt": "2020-12-08T08:23:39Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "1cf445c629e828c065e893f194755501b20ec464",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "teiclap-working",
      "headRefOid": "aeef520acf642ed00bdf1b34a094d0a7e15a3345",
      "closedAt": "2020-12-08T08:23:39Z",
      "mergedAt": "2020-12-08T08:23:39Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "eb6d022a34781e8c268769091b302b4b56d464b5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM1NzcwNTEx",
      "title": "Teiclap working",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/5",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Added considerations on rx buffer size and CWND",
      "createdAt": "2020-12-10T08:56:23Z",
      "updatedAt": "2020-12-10T10:03:08Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "99f77be932d71d98d6d16691ef0ef9a0e4021b93",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "teiclap-working",
      "headRefOid": "f0caa3ff757dc9ed11642343bd499876e959c55c",
      "closedAt": "2020-12-10T10:03:08Z",
      "mergedAt": "2020-12-10T10:03:08Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "40494483c6eb9f95c3eacf2f47feb6614fb54b1f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0NTM1OTQ5MTc2",
      "title": "Teiclap working",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/6",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-10T13:47:43Z",
      "updatedAt": "2020-12-11T14:25:14Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "ffee571b9be293d7a82c14799ce9af43724afa2e",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "teiclap-working",
      "headRefOid": "1acf36e83080ac047341caa89adf82a80a25ac17",
      "closedAt": "2020-12-11T14:25:14Z",
      "mergedAt": "2020-12-11T14:25:14Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "5b1e1febe5619e359bdfa3c451751620c00141bf"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 7,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQwMTEyNTA2",
      "title": "Teiclap working",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/7",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Made a number of typo fixes and some minor changes",
      "createdAt": "2020-12-15T09:38:51Z",
      "updatedAt": "2020-12-15T09:52:57Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "c3068663d37dbc2b23748ff66232aa8a07c5c509",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "teiclap-working",
      "headRefOid": "3d53a1c62acfe3dea1e51286ea1e1dffe212b116",
      "closedAt": "2020-12-15T09:52:57Z",
      "mergedAt": "2020-12-15T09:52:57Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "db8158c91191b5a76f8308f1f3a77583a27d6296"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyMjc4MDAz",
          "commit": {
            "abbreviatedOid": "3d53a1c"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-15T09:52:48Z",
          "updatedAt": "2020-12-15T09:52:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc0MDQyOTA3",
      "title": "Teiclap working",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/9",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-16T09:16:22Z",
      "updatedAt": "2021-02-17T08:38:12Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "d91b9f8c30704108b25b5262e69263794426f9fd",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "teiclap-working",
      "headRefOid": "98dc7caf1fdccc875b02bfa21d3ef9ccde2c3fb3",
      "closedAt": "2021-02-17T08:38:12Z",
      "mergedAt": "2021-02-17T08:38:12Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "1b961d99c751dc61c5698523df90a3e42ab236df"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxOTQ2NjIz",
          "commit": {
            "abbreviatedOid": "98dc7ca"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-17T08:37:45Z",
          "updatedAt": "2021-02-17T08:37:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc0ODI2NTc5",
      "title": "Proposal to fix issue #8 Replay Protection Clarification",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/10",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This is a proposal to address issue #8 ",
      "createdAt": "2021-02-17T10:57:40Z",
      "updatedAt": "2022-06-23T12:48:58Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "1b961d99c751dc61c5698523df90a3e42ab236df",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "replay-protection-i8",
      "headRefOid": "9ce2b6e091bec55d15cf67435d9746486e3aedc0",
      "closedAt": "2021-02-19T12:00:11Z",
      "mergedAt": "2021-02-19T12:00:11Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "fdd5bd1d7f2a069a09a6dc2bdbe0fb2b9daca3a0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyMTI4MzUz",
          "commit": {
            "abbreviatedOid": "9ce2b6e"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-17T12:12:26Z",
          "updatedAt": "2021-02-17T12:12:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc2MTE3Njg3",
      "title": "Get rid of parameter in INIT/INIT-ACK",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/18",
      "state": "MERGED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-19T01:58:35Z",
      "updatedAt": "2021-02-19T12:00:30Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "1b961d99c751dc61c5698523df90a3e42ab236df",
      "headRepository": null,
      "headRefName": "main",
      "headRefOid": "6058201047720da3ae696d9e82b18745b02a8e35",
      "closedAt": "2021-02-19T12:00:30Z",
      "mergedAt": "2021-02-19T12:00:30Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "0b8b32782d141ff2791e8fd1d34884d7dcebb9f4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 20,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc2MTIzMzg3",
      "title": "Typos",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/20",
      "state": "MERGED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-19T02:17:21Z",
      "updatedAt": "2021-02-19T12:00:52Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "1b961d99c751dc61c5698523df90a3e42ab236df",
      "headRepository": null,
      "headRefName": "typos",
      "headRefOid": "4410cc991ff95a24ec2bf11c0496f934c073da86",
      "closedAt": "2021-02-19T12:00:52Z",
      "mergedAt": "2021-02-19T12:00:52Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "6660720b6157fcd560259c77eafa44d370aff53b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0MTAyOTE4",
          "commit": {
            "abbreviatedOid": "4410cc9"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "The typo part looks good. ",
          "createdAt": "2021-02-19T11:30:45Z",
          "updatedAt": "2021-02-19T11:30:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc2MTQxMzQw",
      "title": "Security consideration on rekeying",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/21",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-19T03:16:39Z",
      "updatedAt": "2022-06-23T12:49:00Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "1b961d99c751dc61c5698523df90a3e42ab236df",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Security-consideration-on-rekeying",
      "headRefOid": "8730c3d9b6c0606d237b3031246fad83d37f09a2",
      "closedAt": "2021-02-19T12:01:08Z",
      "mergedAt": "2021-02-19T12:01:08Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "e23dba66749a674bfe88bcddf8693ec7f672a352"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0MDI0Njc4",
          "commit": {
            "abbreviatedOid": "ed199f4"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-19T09:49:38Z",
          "updatedAt": "2021-02-19T09:49:38Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Renkeying -> Rekeying?",
              "createdAt": "2021-02-19T09:49:38Z",
              "updatedAt": "2021-02-19T10:45:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0MTAwNjQx",
          "commit": {
            "abbreviatedOid": "8730c3d"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-19T11:27:32Z",
          "updatedAt": "2021-02-19T11:27:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 26,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc2NDg2NjQ1",
      "title": "Fix more typos",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/26",
      "state": "MERGED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-19T14:14:56Z",
      "updatedAt": "2021-02-19T15:52:58Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "e23dba66749a674bfe88bcddf8693ec7f672a352",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "tuexen-typos",
      "headRefOid": "8ea7793e1813b45855eea0cb471fc5e488232484",
      "closedAt": "2021-02-19T15:48:11Z",
      "mergedAt": "2021-02-19T15:48:10Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "6bd74e9f657854df55076d4ad776b8557b9a6443"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0MzE2NTA4",
          "commit": {
            "abbreviatedOid": "8ea7793"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Sorry that some Swedish language conventions has been used. ",
          "createdAt": "2021-02-19T15:48:04Z",
          "updatedAt": "2021-02-19T15:48:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 30,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc2NzI2MDg2",
      "title": "Remove the word \"master\"",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/30",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This aligns the terminology with https://www.ietf.org/rfcdiff?url2=draft-ietf-tls-rfc8446bis-01",
      "createdAt": "2021-02-19T20:59:50Z",
      "updatedAt": "2022-06-23T12:49:04Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "6bd74e9f657854df55076d4ad776b8557b9a6443",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Remove-\"master\"-aligning-with-RFC8446bis",
      "headRefOid": "5fadad4c4cd532ffb74e24ff7dfbafb855f35ef5",
      "closedAt": "2021-02-22T09:55:52Z",
      "mergedAt": "2021-02-22T09:55:52Z",
      "mergedBy": "emanjon",
      "mergeCommit": {
        "oid": "eaf02a4a9361b54cbb0ef80d778d404eaf14d8b4"
      },
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixes and closes #29",
          "createdAt": "2021-02-22T09:55:29Z",
          "updatedAt": "2021-02-22T09:55:29Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc3NDk2NDgz",
      "title": "Update draft-westerlund-tsvwg-dtls-over-sctp-bis.md",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/32",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-22T09:46:53Z",
      "updatedAt": "2022-06-23T12:49:05Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "6bd74e9f657854df55076d4ad776b8557b9a6443",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Renegotiation",
      "headRefOid": "327dcdae15ceb0243f56c687dced5d1bec8bde47",
      "closedAt": "2021-02-22T13:32:17Z",
      "mergedAt": "2021-02-22T13:32:17Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "5ae59bdbe91a9b8c0dafe4ea4dedc2509a04f720"
      },
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "More information on #31 #24 #23 #22 #12 #13",
          "createdAt": "2021-02-22T10:31:07Z",
          "updatedAt": "2021-02-22T10:31:07Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc3NjUzOTU3",
      "title": "Mw editorials",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/33",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fixing wrapping issue in source and with example message exchange that was over flowing. ",
      "createdAt": "2021-02-22T13:48:31Z",
      "updatedAt": "2021-02-22T13:49:53Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "5ae59bdbe91a9b8c0dafe4ea4dedc2509a04f720",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "mw-editorials",
      "headRefOid": "51a3aa70e97b2400a2f0af258e1643a97dca95e9",
      "closedAt": "2021-02-22T13:49:53Z",
      "mergedAt": "2021-02-22T13:49:53Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "1145aee11b333997374dfa37ae76bf3403b18cd5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 34,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc3NzQ2NDQ3",
      "title": "Addressing issues in fallback",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/34",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Fallback section was rewritten to address the changes to use adaptation-indication. So this PR should resolve issue #17 and #19.",
      "createdAt": "2021-02-22T15:57:00Z",
      "updatedAt": "2021-02-22T15:57:08Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "1145aee11b333997374dfa37ae76bf3403b18cd5",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "mw-editorials",
      "headRefOid": "9e65d7f71217d0ca240f181e7da6e9be22e80edd",
      "closedAt": "2021-02-22T15:57:08Z",
      "mergedAt": "2021-02-22T15:57:08Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "03db3ccbbff457b8df949782416e606437443d6f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc3NzYzMDkx",
      "title": "Moving out of place requirement on no plain text.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/36",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Rewrapping text to 70 columns and 3 initial spaces for paragraphs. Removed single sentence in initilization about no user message and wrote new paragraph in DTLS Connection handling that plain text data is a protocol violation and termination is allowed.\r\n\r\nThis addresses #27 ",
      "createdAt": "2021-02-22T16:20:25Z",
      "updatedAt": "2022-06-23T12:49:09Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "03db3ccbbff457b8df949782416e606437443d6f",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "mw-editorials",
      "headRefOid": "c2339422bcb1c56ef72572ea7998e9f598f898e5",
      "closedAt": "2021-02-22T16:21:48Z",
      "mergedAt": "2021-02-22T16:21:47Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "a46f47d20dfff7c460f24152cccd0b7b8fa34295"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 39,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA5MTk4MjQw",
      "title": "Clarified many uses of SCTP-AUTH",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/39",
      "state": "MERGED",
      "author": "vanrein",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": " - These concerns come up due to \"simply\" appending DTLS( m<i> )\r\n - It was not immediately clear that these were handled\r\n - Perhaps some wording in the Security Issues is useful",
      "createdAt": "2021-04-05T20:56:09Z",
      "updatedAt": "2021-06-23T10:03:01Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "a46f47d20dfff7c460f24152cccd0b7b8fa34295",
      "headRepository": "arpa2/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "main",
      "headRefOid": "a08375fcb858bcca686ad3dc9535e6f6acc342c5",
      "closedAt": "2021-06-23T10:03:01Z",
      "mergedAt": "2021-06-23T10:03:01Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "005f4ffd5d953599bf1196f730d177b6fe54a01a"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I think the suggest proposal looks reasonable. ",
          "createdAt": "2021-04-19T07:58:18Z",
          "updatedAt": "2021-04-19T07:58:18Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Look ok",
          "createdAt": "2021-06-21T13:01:25Z",
          "updatedAt": "2021-06-21T13:01:25Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM",
          "createdAt": "2021-06-21T16:32:57Z",
          "updatedAt": "2021-06-21T16:32:57Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 40,
      "id": "MDExOlB1bGxSZXF1ZXN0NjcyNTg2OTQx",
      "title": "Rework for introducing changes from the Issue's list",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/40",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I tried to cover all current Issues.\r\nMost of the Issues in the list related to encryption have been already fixed by John and committed.\r\nNote: a new markdown file \"Adaptation_Layer_Indication.md\" has been prepared for IANA proposal, please Michael take care of it.\r\n",
      "createdAt": "2021-06-17T12:32:51Z",
      "updatedAt": "2022-06-23T12:49:17Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "f577e8c80d4386d9c1833df9c08488a4493e09ae",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "teiclap-rework",
      "headRefOid": "b7fe0037101c633907dbdd5ee2f5659de728ef5f",
      "closedAt": "2021-06-30T09:25:34Z",
      "mergedAt": "2021-06-30T09:25:34Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "a24b6cc218fd057f9bb100b3ae3a7a96552cd73b"
      },
      "comments": [
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Michael,\nisn\u2019t the DTLS implementation part of the rfc6083 layer?\nThe user doesn\u2019t see DTLS actually, or I am wrong?\n \nRegards,\nClaudio.\n \nFrom: Michael T\u00fcxen ***@***.***> \nSent: Monday, June 21, 2021 6:27 PM\nTo: gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis ***@***.***>\nCc: Claudio Porfiri ***@***.***>; Author ***@***.***>\nSubject: Re: [gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis] Rework for introducing changes from the Issue's list (#40)\n \n@tuexen commented on this pull request.\n  _____  \n\nIn draft-westerlund-tsvwg-dtls-over-sctp-bis.md <https://protect2.fireeye.com/v1/url?k=250cd49f-7a97edb4-250c9404-866038973a15-4d49d4fd9176adec&q=1&e=58e87cfb-857c-43d0-b637-9c291eeb5a5b&u=https%3A%2F%2Fgithub.com%2Fgloinul%2Fdraft-westerlund-tsvwg-dtls-over-sctp-bis%2Fpull%2F40%23discussion_r655534158> :\n> @@ -616,8 +622,7 @@ During resumption, the maximum message size is renegotiated.\n    DTLS/SCTP Mandatory Options, in that case the Association will\n    proceed as specified in the previous {{DTLS-init}} section.  If the\n    peer replies with an INIT-ACK not containing all DTLS/SCTP\n-   Mandatory Options, the Client can decide to keep on working with\n-   RFC 6083 fallback, plain data only, or to ABORT the association.\n+   Mandatory Options, the Client SHOULD reply with ABORT.\nThis is hard to realise... At least with SCTP implementations using the socket API specified in RFC 6458 <https://datatracker.ietf.org/doc/html/rfc6458> . The normal procedure is that the upper layer enables some options, sets some parameters, then the association is set up and features are negotiated. After the association has been established, the end-points can check and abort the association.\nThe constraints are coming from the upper layer, so the upper layer should check it. In this case, the upper layer is the DTLS implementation.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub <https://protect2.fireeye.com/v1/url?k=a0d0ac89-ff4b95a2-a0d0ec12-866038973a15-56e20f12c9951de4&q=1&e=58e87cfb-857c-43d0-b637-9c291eeb5a5b&u=https%3A%2F%2Fgithub.com%2Fgloinul%2Fdraft-westerlund-tsvwg-dtls-over-sctp-bis%2Fpull%2F40%23pullrequestreview-688642739> , or unsubscribe <https://protect2.fireeye.com/v1/url?k=aaf2271c-f5691e37-aaf26787-866038973a15-62a1d4ed7d2ef5ac&q=1&e=58e87cfb-857c-43d0-b637-9c291eeb5a5b&u=https%3A%2F%2Fgithub.com%2Fnotifications%2Funsubscribe-auth%2FAQE4BR4ELZOZYY2BILYOXC3TT5R6TANCNFSM463SPX3Q> .\n",
          "createdAt": "2021-06-22T07:21:09Z",
          "updatedAt": "2021-06-22T07:21:09Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Hi Michael, isn\u2019t the DTLS implementation part of the rfc6083 layer? The user doesn\u2019t see DTLS actually, or I am wrong? \r\n> Regards, Claudio.\r\n\r\nIn my view [RFC 6083](https://datatracker.ietf.org/doc/html/rfc6083) describes how to use DTLS over SCTP. It is not describing a single layer, but how to combine two. The application is interacting with the upper layer interface of DTLS.\r\n\r\nI'm not sure why you are asking the above question. Can elaborate?",
          "createdAt": "2021-06-22T07:58:22Z",
          "updatedAt": "2021-06-22T07:58:22Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi Michael,\nin my view rfc6083 is a layer on its own, it offers the same interface as SCTP and has the possibility\nto exploit DTLS as an encryption engine.\nrfc6083 layer does fragmentation and reassembly of user data and interfaces both DTLS and SCTP.\nIn my view, DTLS is not even visible to the user.\nIn the implementation, it may be hidden inside SCTP API (by adding some extra parameters).\n \nRegards,\nClaudio.\n \n \nFrom: Michael T\u00fcxen ***@***.***> \nSent: Tuesday, June 22, 2021 9:59 AM\nTo: gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis ***@***.***>\nCc: Claudio Porfiri ***@***.***>; Author ***@***.***>\nSubject: Re: [gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis] Rework for introducing changes from the Issue's list (#40)\n \nHi Michael, isn\u2019t the DTLS implementation part of the rfc6083 layer? The user doesn\u2019t see DTLS actually, or I am wrong?\nRegards, Claudio.\nIn my view RFC 6083 <https://datatracker.ietf.org/doc/html/rfc6083>  describes how to use DTLS over SCTP. It is not describing a single layer, but how to combine two. The application is interacting with the upper layer interface of DTLS.\nI'm not sure why you are asking the above question. Can elaborate?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub <https://protect2.fireeye.com/v1/url?k=4e9d81f4-1106b8f1-4e9dc16f-86d2114eab2f-26e819f9c0aafde3&q=1&e=001bd3e2-f07a-44cb-a965-d9d6572f8e2c&u=https%3A%2F%2Fgithub.com%2Fgloinul%2Fdraft-westerlund-tsvwg-dtls-over-sctp-bis%2Fpull%2F40%23issuecomment-865689278> , or unsubscribe <https://protect2.fireeye.com/v1/url?k=13adf326-4c36ca23-13adb3bd-86d2114eab2f-8a070df4fc7cb87d&q=1&e=001bd3e2-f07a-44cb-a965-d9d6572f8e2c&u=https%3A%2F%2Fgithub.com%2Fnotifications%2Funsubscribe-auth%2FAQE4BRYIP6B2E6FDHP2TT43TUA7C3ANCNFSM463SPX3Q> .\n",
          "createdAt": "2021-06-22T08:30:39Z",
          "updatedAt": "2021-06-22T08:30:39Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Hi Michael, in my view rfc6083 is a layer on its own, it offers the same interface as SCTP and has the possibility to exploit DTLS as an encryption engine. rfc6083 layer does fragmentation and reassembly of user data and interfaces both DTLS and SCTP. In my view, DTLS is not even visible to the user. In the implementation, it may be hidden inside SCTP API (by adding some extra parameters). Regards, Claudio. \r\n\r\nAhh, I see. I do see DTLS/SCTP like I see TLS/TCP. You can implement TLS on top of TCP by using the upper layer API of TCP. For example, OpenSSL does it like this. The same is true for the DTLS/SCTP implementation of OpenSSL and the SCTP implementation of the FreeBSD or Linux kernel. I'm not saying that this is the only way of implementing DTLS/SCTP, but I think it should be at least one possible way of doing so.",
          "createdAt": "2021-06-22T11:27:55Z",
          "updatedAt": "2021-06-22T11:45:08Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "The IANA changed has been removed from this PR and instead have been improved in #44. ",
          "createdAt": "2021-06-29T15:00:22Z",
          "updatedAt": "2021-06-29T15:00:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg4NjMwNjE4",
          "commit": {
            "abbreviatedOid": "5315ee4"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-21T16:14:19Z",
          "updatedAt": "2021-06-21T16:14:19Z",
          "comments": [
            {
              "originalPosition": 223,
              "body": "Can you elaborate on why two DTLS records is enough?\r\n\r\nCan't you have on each incoming stream an incomplete DTLS record you can't process at the DTLS layer?",
              "createdAt": "2021-06-21T16:14:19Z",
              "updatedAt": "2021-06-21T16:14:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg4NjQyNzM5",
          "commit": {
            "abbreviatedOid": "5315ee4"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-21T16:27:03Z",
          "updatedAt": "2021-06-21T16:27:04Z",
          "comments": [
            {
              "originalPosition": 346,
              "body": "This is hard to realise... At least with SCTP implementations using the socket API specified in [RFC 6458](https://datatracker.ietf.org/doc/html/rfc6458). The normal procedure is that the upper layer enables some options, sets some parameters, then the association is set up and features are negotiated. After the association has been established, the end-points can check and abort the association.\r\n\r\nThe constraints are coming from the upper layer, so the upper layer should check it. In this case, the upper layer is the DTLS implementation.",
              "createdAt": "2021-06-21T16:27:03Z",
              "updatedAt": "2021-06-21T16:27:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg4NjQ0MDEw",
          "commit": {
            "abbreviatedOid": "5315ee4"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-21T16:28:27Z",
          "updatedAt": "2021-06-21T16:28:27Z",
          "comments": [
            {
              "originalPosition": 356,
              "body": "See my comment above. Isn't checking the requirements of an upper layer the job of the upper layer?",
              "createdAt": "2021-06-21T16:28:27Z",
              "updatedAt": "2021-06-21T16:28:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg5MjE5MDU4",
          "commit": {
            "abbreviatedOid": "5315ee4"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-22T08:36:10Z",
          "updatedAt": "2021-06-22T08:36:10Z",
          "comments": [
            {
              "originalPosition": 223,
              "body": "So the comment on two DTLS records are per user message which properly should be made explicit. So you may have multiple of these, so per stream for in order delivery, and for streams with out of order delivery it becomes per message. \r\n\r\nIt also includes an assumption that may be wrong in some implementation, that the partial delivery will only release data up to the earliest gap in the byte delivery, i.e. the data prior and including the cumulative ACK, but not ranges of data beyond a gap in the user message will be given to the layer above SCTP, and that SCTP will be responsible for holding this buffer.",
              "createdAt": "2021-06-22T08:36:10Z",
              "updatedAt": "2021-06-22T08:36:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg5MjIyMTU2",
          "commit": {
            "abbreviatedOid": "5315ee4"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-22T08:39:00Z",
          "updatedAt": "2021-06-22T08:39:01Z",
          "comments": [
            {
              "originalPosition": 346,
              "body": "Sounds like something that can be resolved with an reformulation. I guess the issue here is depending on how one interpret the meaning of \"the client\". If that is the SCTP layer only, no I can see the validity of your comment under some API, but I think we are talking about the DTLS + SCTP stack combination that needs to do the right thing here.",
              "createdAt": "2021-06-22T08:39:01Z",
              "updatedAt": "2021-06-22T08:39:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njg5MzY3ODI1",
          "commit": {
            "abbreviatedOid": "5315ee4"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-22T11:09:01Z",
          "updatedAt": "2021-06-22T11:09:01Z",
          "comments": [
            {
              "originalPosition": 346,
              "body": "> Sounds like something that can be resolved with an reformulation. I guess the issue here is depending on how one interpret the meaning of \"the client\". If that is the SCTP layer only, no I can see the validity of your comment under some API, but I think we are talking about the DTLS + SCTP stack combination that needs to do the right thing here.\r\n\r\nYes.",
              "createdAt": "2021-06-22T11:09:01Z",
              "updatedAt": "2021-06-22T11:09:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk1MTc4OTA1",
          "commit": {
            "abbreviatedOid": "cfcc740"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-29T15:19:19Z",
          "updatedAt": "2021-06-29T15:19:19Z",
          "comments": [
            {
              "originalPosition": 346,
              "body": "I have just committed some changes to these two paragraphs. @tuexen can you please check if this is better or possible suggest rewording?",
              "createdAt": "2021-06-29T15:19:19Z",
              "updatedAt": "2021-06-29T15:19:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk1Mjc0NjU3",
          "commit": {
            "abbreviatedOid": "cfcc740"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-29T16:49:17Z",
          "updatedAt": "2021-06-29T16:49:17Z",
          "comments": [
            {
              "originalPosition": 346,
              "body": "Will do after we finished the handshake discussion.",
              "createdAt": "2021-06-29T16:49:17Z",
              "updatedAt": "2021-06-29T16:49:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 41,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc0NTQ2NzM0",
      "title": "Cryptographic parameters",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/41",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-06-21T13:18:23Z",
      "updatedAt": "2022-06-23T12:49:12Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "9043e3d7c0ffe87b5d36ffc9eea1b3ff0b3f5242",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "DTLS",
      "headRefOid": "88a19db59840e56a7f158d9ab3c00a32f6c3d073",
      "closedAt": "2021-06-23T10:04:31Z",
      "mergedAt": "2021-06-23T10:04:31Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "5730b3b3b69eff2b42ec2b9b006800889dc7d68b"
      },
      "comments": [
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM",
          "createdAt": "2021-06-21T16:31:12Z",
          "updatedAt": "2021-06-21T16:31:12Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 42,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc5OTgwMzAw",
      "title": "Resolving issue 24",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/42",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Describing that long lived sessions that cant reconnect easily may have to use DTLS 1.2. This should resolve the last part of Issue #24 ",
      "createdAt": "2021-06-29T13:21:06Z",
      "updatedAt": "2021-06-29T13:30:48Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "5730b3b3b69eff2b42ec2b9b006800889dc7d68b",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue24",
      "headRefOid": "7b51e9141c640bd21d9bd4512e6656b40dd80609",
      "closedAt": "2021-06-29T13:22:08Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 43,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc5OTg4MDcz",
      "title": "Resolving issue 24 by clarifying that for long lived connections that\u2026",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/43",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "\u2026 cant reconnect may have to use DTLS 1.2. Resolves #24 ",
      "createdAt": "2021-06-29T13:27:38Z",
      "updatedAt": "2022-06-23T12:49:15Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "5730b3b3b69eff2b42ec2b9b006800889dc7d68b",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue24b",
      "headRefOid": "377d98fffda53f00e2361b66d564de5865649e0a",
      "closedAt": "2021-06-30T09:22:00Z",
      "mergedAt": "2021-06-30T09:21:59Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "f577e8c80d4386d9c1833df9c08488a4493e09ae"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I would note that there could be some improvement here if one restructured the section a bit as some of the useful information for the new paragraph is following the added paragraph. ",
          "createdAt": "2021-06-29T13:29:08Z",
          "updatedAt": "2021-06-29T13:29:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0NjgwMDkzNzcy",
      "title": "Proposed IANA section for adding Adaptation Code Point. Additional re\u2026",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/44",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "\u2026ference additions. This intend to resolve #15. It also add a few informative references from within the document to the IANA section. ",
      "createdAt": "2021-06-29T14:55:59Z",
      "updatedAt": "2022-06-23T12:49:16Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "5730b3b3b69eff2b42ec2b9b006800889dc7d68b",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "iana-ali",
      "headRefOid": "4a987058843b687b6115f9a135e8e7088c7e72ce",
      "closedAt": "2021-06-30T09:21:41Z",
      "mergedAt": "2021-06-30T09:21:41Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "ea4f05f4f2c799c7f26c35a185127962dc7b1a9e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk1ODU4NjYz",
          "commit": {
            "abbreviatedOid": "3c5c9c1"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-30T08:46:19Z",
          "updatedAt": "2021-06-30T08:46:20Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Fix reference to point to RFC6083bis [RFCTBD]",
              "createdAt": "2021-06-30T08:46:20Z",
              "updatedAt": "2021-06-30T08:46:20Z"
            }
          ]
        }
      ]
    },
    {
      "number": 45,
      "id": "MDExOlB1bGxSZXF1ZXN0NjgwNzMxNjU0",
      "title": "\"dtls_over_sctp_maximum_message_size\" IANA section",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/45",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The registry now refers to RFC 8447 only. No reason to reference RFC5246\r\n\r\nDLTS-Only column was missing.\r\n\r\nSome text was duplicated.",
      "createdAt": "2021-06-30T10:26:18Z",
      "updatedAt": "2022-06-23T12:49:19Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "a24b6cc218fd057f9bb100b3ae3a7a96552cd73b",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "emanjon-patch-1",
      "headRefOid": "ce43dbdd61772f210413a3d536d41053dbbf787a",
      "closedAt": "2021-06-30T12:46:53Z",
      "mergedAt": "2021-06-30T12:46:53Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "2bc09f71839a7bbf7dd24af7708a36ea912f0cb5"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Per today's discussion the message size is to be removed. But maybe the easiest is to merge this, and then remove it so that if we need to backtrack we have these improvements in the repository. ",
          "createdAt": "2021-06-30T12:17:46Z",
          "updatedAt": "2021-06-30T12:17:46Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0NjgxODYyMDIz",
      "title": "Resolving Issue 38 on user message sizes, partial delivery and failures.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/48",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This attempts to address issue #38. The main changes are:\r\n- Removing the message size parameter\r\n- Clarifying how DTLS/SCTP resources are bounded in relation to streams and user messages. \r\n- Require partial delivery API to be able to fulfill the bounded resources. \r\n- Addressing failures in receiver when processing DTLS records. ",
      "createdAt": "2021-07-01T13:30:20Z",
      "updatedAt": "2021-10-25T08:58:55Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "9585486483b1f8ddfc7fdaa1a90cd1524a498dc6",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue38",
      "headRefOid": "4071120fb0b655cc7596011ea5ca7409e3f623dd",
      "closedAt": "2021-07-01T14:55:56Z",
      "mergedAt": "2021-07-01T14:55:56Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "4e0245634163398408bc3d079f6cfbb349004200"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3Mjc2ODkz",
          "commit": {
            "abbreviatedOid": "b88d155"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-01T13:55:47Z",
          "updatedAt": "2021-07-01T13:55:48Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Do we need a space between 1.3 and {{?",
              "createdAt": "2021-07-01T13:55:48Z",
              "updatedAt": "2021-07-01T13:55:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3MjgxNDU2",
          "commit": {
            "abbreviatedOid": "b88d155"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-01T13:59:28Z",
          "updatedAt": "2021-07-01T13:59:29Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "What about:\r\n```\r\nas well mandating an SCTP API (for example the one described in {{RFC6458}})\r\nthat supports partial user message delivery.\r\n```\r\nsince even the API described in RFC 4960 does support it.",
              "createdAt": "2021-07-01T13:59:29Z",
              "updatedAt": "2021-07-01T13:59:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3MjgyMjY3",
          "commit": {
            "abbreviatedOid": "b88d155"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-01T14:00:10Z",
          "updatedAt": "2021-07-01T14:00:11Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Not sure we need a reference to RFC6458 here. I would just remove it.",
              "createdAt": "2021-07-01T14:00:11Z",
              "updatedAt": "2021-07-01T14:00:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3MjgzMzc0",
          "commit": {
            "abbreviatedOid": "b88d155"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-01T14:01:08Z",
          "updatedAt": "2021-07-01T14:01:08Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "Not sure we need the reference to RFC6458 here.",
              "createdAt": "2021-07-01T14:01:08Z",
              "updatedAt": "2021-07-01T14:01:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3Mjg4Nzc1",
          "commit": {
            "abbreviatedOid": "b88d155"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-01T14:05:43Z",
          "updatedAt": "2021-07-01T14:05:43Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "Ordered or unordered is a property of a user message, not of a stream. So I would suggest to write something like:\r\n```\r\nHowever, by requiring the use of the partial delivery of user messages\r\nfrom SCTP and assuming that no two messages received on the same\r\nstream are interleaved (as it is the case when using the API defined\r\nin {{RFC6458}}) the required buffering prior to DTLS processing can\r\nbe limited to a single DTLS record per used incoming stream.\r\n```",
              "createdAt": "2021-07-01T14:05:43Z",
              "updatedAt": "2021-07-01T14:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3MjkwNzky",
          "commit": {
            "abbreviatedOid": "b88d155"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-01T14:07:23Z",
          "updatedAt": "2021-07-01T14:07:24Z",
          "comments": [
            {
              "originalPosition": 172,
              "body": "Maybe `detect and then act on` is better?",
              "createdAt": "2021-07-01T14:07:23Z",
              "updatedAt": "2021-07-01T14:07:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3MjkzNDc3",
          "commit": {
            "abbreviatedOid": "b88d155"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-01T14:09:35Z",
          "updatedAt": "2021-07-01T14:09:35Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "Maybe add a comma after `message`?",
              "createdAt": "2021-07-01T14:09:35Z",
              "updatedAt": "2021-07-01T14:09:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3MzEzMDUy",
          "commit": {
            "abbreviatedOid": "b88d155"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-01T14:26:05Z",
          "updatedAt": "2021-07-01T14:26:05Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Yes, fixed. ",
              "createdAt": "2021-07-01T14:26:05Z",
              "updatedAt": "2021-07-01T14:26:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3MzE0Nzc2",
          "commit": {
            "abbreviatedOid": "b88d155"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-01T14:27:30Z",
          "updatedAt": "2021-07-01T14:27:30Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Yes, that improves. Implemented.",
              "createdAt": "2021-07-01T14:27:30Z",
              "updatedAt": "2021-07-01T14:27:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3MzE1Njk3",
          "commit": {
            "abbreviatedOid": "b88d155"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-01T14:28:19Z",
          "updatedAt": "2021-07-01T14:28:19Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Agreed, a result of writing changes in the wrong order. ",
              "createdAt": "2021-07-01T14:28:19Z",
              "updatedAt": "2021-07-01T14:28:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3MzIwNTAy",
          "commit": {
            "abbreviatedOid": "b88d155"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-01T14:32:17Z",
          "updatedAt": "2021-07-01T14:32:17Z",
          "comments": [
            {
              "originalPosition": 172,
              "body": "Yes. implemented. ",
              "createdAt": "2021-07-01T14:32:17Z",
              "updatedAt": "2021-07-01T14:32:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3MzIwNjE5",
          "commit": {
            "abbreviatedOid": "b88d155"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-01T14:32:24Z",
          "updatedAt": "2021-07-01T14:32:24Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "Yes.",
              "createdAt": "2021-07-01T14:32:24Z",
              "updatedAt": "2021-07-01T14:32:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3MzQzNTY1",
          "commit": {
            "abbreviatedOid": "b88d155"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-01T14:52:03Z",
          "updatedAt": "2021-07-01T14:52:04Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "I ended up rewriting the whole sentence. ",
              "createdAt": "2021-07-01T14:52:03Z",
              "updatedAt": "2021-07-01T14:52:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3MzQ1ODc4",
          "commit": {
            "abbreviatedOid": "4071120"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-01T14:54:01Z",
          "updatedAt": "2021-07-01T14:54:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0NjgxOTQ1NzAy",
      "title": "Fixed the double negative writing on DTLS 1.3 length field in Mapping\u2026",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/49",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "\u2026 of DTLS records. Fixes #47 ",
      "createdAt": "2021-07-01T15:07:50Z",
      "updatedAt": "2021-10-25T08:58:51Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "4e0245634163398408bc3d079f6cfbb349004200",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue47",
      "headRefOid": "287890eb42ac69871a53c39deac58d0a19845064",
      "closedAt": "2021-07-01T15:08:32Z",
      "mergedAt": "2021-07-01T15:08:32Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "bd0e6fde2ff37c66ddfe268ddf646f9bca0bc0be"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0NjgzOTUzNTQ0",
      "title": "Cleanup the text.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/50",
      "state": "MERGED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This  fixes https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/14",
      "createdAt": "2021-07-05T22:13:14Z",
      "updatedAt": "2021-07-06T07:50:26Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "bd0e6fde2ff37c66ddfe268ddf646f9bca0bc0be",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "tuexen-issue-14",
      "headRefOid": "9c5a14af502fe547a579d17630859e16364d6688",
      "closedAt": "2021-07-06T07:50:22Z",
      "mergedAt": "2021-07-06T07:50:22Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "ee6cb119c86014551bae043f770dcd879853c600"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Looks good.",
          "createdAt": "2021-07-06T07:50:26Z",
          "updatedAt": "2021-07-06T07:50:26Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg0MjQ2NDU4",
      "title": "Added introduction section on DTLS version.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/51",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "\u2026o review of usage of the word DTLS.\r\n\r\nAttempt to resolve #46 ",
      "createdAt": "2021-07-06T10:20:36Z",
      "updatedAt": "2021-10-25T08:58:47Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "ee6cb119c86014551bae043f770dcd879853c600",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "magnus-issue46",
      "headRefOid": "77a1a01141bde8002b91ecf1b140f96c345c0799",
      "closedAt": "2021-07-07T12:38:03Z",
      "mergedAt": "2021-07-07T12:38:02Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "1511638afeba94f1ac06ac50b7c2415a080f3820"
      },
      "comments": [
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Added some more comments (now I'm done with it). When they are addressed, I'm fine with the changes.\r\nWill also address the issues assigned to me later today.",
          "createdAt": "2021-07-06T13:27:31Z",
          "updatedAt": "2021-07-06T13:27:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5ODExMzc4",
          "commit": {
            "abbreviatedOid": "5ad01de"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T10:53:38Z",
          "updatedAt": "2021-07-06T10:53:39Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Remove `is`",
              "createdAt": "2021-07-06T10:53:39Z",
              "updatedAt": "2021-07-06T10:53:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5ODEyMjYx",
          "commit": {
            "abbreviatedOid": "5ad01de"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T10:54:47Z",
          "updatedAt": "2021-07-06T10:54:48Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Use `known` instead of `know`.",
              "createdAt": "2021-07-06T10:54:47Z",
              "updatedAt": "2021-07-06T10:54:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5ODEzNDgw",
          "commit": {
            "abbreviatedOid": "5ad01de"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T10:56:17Z",
          "updatedAt": "2021-07-06T10:56:17Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "`its` instead oh `their`.",
              "createdAt": "2021-07-06T10:56:17Z",
              "updatedAt": "2021-07-06T10:56:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5ODE0Nzg1",
          "commit": {
            "abbreviatedOid": "5ad01de"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T10:57:50Z",
          "updatedAt": "2021-07-06T10:57:50Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "`implementation constraints` instead of `implementations constrain`?",
              "createdAt": "2021-07-06T10:57:50Z",
              "updatedAt": "2021-07-06T10:57:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5OTQ1MTg0",
          "commit": {
            "abbreviatedOid": "631d8ac"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T13:21:27Z",
          "updatedAt": "2021-07-06T13:21:27Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "maybe `is preferred as being a new protocol`?",
              "createdAt": "2021-07-06T13:21:27Z",
              "updatedAt": "2021-07-06T13:21:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5OTQ1Nzkw",
          "commit": {
            "abbreviatedOid": "631d8ac"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T13:21:58Z",
          "updatedAt": "2021-07-06T13:21:58Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "`defines` instead of `define` and `known major weaknesses` instead of `major weaknesses`?",
              "createdAt": "2021-07-06T13:21:58Z",
              "updatedAt": "2021-07-06T13:22:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5OTQ3Mjc4",
          "commit": {
            "abbreviatedOid": "631d8ac"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T13:23:17Z",
          "updatedAt": "2021-07-06T13:23:17Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "May `some application using DTLS/SCTP`...",
              "createdAt": "2021-07-06T13:23:17Z",
              "updatedAt": "2021-07-06T13:23:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5OTQ3NjUx",
          "commit": {
            "abbreviatedOid": "631d8ac"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T13:23:37Z",
          "updatedAt": "2021-07-06T13:23:37Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "`use` instead of `uses`.",
              "createdAt": "2021-07-06T13:23:37Z",
              "updatedAt": "2021-07-06T13:23:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5OTQ5MjQ3",
          "commit": {
            "abbreviatedOid": "631d8ac"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T13:25:01Z",
          "updatedAt": "2021-07-06T13:25:02Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Why adding a trailing whitespace?",
              "createdAt": "2021-07-06T13:25:01Z",
              "updatedAt": "2021-07-06T13:25:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5OTQ5NzI5",
          "commit": {
            "abbreviatedOid": "631d8ac"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-06T13:25:25Z",
          "updatedAt": "2021-07-06T13:25:25Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "`defines the usage` instead of `defines usage`.",
              "createdAt": "2021-07-06T13:25:25Z",
              "updatedAt": "2021-07-06T13:25:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAwODEzOTc5",
          "commit": {
            "abbreviatedOid": "77a1a01"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-07T09:59:34Z",
          "updatedAt": "2021-07-07T09:59:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 53,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg3Mzc5Mzgy",
      "title": "Add socket API section.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/53",
      "state": "MERGED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This fixes https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/16",
      "createdAt": "2021-07-11T18:45:27Z",
      "updatedAt": "2021-07-12T12:59:36Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "a8a077e3a92ce40db29f364940c1c7a8f2f644a3",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "tuexen-issue-14",
      "headRefOid": "6146d45c5155565b705e8be48351ba7405e7a1d7",
      "closedAt": "2021-07-12T11:44:44Z",
      "mergedAt": "2021-07-12T11:44:43Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "26a24ecbf7900a233e2179fad554a75de8cc8c1b"
      },
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me, but I have limited knowledge of this API.",
          "createdAt": "2021-07-12T10:34:11Z",
          "updatedAt": "2021-07-12T10:34:11Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Looks good to me, but I have limited knowledge of this API.\r\n\r\nI'm pretty sure that this is OK, will implement this before this ID goes to WGLC.",
          "createdAt": "2021-07-12T10:50:44Z",
          "updatedAt": "2021-07-12T10:50:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MDE1ODAx",
          "commit": {
            "abbreviatedOid": "6146d45"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "This text works, I think it could be clearer in what changes it actually does. But I think I understand the addition and changes. ",
          "createdAt": "2021-07-12T11:44:30Z",
          "updatedAt": "2021-07-12T11:44:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 55,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg3NDY1MTU2",
      "title": "Address AUTH key handling and epoch handling",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/55",
      "state": "MERGED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This should describe the handling of AUTH keys such that we are sure that we are not loosing any messages due to missing AUTH keys. It also describes the epoch handling, but this still has some issues.",
      "createdAt": "2021-07-12T02:58:09Z",
      "updatedAt": "2021-10-25T08:58:43Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "a8a077e3a92ce40db29f364940c1c7a8f2f644a3",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "tuexen-issue-25",
      "headRefOid": "62488693cd3e2f94579cbe7890d895838a7edd16",
      "closedAt": "2021-07-12T14:21:36Z",
      "mergedAt": "2021-07-12T14:21:36Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "93996cf8443f086c81052dd299f6c197f79b0212"
      },
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Comments on the SCTP-AUTH part\r\n\r\n\r\n>   Before sending the DTLS Finished message, the active SCTP-AUTH key\r\n>   SHOULD be switched to the new one, it MAY be sent using the old one\r\n>   (for example in the case of the client performing a full handshake or the\r\n>   server performing a session-resuming handshake).\r\n>   If the active SCTP-AUTH key is not switched to the new one before sending\r\n>   the DTLS Finished message, it MUST be switched to the new one immediately\r\n>   after sending the DTLS Finished message.\r\n\r\nOn the client side, the Finished message is likely send in the same DTLS record as the\r\nChangeCipherSpec. While the TLS implementation has all information to derive the\r\nmaster secret after generating ChangeCipherSpec, I don't know when the new master\r\nkey is made available to the exporter, I think this is unspecified....\r\n\r\nMaybe it is best to have \"After sending the DTLS Finished message,\" for both\r\nDTLS 1.2 and DTLS 1.3\r\n\r\n> (for example in the case of the client performing a full handshake or the\r\n> server performing a session-resuming handshake).\r\n\r\nThis list seems exhaustive.\r\n\r\n>   Once the Finished message using DTLS epoch n with n > 2 has been processed\r\n>   by DTLS, the SCTP-AUTH key with Shared Key Identifier n - 2 MUST be removed.\r\n\r\nI think this should be \"n > 3\" as 0 has already been removed.\r\n\r\n\r\n",
          "createdAt": "2021-07-12T05:19:16Z",
          "updatedAt": "2021-07-12T05:19:16Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Comments on the DTLS parts:\r\n\r\n>Before sending during renegotiation a ClientHello message or ServerHello\r\n>   message, \r\n\r\nThe server send a HelloRequest message to initiate renegotiation (Not ServerHello).\r\nCould we say just: \"Before inititating or accepting renegotiation\"?\r\n\r\n\r\n\r\n>User messages that arrive between ChangeCipherSpec and Finished messages and\r\n>   use the new epoch have probably passed the Finished message and MUST be\r\n>   buffered by DTLS until the Finished message has been processed.\r\n\r\nShould this be user messages? user messages might be processed with several different epochs I assume.\r\nWould \"user messages where SCTP chunks arrive between...\" be better?\r\n",
          "createdAt": "2021-07-12T05:31:06Z",
          "updatedAt": "2021-07-12T05:31:06Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "I assume updating key after ChangeCipherSpec is standards. But what about the reciving side? I think we need to have a requirement here that ChangeCipherSpec is send using old SCTP-AUTH key, otherwise the receiving will reject ChangeCipherSpec before processing it. We probably don't want to mandate anything for the DTLS  layer.",
          "createdAt": "2021-07-12T05:36:22Z",
          "updatedAt": "2021-07-12T05:36:22Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Comments on the SCTP-AUTH part\r\n> \r\n> > Before sending the DTLS Finished message, the active SCTP-AUTH key\r\n> > SHOULD be switched to the new one, it MAY be sent using the old one\r\n> > (for example in the case of the client performing a full handshake or the\r\n> > server performing a session-resuming handshake).\r\n> > If the active SCTP-AUTH key is not switched to the new one before sending\r\n> > the DTLS Finished message, it MUST be switched to the new one immediately\r\n> > after sending the DTLS Finished message.\r\n> \r\n> On the client side, the Finished message is likely send in the same DTLS record as the\r\n> ChangeCipherSpec. While the TLS implementation has all information to derive the\r\n> master secret after generating ChangeCipherSpec, I don't know when the new master\r\n> key is made available to the exporter, I think this is unspecified....\r\n\r\nI think the Finished and the ChangeCipherSpec messages each have its own DTLS record header,\r\nbut I think both records are often put in the same UDP packet.\r\n\r\nI agree, that it is left unspecified when the exporter (using some API) can be used.\r\nSince implementing SCTP/DTLS has to touch code in the DTLS implementation, I was\r\nassuming that this could be changed to fit our needs...\r\n\r\n> \r\n> Maybe it is best to have \"After sending the DTLS Finished message,\" for both\r\n> DTLS 1.2 and DTLS 1.3\r\n\r\nI'm fine with that.\r\n\r\n> \r\n> > (for example in the case of the client performing a full handshake or the\r\n> > server performing a session-resuming handshake).\r\n> \r\n> This list seems exhaustive.\r\n\r\nIt is not intended to cover the server side performing a full handshake or\r\nthe client side performing a session-resuming handshake. In both cases\r\nthe peer can make sure the SCTP AUTH keys are configured when the\r\ncorresponding packets are received.\r\n\r\n> \r\n> > Once the Finished message using DTLS epoch n with n > 2 has been processed\r\n> > by DTLS, the SCTP-AUTH key with Shared Key Identifier n - 2 MUST be removed.\r\n> \r\n> I think this should be \"n > 3\" as 0 has already been removed.\r\n\r\nI think the text is correct. The smallest applicable number is 3 and this would result\r\nin removing 3 - 2 = 1, which is not 0.\r\n\r\n",
          "createdAt": "2021-07-12T07:16:23Z",
          "updatedAt": "2021-07-12T07:16:23Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Comments on the DTLS parts:\r\n> \r\n> > Before sending during renegotiation a ClientHello message or ServerHello\r\n> > message,\r\n> \r\n> The server send a HelloRequest message to initiate renegotiation (Not ServerHello).\r\n> Could we say just: \"Before inititating or accepting renegotiation\"?\r\n\r\nSure. It would be OK, if the client does this check before sending the ClientHello message in response to the HelloRequest, but we can change roles here. I don't think it makes a difference.\r\n\r\nBut then the next paragraph becomes more complex. \r\n\r\nI can change both paragraphs if you want. Just let me know.\r\n\r\n> \r\n> > User messages that arrive between ChangeCipherSpec and Finished messages and\r\n> > use the new epoch have probably passed the Finished message and MUST be\r\n> > buffered by DTLS until the Finished message has been processed.\r\n> \r\n> Should this be user messages? user messages might be processed with several different epochs I assume.\r\n> Would \"user messages where SCTP chunks arrive between...\" be better?\r\n\r\nBut is it OK to process user message of a new epoch *before* processing the Finished message? Couldn't this be used by an attacker to get message delivered to the application and bypassing the checks done by processing the Finished message?\r\n\r\n",
          "createdAt": "2021-07-12T07:28:23Z",
          "updatedAt": "2021-07-12T07:28:23Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I assume updating key after ChangeCipherSpec is standards. But what about the reciving side? I think we need to have a requirement here that ChangeCipherSpec is send using old SCTP-AUTH key, otherwise the receiving will reject ChangeCipherSpec before processing it. We probably don't want to mandate anything for the DTLS layer.\r\n\r\nI agree with both points. Were is the text contradicting this?\r\n\r\n",
          "createdAt": "2021-07-12T07:31:15Z",
          "updatedAt": "2021-07-12T07:31:15Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "\"previous epoch\" could maybe be misunderstood...  Yes, I think it should be something like:\r\n\r\n   Before inititating or accepting renegotiation resulting in epoch n+1, the DTLS endpoint MUST ensure\r\n   that all DTLS messages using epoch n-1 have been acknowledged by\r\n   the SCTP peer in a non-revokable way.\r\n\r\nI don't think the endpoints can change roles. \r\n\r\n\r\n\r\nI think the following is handled by DTLS:\r\n\r\n   User messages that arrive between ChangeCipherSpec and Finished messages and\r\n   use the new epoch have probably passed the Finished message and MUST be\r\n   buffered by DTLS until the Finished message has been processed.\r\n\r\n\r\nI don't see why the following is needed as the requires as the endpoint has both the new and the old key in parallel.\r\n\r\n   Prior to processing a received ClientHello message or ServerHello\r\n   message, all other received SCTP user messages that are buffered in the\r\n   SCTP layer and can be delivered to the DTLS layer MUST be read and\r\n   processed by DTLS.\r\n\r\n",
          "createdAt": "2021-07-12T08:17:23Z",
          "updatedAt": "2021-07-12T08:17:23Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> \"previous epoch\" could maybe be misunderstood... Yes, I think it should be something like:\r\n> \r\n> Before inititating or accepting renegotiation resulting in epoch n+1, the DTLS endpoint MUST ensure\r\n> that all DTLS messages using epoch n-1 have been acknowledged by\r\n> the SCTP peer in a non-revokable way.\r\n> \r\n> I don't think the endpoints can change roles.\r\n\r\nNo, they can't. But using the text I suggested, the client drains first, then the server, no matter which side triggered the renegotiation.\r\n\r\nIn your text, if the client triggers the renegotiation, the client drains first, then the server. If the server triggers the renegotiation, the server drains first, then the client drains.\r\nI'm not sure if you consider this different important or not.\r\n\r\n> \r\n> I think the following is handled by DTLS:\r\n> \r\n> User messages that arrive between ChangeCipherSpec and Finished messages and\r\n> use the new epoch have probably passed the Finished message and MUST be\r\n> buffered by DTLS until the Finished message has been processed.\r\n\r\nYes, you are right. This is handled in DTLS 1.2, but wasn't in DTLS 1.0. That is why we added it to RFC 6083.\r\nI've removed it.\r\n> \r\n> I don't see why the following is needed as the requires as the endpoint has both the new and the old key in parallel.\r\n> \r\n> Prior to processing a received ClientHello message or ServerHello\r\n> message, all other received SCTP user messages that are buffered in the\r\n> SCTP layer and can be delivered to the DTLS layer MUST be read and\r\n> processed by DTLS.\r\n\r\nAs far as I understood, draining and waiting is no an option. So the idea was to have always (when it makes sense) the current and the key before active to avoid message loss due to missing key material.\r\n\r\nHere is the procedure:\r\n\r\nLooking at data sent from the client to the server. The client uses epoch n. Before sending the ClientHello message, the client must stop and wait until all data using epoch n - 1 has the acknowledged by the peer. That means, when the server reads the ClientHello, all data using epoch n - 1 which has not been processed by the DTLS layer is at least buffered at the SCTP layer. Now reading and processing it ensures that all data using epoch n - 1 has been completely processed before switching to epoch n + 1. This means the DTLS layer can drop the keys for epoch n - 1 when switching to epoch n + 1. So for receiving the DTLS layer only needs the key material of two epochs, not more.\r\n\r\nThe same applies for data sent from the server to the client.\r\n\r\nDoes this makes sense? Is it acceptable?\r\n\r\n",
          "createdAt": "2021-07-12T08:53:32Z",
          "updatedAt": "2021-07-12T08:53:32Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": " >After sending the KeyUpdate message, it stops sending DTLS messages until\r\n  >the corresponding Ack message has been processed.\r\n  \r\n  Is this needed? The recipient could just buffer the DTLS records until the KeyUpdate has been received.",
          "createdAt": "2021-07-12T09:54:50Z",
          "updatedAt": "2021-07-12T09:54:50Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > After sending the KeyUpdate message, it stops sending DTLS messages until\r\n> > the corresponding Ack message has been processed.\r\n> \r\n> Is this needed? The recipient could just buffer the DTLS records until the KeyUpdate has been received.\r\n\r\nHow do you make sure that all messages using an old epoch n - i have been processed by the receiving DTLS endpoint before you remove the keys for epoch n - i? I'm using i = 1 for DTLS 1.3, and i = 2 for DTLS 1.2.",
          "createdAt": "2021-07-12T10:03:44Z",
          "updatedAt": "2021-07-12T10:05:14Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I think we should fix the easy errors and then merge and create a new issue regarding DTLS 1.3 records handling in user message over key updates. ",
          "createdAt": "2021-07-12T14:03:54Z",
          "updatedAt": "2021-07-12T14:03:54Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think we should fix the easy errors and then merge and create a new issue regarding DTLS 1.3 records handling in user message over key updates.\r\n\r\nI agree.",
          "createdAt": "2021-07-12T14:14:45Z",
          "updatedAt": "2021-07-12T14:14:45Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I am fixing the reference and the roll over. Will commit soon. ",
          "createdAt": "2021-07-12T14:16:43Z",
          "updatedAt": "2021-07-12T14:16:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MTQzMjIz",
          "commit": {
            "abbreviatedOid": "a7d1dd2"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-07-12T13:56:39Z",
          "updatedAt": "2021-07-12T14:04:18Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "When we mentioning DTLS messages, we mean messages, not protection records? ",
              "createdAt": "2021-07-12T13:56:39Z",
              "updatedAt": "2021-07-12T14:04:18Z"
            },
            {
              "originalPosition": 83,
              "body": "Doesn't this need the in case of wrap, wrap to 1 not 0 text?",
              "createdAt": "2021-07-12T13:58:44Z",
              "updatedAt": "2021-07-12T14:04:18Z"
            },
            {
              "originalPosition": 47,
              "body": "Wrong reference, should point to a DTSL 1.3 spec section, not 1.2. ",
              "createdAt": "2021-07-12T13:59:19Z",
              "updatedAt": "2021-07-12T14:04:18Z"
            },
            {
              "originalPosition": 49,
              "body": "This implies draining of protection records. Couldn't we avoid this. ",
              "createdAt": "2021-07-12T14:01:49Z",
              "updatedAt": "2021-07-12T14:04:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MTcyOTcy",
          "commit": {
            "abbreviatedOid": "6248869"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "I think we can merge this, but will create a new issue that is more specific to the remaining aspect of DTLS epoch handling. ",
          "createdAt": "2021-07-12T14:21:26Z",
          "updatedAt": "2021-07-12T14:21:26Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MTc0MTI2",
          "commit": {
            "abbreviatedOid": "6248869"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-12T14:22:24Z",
          "updatedAt": "2021-07-12T14:22:24Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "For me a DTLS message consists of a DTLS record. In case of UDP. In case of UDP, you can put multiple DTLS records or DTLS messages in a single UDP packet. In case of SCTP you can put multiple DTLS messages in a single SCTP user message. This is what this document is about. RFC 6083 has a one-to-one relation between DTLS messages / DTLS records and SCTP user messages.\r\n\r\nAre you asking for a wording like `MUST ensure that all DATA chunks related to DTLS messages using the previous epoch have been`?",
              "createdAt": "2021-07-12T14:22:24Z",
              "updatedAt": "2021-07-12T14:22:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MTc1OTE3",
          "commit": {
            "abbreviatedOid": "6248869"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-12T14:23:50Z",
          "updatedAt": "2021-07-12T14:23:50Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "As far as I know the epoch can't wrap in DTLS 1.2 and DTLS 1.3 anymore. Since the epoch and the key id are both 16 bit, the key id can't wrap anymore. In DTLS 1.0 the epoch could wrap, therefore the key id.",
              "createdAt": "2021-07-12T14:23:50Z",
              "updatedAt": "2021-07-12T14:23:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MTgwMzQ0",
          "commit": {
            "abbreviatedOid": "6248869"
          },
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-12T14:27:29Z",
          "updatedAt": "2021-07-12T14:27:29Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Right now, I don't know now.",
              "createdAt": "2021-07-12T14:27:29Z",
              "updatedAt": "2021-07-12T14:27:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg3NTk5Nzgy",
      "title": "Don't consider the case with an adaptation layer indication provided as a fallback.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/56",
      "state": "MERGED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is intended to fix https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/issues/54",
      "createdAt": "2021-07-12T07:54:08Z",
      "updatedAt": "2021-07-12T12:59:32Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "a8a077e3a92ce40db29f364940c1c7a8f2f644a3",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "tuexen-issue-54",
      "headRefOid": "bc91ef713fdd46f9bb062dd48153d960c9f6d2ed",
      "closedAt": "2021-07-12T11:50:14Z",
      "mergedAt": "2021-07-12T11:50:14Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "2764c2b2f0b5ef41de68dd6fe7481500f7a34624"
      },
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me\r\n",
          "createdAt": "2021-07-12T10:33:13Z",
          "updatedAt": "2021-07-12T10:33:13Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Looks good to me\r\n\r\nShouldn't it provide the same behaviour for client and server side? Since I think so, I updated this PR. So @gloinul can approve or reject, if he wants asymmetric fallback behaviour.",
          "createdAt": "2021-07-12T10:51:41Z",
          "updatedAt": "2021-07-12T11:01:54Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I think symmetric and the simplification is a better point for any further changes if needed. I think the remaining questions is if we should say anything additionally on fallback requirement. But it appears that it is no necessary now. ",
          "createdAt": "2021-07-12T11:50:10Z",
          "updatedAt": "2021-07-12T11:50:10Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 57,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg3ODA5MzQz",
      "title": "Maybe this fixes the layout issues in the socket API section.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/57",
      "state": "MERGED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "@gloinul I really don't know the syntax we are using... Does this resolve the layout issues?",
      "createdAt": "2021-07-12T12:42:57Z",
      "updatedAt": "2021-07-12T12:59:30Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "2764c2b2f0b5ef41de68dd6fe7481500f7a34624",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "tuexen-layout",
      "headRefOid": "6f3a504b6f8dea16700465054b593dbd65ba8aa9",
      "closedAt": "2021-07-12T12:53:52Z",
      "mergedAt": "2021-07-12T12:53:52Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "e4f46e410bfcf6e88168f0476854ea4d2cf065ac"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Yes, this layout looks reasonable both in HTML and text. Will merge",
          "createdAt": "2021-07-12T12:53:47Z",
          "updatedAt": "2021-07-12T12:53:47Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Yes, this layout looks reasonable both in HTML and text. Will merge\r\n\r\nYepp, that looks how it was intended. Didn't know about the whitespace and `:` requirements. Thanks for testing and merging.",
          "createdAt": "2021-07-12T12:58:00Z",
          "updatedAt": "2021-07-12T12:58:00Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg3ODc3MDQz",
      "title": "Ordered / unordered is a message property not a stream property",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/58",
      "state": "MERGED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-12T14:05:53Z",
      "updatedAt": "2022-06-23T12:49:22Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "e4f46e410bfcf6e88168f0476854ea4d2cf065ac",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "tuexen-stream-0-usage",
      "headRefOid": "845e2b9211d7114bf4b914bd8c0c61f6047baa41",
      "closedAt": "2021-07-12T14:54:44Z",
      "mergedAt": "2021-07-12T14:54:44Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "d8d5b012d6b4de05e7ee2868de9627e0b487dce9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MjEyNTYz",
          "commit": {
            "abbreviatedOid": "845e2b9"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-12T14:54:40Z",
          "updatedAt": "2021-07-12T14:54:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg3ODk3NTY4",
      "title": "No wrap around possible.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/61",
      "state": "MERGED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In DTLS 1.2 and 1.3 the epoch can't wrap around anymore. Therefore the Shared Key ID can't either. Both are 16 bit entities.",
      "createdAt": "2021-07-12T14:29:21Z",
      "updatedAt": "2022-06-23T12:49:28Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "93996cf8443f086c81052dd299f6c197f79b0212",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "tuexen-fixes",
      "headRefOid": "61ee728f7b2af4faffbd0b6dd486be35e80e275c",
      "closedAt": "2021-07-12T14:57:04Z",
      "mergedAt": "2021-07-12T14:57:04Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "960c430c7fb86e6e09a4154eab3a3e6a72d7fba6"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Ok, do we need a note about this, if the number of rekeyings are limited to 65535 ones? ",
          "createdAt": "2021-07-12T14:49:38Z",
          "updatedAt": "2021-07-12T14:49:38Z"
        },
        {
          "author": "tuexen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Ok, do we need a note about this, if the number of rekeyings are limited to 65535 ones?\r\n\r\nI think we don't need to say this, since it is said in the DTLS specification. We removed earlier today other text with this argument.",
          "createdAt": "2021-07-12T15:04:53Z",
          "updatedAt": "2021-07-12T15:04:53Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 64,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg3OTk0ODU3",
      "title": "Explain limitations of DTLS 1.2 and DTLS 1.3",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/64",
      "state": "MERGED",
      "author": "tuexen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-12T16:35:25Z",
      "updatedAt": "2022-06-23T12:49:31Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "960c430c7fb86e6e09a4154eab3a3e6a72d7fba6",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "tuexen-issue-63",
      "headRefOid": "02d7bb4dac04a421000e9f7dbe1f6c398d968d0c",
      "closedAt": "2021-07-12T16:58:33Z",
      "mergedAt": "2021-07-12T16:58:33Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "4ebb26521b2ce1b7f28d50a3194f4dbd16b770da"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA0MzQyMDA4",
          "commit": {
            "abbreviatedOid": "02d7bb4"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-12T16:58:25Z",
          "updatedAt": "2021-07-12T16:58:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 66,
      "id": "PR_kwDOEtjg5s4rxEzN",
      "title": "Authentication",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/66",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The document is vary vague on authentication. The TLS spec unfortunatly give the idea it provides authentication. It does not. It provides proof of possesion of a key and provides information to enable the application to do authentication.\r\n",
      "createdAt": "2021-09-15T07:12:20Z",
      "updatedAt": "2022-06-23T12:49:32Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "51936766d64f8637e59fa896b18afdf77ab7e3ce",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Authentication",
      "headRefOid": "07f7c2d2d347a5d5eaf2b43fcace5260bec0207d",
      "closedAt": "2021-10-22T12:59:10Z",
      "mergedAt": "2021-10-22T12:59:10Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "27dc53342a7043bf1352efb2d4dfa5fd8e5e1da8"
      },
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "#67",
          "createdAt": "2021-09-15T07:12:44Z",
          "updatedAt": "2021-09-15T07:12:44Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s4u5dLd",
          "commit": {
            "abbreviatedOid": "07f7c2d"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "I think this can be merged.",
          "createdAt": "2021-10-22T12:58:19Z",
          "updatedAt": "2021-10-22T12:58:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 69,
      "id": "PR_kwDOEtjg5s4ti9BW",
      "title": "Parallel DTLS connections",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/69",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "A worked through implementation of parallel DTLS connections. ",
      "createdAt": "2021-10-22T12:07:28Z",
      "updatedAt": "2021-10-22T14:01:03Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "6479857d111665ca4e18a3785298e8ebfa840b38",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "parallel-connections",
      "headRefOid": "3017f59ae9f32b85ac3aac50f7dc2f544b5c20c6",
      "closedAt": "2021-10-22T12:11:02Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 70,
      "id": "PR_kwDOEtjg5s4ti-Ht",
      "title": "Added parallel DTLS connecitons",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/70",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This pull request is a proposal for how to resolve the known issues around rekeying for long lived SCTP associations. So that the either endpoint can intiate mutual re-authentication, and PFS rekeying.  ",
      "createdAt": "2021-10-22T12:13:22Z",
      "updatedAt": "2021-10-22T14:01:02Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "b97f18b64efc75e2a0e3d16b09c00e57a6bf9b7e",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "parallel-connections",
      "headRefOid": "3017f59ae9f32b85ac3aac50f7dc2f544b5c20c6",
      "closedAt": "2021-10-22T13:28:53Z",
      "mergedAt": "2021-10-22T13:28:53Z",
      "mergedBy": "teiclap",
      "mergeCommit": {
        "oid": "2d8e054b1cd4cb180341514ec8d9739e1b54c750"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 71,
      "id": "PR_kwDOEtjg5s4tjNsa",
      "title": "Removal of Michale T\u00fcexen as co-author on his request.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/71",
      "state": "CLOSED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-22T13:35:17Z",
      "updatedAt": "2021-10-22T13:42:23Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "2d8e054b1cd4cb180341514ec8d9739e1b54c750",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "author-remove",
      "headRefOid": "3550d44011bfcc3a8b3da70ad644887554841b1e",
      "closedAt": "2021-10-22T13:42:23Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 72,
      "id": "PR_kwDOEtjg5s4tltZP",
      "title": "John review of current document",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/72",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Added some terminology and abbreviations\r\n\r\n- Full handshake cannot be resumption.\r\n\r\n- Added DTLS 1.3 changes to Motivation for Changes\r\n\r\n- Some spell checking\r\n\r\n- Some inline references to RFC 7624",
      "createdAt": "2021-10-24T12:06:40Z",
      "updatedAt": "2022-06-23T12:49:35Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "e695f6ac4f82234a25e53b8208fc29a6d72fa93f",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "John-review-of-current-document",
      "headRefOid": "e74adbb8dd120d1bd3973eb33ef7da1105c07aeb",
      "closedAt": "2021-10-25T08:44:57Z",
      "mergedAt": "2021-10-25T08:44:57Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "cebc18f624aa4a53fa26eb82cb6385d479819025"
      },
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "- DTLS 1.3 is RECOMMENDED\r\n\r\n- DTLS Records can be 2^14 = 16384 bytes\r\n\r\n- Stated that authentication is the responsibility of the application using DTLS/SCTP\r\n\r\n- Rewrote the section on independence of DTLS version",
          "createdAt": "2021-10-24T12:10:23Z",
          "updatedAt": "2021-10-24T12:10:23Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The current text is unclear on when to derive new SCTP-AUTH keys. This might be caused by the fact that (in my understanding) a connection can have several connection IDs.\r\n\r\n\r\nMy reading of TLS 1.2 (RFC 5246) is that renegotiation does not create a new connection:\r\n\r\n\"      The client can also send a\r\n      ClientHello in response to a HelloRequest or on its own initiative\r\n      in order to renegotiate the security parameters in an existing\r\n      connection.\"\r\n\r\nBut RFC 5246 is not very clear, it actually just states that thing are done inside an existing connection without saying if the resulting connection is a new one or not.\r\n\r\nSeveral references on the internet (informal) seems to align with renegotiation not creating a new connection:\r\n\r\n  \"Thus instead of dropping and creating a new SSL connection, renegotiation adds authentication\r\n   details to the current connection\"\r\n  https://www.mcafee.com/blogs/enterprise/tips-securing-ssl-renegotiation/\r\n\r\n  \"proceed as though your application were creating a new connection.\"\r\n  https://docs.microsoft.com/en-us/windows/win32/secauthn/renegotiating-an-schannel-connection\r\n\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-tls-dtls-connection-id-13\r\n\r\n\r\n\r\ndraft-ietf-tls-dtls-connection-id-13 states that connection ID is negotiated afresh during renegotiation.\r\n\r\nWhen a DTLS session is resumed or\r\n   renegotiated, the \"connection_id\" extension is negotiated afresh.\r\n\r\n\r\nMy understanding would be that renegotiation does not create a new connection but that it may change the connection ID for the current connection. This is howerver just my understanding. TLS is not really clear what a connection is and what the difference between session and connection is.\r\n\r\n\r\nGiven my unserstanding the following to sentences are then contradicing each other\r\n\r\n\"There is also only a single SCTP-AUTH key exported per DTLS connection ensuring that there is clear mapping between the DTLS connection and the SCTP-AUTH security context for each key-id.\"\r\n\r\n\"Whenever the master secret changes, i.e., either due to DTLS Renegotiation or the establishment of a new DTLS connection, a 64-byte shared secret is derived from every master secret and provided as a new endpoint-pair shared secret by using the TLS-Exporter described in {{RFC5705}}.\"\r\n\r\nThe above could be fixed by changing to\r\n\r\n\"there is clear mapping between the DTLS connection ID and the SCTP-AUTH security context for each key-id.\"\r\n\r\nI did that\r\n\r\n\r\nI also added the following sentent, which I think is correct.\r\n\r\nConnection:  An DTLS connection. It is uniquely\r\nidentified by a connection identifier.\r\n",
          "createdAt": "2021-10-24T12:40:53Z",
          "updatedAt": "2021-10-24T12:40:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s4u9Tqm",
          "commit": {
            "abbreviatedOid": "e74adbb"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "The changes looks good. I will now merge these fixes. ",
          "createdAt": "2021-10-25T08:44:26Z",
          "updatedAt": "2021-10-25T08:44:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 74,
      "id": "PR_kwDOEtjg5s4tohUS",
      "title": "Removal of Renegotiations, general review. ",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/74",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-25T15:34:32Z",
      "updatedAt": "2021-10-25T18:42:47Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "73f36460260b757c75b704a3603a12a261e0c9cd",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "mw-edits",
      "headRefOid": "9c62deb894b0a74cc84dabdf924bdf3d5da503be",
      "closedAt": "2021-10-25T18:42:47Z",
      "mergedAt": "2021-10-25T18:42:47Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "b6150d378783de35f45983181b3fa077e4dfd519"
      },
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me.",
          "createdAt": "2021-10-25T15:54:07Z",
          "updatedAt": "2021-10-25T15:54:07Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 77,
      "id": "PR_kwDOEtjg5s4uhRTs",
      "title": "Remove the term Perfect Forward Secrecy (PFS)",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/77",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#75",
      "createdAt": "2021-11-15T09:30:55Z",
      "updatedAt": "2022-06-23T12:49:36Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "28fa16dce0fd0c8eda8450b07278fdf7d0cedf91",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Remove-the-term-Perfect-Forward-Secrecy-(PFS)",
      "headRefOid": "38719cb858d197c763533effd3c91afdc8de5211",
      "closedAt": "2021-11-19T10:33:55Z",
      "mergedAt": "2021-11-19T10:33:55Z",
      "mergedBy": "emanjon",
      "mergeCommit": {
        "oid": "c583aeff1f4335ed1d0ff8c4e67fb5fd177c0c19"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s4wCGrX",
          "commit": {
            "abbreviatedOid": "144c483"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "Looks good with this basic changes. I think we might want to consider if we need any expanded text somewhere that gives a more detailed description of the properties. ",
          "createdAt": "2021-11-15T10:03:53Z",
          "updatedAt": "2021-11-15T10:03:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s4wVzx_",
          "commit": {
            "abbreviatedOid": "9fbf115"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "I think this new changes are good to explain what is achieved. I think this can be merged. ",
          "createdAt": "2021-11-19T10:09:04Z",
          "updatedAt": "2021-11-19T10:09:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 83,
      "id": "PR_kwDOEtjg5s4xBOgl",
      "title": "Replaced rfc6347 with rfc9147",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/83",
      "state": "CLOSED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "rfc9147 (DTLS 1.3) has obsoleted rfc6347.\r\nI have simply replaced all rfc9147 occurrences in the text ",
      "createdAt": "2022-01-14T09:31:39Z",
      "updatedAt": "2022-06-23T12:49:38Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "e46cfbb605c85b27223cbb82472a8fda627c3bb3",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "rfc9147",
      "headRefOid": "208b3170fad2b06765733208cd20167f5577b48a",
      "closedAt": "2022-03-21T08:04:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "This PR needs to be updated. DTLS 1.3 will be RFC 9147 when published. DTLS 1.2 reference will stay RFC 6347. It is  I-D.ietf-tls-dtls-connection-id that will become RFC 9146 when published. And there are no point of merging this until the actual publication happens. RFC 9146 and RFC 9147 are still in AUTH48. ",
          "createdAt": "2022-01-14T10:56:02Z",
          "updatedAt": "2022-01-14T10:56:02Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So this pull request should now be ready for when RFC 9146 and RFC 9147 are ready to be published. However, as the references are not yet available processing fails. So this needs to be held until publication has occurred.",
          "createdAt": "2022-01-19T13:56:12Z",
          "updatedAt": "2022-01-19T13:56:12Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "RFC 9146 has been published now. I made a commit for that.\r\n\r\nRFC 9147 may take much more time. I think this can be closed for now.",
          "createdAt": "2022-03-21T08:04:52Z",
          "updatedAt": "2022-03-21T08:04:52Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 89,
      "id": "PR_kwDOEtjg5s4y-2RQ",
      "title": "Resumption #76",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/89",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Resumption #76\r\n\r\nSome more information and considerations regarding resumption and tickets. There was a lot of questions from developers regarding ticket and resumption in EAP-TLS 1.3 so it might be good to give some information.\r\n\r\nThis is not critical. It is just informational information. Please review. Could also be in some other part of the document.",
      "createdAt": "2022-02-17T10:52:29Z",
      "updatedAt": "2022-02-22T10:37:41Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "e46cfbb605c85b27223cbb82472a8fda627c3bb3",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Resumption-#76",
      "headRefOid": "e536c33d5a8ef6bb4194f227f20be0eb637ef074",
      "closedAt": "2022-02-22T10:37:36Z",
      "mergedAt": "2022-02-22T10:37:36Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "c4fdaeb92dcfe7b91a0613a5ab23500848f003f5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s41BHIu",
          "commit": {
            "abbreviatedOid": "e536c33"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-22T09:07:43Z",
          "updatedAt": "2022-02-22T09:07:43Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s41BjXD",
          "commit": {
            "abbreviatedOid": "e536c33"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-22T10:37:29Z",
          "updatedAt": "2022-02-22T10:37:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 90,
      "id": "PR_kwDOEtjg5s4y_Ftt",
      "title": "Fragmentation #82 #85",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/90",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fragmentation #82 #85\r\n\r\n- Added information on decryption and reassembly based on the comments and suggestion from Li Yan. This is very good information to have. I changed the suggested text a bit. I tried to use some sentences from the DTLS 1.3 draft. There is also not a single way to do this. Some things are up to the implementation. #82 \r\n\r\n- Removed the sentence that records are decrypted individually. This is up to the implementation. Might input the whole user_message' to DTLS. DTLS can handle sequences of concatenated records. #82 \r\n\r\n- Removed the comparision with DTLS handshake fragmentation based on a comment from Daria Ivanova. While there are similarities there are also a lot of differences. The comparision does not really help and likely just cause confusion. #85\r\n\r\n- Added Li Yan and Daria Ivanova to the Acknowledgments section",
      "createdAt": "2022-02-17T12:02:38Z",
      "updatedAt": "2022-02-22T10:38:11Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "e46cfbb605c85b27223cbb82472a8fda627c3bb3",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Fragmentation-#82-#85",
      "headRefOid": "81baf84368d401eab32a3391ebf240079ba14870",
      "closedAt": "2022-02-22T10:36:21Z",
      "mergedAt": "2022-02-22T10:36:21Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "6bfbc3c507b3f40694e4afdd1f3151a37777371d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s41BHjv",
          "commit": {
            "abbreviatedOid": "296026c"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-22T09:09:03Z",
          "updatedAt": "2022-02-22T09:09:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s41Bi9G",
          "commit": {
            "abbreviatedOid": "8f8801d"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-22T10:36:09Z",
          "updatedAt": "2022-02-22T10:36:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 91,
      "id": "PR_kwDOEtjg5s4zN-8Z",
      "title": "Text proposal to address #88.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/91",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-21T10:25:18Z",
      "updatedAt": "2022-02-22T10:39:20Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "e46cfbb605c85b27223cbb82472a8fda627c3bb3",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "initial-handshake-#88",
      "headRefOid": "2def93702574e2f482c067c4966938eae016aa55",
      "closedAt": "2022-02-22T10:39:16Z",
      "mergedAt": "2022-02-22T10:39:16Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "d1e43a947234d3a17e1fef95ed3593254368820b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s41BFIA",
          "commit": {
            "abbreviatedOid": "2def937"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Changes are fine for me",
          "createdAt": "2022-02-22T09:01:05Z",
          "updatedAt": "2022-02-22T09:01:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 92,
      "id": "PR_kwDOEtjg5s4zOJlD",
      "title": "Proposed clarification around the fact that DTLS/SCTP now is an adapt\u2026",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/92",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "\u2026ation layer and that is how we can enforce that all user messages are DTLS protected. In addition a note that implementation have to ensure that processing is happening in the right order if the DTLS endpoint is not immediately available on association establishment. This addresses issue #86.",
      "createdAt": "2022-02-21T11:11:25Z",
      "updatedAt": "2022-02-22T10:51:47Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "c6ae79525d3493a8b412778460a089cebabbfa30",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "adaptation-layer-#86",
      "headRefOid": "060abd77ef20fe5afc80b8e8abd84a7f442b3e96",
      "closedAt": "2022-02-22T10:51:41Z",
      "mergedAt": "2022-02-22T10:51:41Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "d05ec054407793c2f9d0867cce8acd4991c39fab"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s409lgC",
          "commit": {
            "abbreviatedOid": "0786f44"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-21T11:34:35Z",
          "updatedAt": "2022-02-21T11:34:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s41Bl9v",
          "commit": {
            "abbreviatedOid": "060abd7"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-22T10:46:18Z",
          "updatedAt": "2022-02-22T10:46:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 93,
      "id": "PR_kwDOEtjg5s4zRzA-",
      "title": "Proposal to address issue #84 on message size limitations.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/93",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-22T11:05:52Z",
      "updatedAt": "2022-06-23T12:50:04Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "a6cc7ac4cc66034fe69b3ffaae15181bcc6e9757",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Message-size-#84",
      "headRefOid": "1ffbaa4e8936fedcf621a17d360e1f258482f48f",
      "closedAt": "2022-03-07T10:53:23Z",
      "mergedAt": "2022-03-07T10:53:23Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "c2b5ef5d16460483da84eba59ef553bde909a62c"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I think I should further update this PR to deal also with the SCTP-AUTH API limitations that are discussed in #62. ",
          "createdAt": "2022-02-22T16:22:46Z",
          "updatedAt": "2022-02-22T16:22:46Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I have addressed the SCTP-AUTH API limitations on high level with no specific wording. ",
          "createdAt": "2022-02-28T16:48:01Z",
          "updatedAt": "2022-02-28T16:48:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s41CL-S",
          "commit": {
            "abbreviatedOid": "ef646a2"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-22T13:04:56Z",
          "updatedAt": "2022-02-22T13:04:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 94,
      "id": "PR_kwDOEtjg5s4zSGqO",
      "title": "Defined the shutdown procedure",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/94",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Detailed procedure for a graceful shutdown has been added",
      "createdAt": "2022-02-22T12:37:52Z",
      "updatedAt": "2022-06-23T12:49:45Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "a6cc7ac4cc66034fe69b3ffaae15181bcc6e9757",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue87",
      "headRefOid": "45331d6235bec64669f80f83b6b72bf5c2a9b567",
      "closedAt": "2022-03-07T10:42:29Z",
      "mergedAt": "2022-03-07T10:42:29Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "b5c555dbf0d1e9d08531eea79df2a21adbcac098"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "> Even if this details pretty well all the procedure, I think it's maybe overruling. It's just enough to mandate that in case of not fully completed shutdown procedure or in case that it's known that the DTLS library is not behaving properly with close_notify, the ULP should be informed that the Association has been aborted. It's up to the implementor to find a solution, furthermore I see that since data is being sent encrypted SCTP cannot detect a close_notify message by doing a packet inspection.\r\n\r\nSo, I added the exception case to figure out if it works. As you point out if the DTLS/SCTP can't intercept the close_notify then it can't hold it. Thus we end up in a situation where we do either of three things to make this interoperable.\r\n\r\nA. Mandate DTLS implementation that can stay in some type of closing state and process the close_notify but not terminate the DTLS connection state just yet.\r\n\r\nB. We instert the wait to send close_notify until all data has been drained and require API or tight integration that support that.\r\n\r\nC. We add an additional DTLS/SCTP level close signal that indicate to both side that we are going into shutdown preparation mode to block accepting more data and drain the queue. \r\n\r\nHowever, I don't see that we can't leave this for the implementations to figure out. Because that is going to lead to shutdown failures where data is lost.",
          "createdAt": "2022-02-23T12:53:34Z",
          "updatedAt": "2022-02-23T12:53:34Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I think this can be merged now. But please review my latest changes.",
          "createdAt": "2022-02-28T16:43:04Z",
          "updatedAt": "2022-02-28T16:43:04Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "> On point 2: it's better to give just one choice to the implementor. Let's decide for abort\r\n> In case a DTLS connection handshake is ongoing this needs to be\r\n> aborted at this step to ensure that the necessary...\r\n\r\nI guess that is fine, the main reason I made that open was that any way should work. But, I guess no one should rekey so late that they can't continue with the limited amount of data that they should have in DTLS/SCTP buffers which would require additional protection operations. ",
          "createdAt": "2022-03-07T08:30:49Z",
          "updatedAt": "2022-03-07T08:30:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s41CSb7",
          "commit": {
            "abbreviatedOid": "dac2ca0"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-02-22T13:26:15Z",
          "updatedAt": "2022-02-22T13:44:19Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I Think you should clarify that no new data from local instance of ULP will be accepted.",
              "createdAt": "2022-02-22T13:26:16Z",
              "updatedAt": "2022-02-22T13:44:19Z"
            },
            {
              "originalPosition": 5,
              "body": "Local ULP asks for terminating. ",
              "createdAt": "2022-02-22T13:26:37Z",
              "updatedAt": "2022-02-22T13:44:19Z"
            },
            {
              "originalPosition": 8,
              "body": "I thought this was what we wanted to avoid. As knowing when the criteria of it having been transferred to B is the API challenge we have. ",
              "createdAt": "2022-02-22T13:28:11Z",
              "updatedAt": "2022-02-22T13:44:19Z"
            },
            {
              "originalPosition": 7,
              "body": "Instead of flushes I would use something that makes it clears that DTLS/SCTP finish any protection operation on buffered user messages and ensures that all protected user message data has been accepted by SCTP for transmission, i.e. it needs to be in the tx_buffer. ",
              "createdAt": "2022-02-22T13:29:49Z",
              "updatedAt": "2022-02-22T13:44:19Z"
            },
            {
              "originalPosition": 9,
              "body": "To me this transmission can happen as soon 3 has completed and the data is in the SCTP tx_buffer?",
              "createdAt": "2022-02-22T13:31:33Z",
              "updatedAt": "2022-02-22T13:44:19Z"
            },
            {
              "originalPosition": 10,
              "body": "When receiving DTLS close_notify on the last **open** DTLS connection, remote DTLS/SCTP instance informs its ULP that remote shutdown has been initiated. No more ULP user message data can be accepted by DTLS/SCTP.  ",
              "createdAt": "2022-02-22T13:34:45Z",
              "updatedAt": "2022-02-22T13:44:19Z"
            },
            {
              "originalPosition": 11,
              "body": "Once more use clearer terms than flush. ",
              "createdAt": "2022-02-22T13:34:57Z",
              "updatedAt": "2022-02-22T13:44:19Z"
            },
            {
              "originalPosition": 12,
              "body": "Remove this phase.",
              "createdAt": "2022-02-22T13:35:15Z",
              "updatedAt": "2022-02-22T13:44:19Z"
            },
            {
              "originalPosition": 14,
              "body": "I would think that B can initiate shutdown and enter SCTP state shutdown-pending when it has commited all DTLS close notifies from 9 to its TX_buffers. A can request SCTP shutdown when it has received DTLS close_notify for all half-open DTLS connections. ",
              "createdAt": "2022-02-22T13:37:53Z",
              "updatedAt": "2022-02-22T13:44:19Z"
            },
            {
              "originalPosition": 15,
              "body": "Step 11. Both A an B: Accept any straggling data from peer that arrives during shutdown-pending state and perform de-protection and delvier to ULP. \r\nStep 12. When SCTP stack has completed shutdown then DTLS connection state can be removed. Indicate to ULP if shutdown was succesfull or ended in ABORT. In the later case some data may have been lost. \r\n\r\nI think Step 12 is acceptable because that in a graceful shutdown with SCTP the ULP most anyway either rely on comparable risk of shutdown failure, or have ULP level shutdown initiation to prevent ULP level data being partially transmitted. ",
              "createdAt": "2022-02-22T13:43:55Z",
              "updatedAt": "2022-02-22T13:44:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEtjg5s41DO-U",
          "commit": {
            "abbreviatedOid": "972e882"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "I think we are getting to a reasonable state. However, I think we should await some feedback on the DTLS issue before proceeding and let this proposal sink in a bit. ",
          "createdAt": "2022-02-22T16:20:35Z",
          "updatedAt": "2022-02-22T16:20:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s41DPIo",
          "commit": {
            "abbreviatedOid": "972e882"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-22T16:21:06Z",
          "updatedAt": "2022-02-22T16:21:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s41uvYJ",
          "commit": {
            "abbreviatedOid": "4ddf7e6"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "It looks fine to me",
          "createdAt": "2022-03-07T09:40:22Z",
          "updatedAt": "2022-03-07T09:40:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 95,
      "id": "PR_kwDOEtjg5s4zSKYv",
      "title": "Specified usage of PPID for internal DTLS signals",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/95",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Specified that DTLS/SCTP internal signals will use PPID=0 according to rfc4960 section 3.3.1",
      "createdAt": "2022-02-22T12:55:16Z",
      "updatedAt": "2022-02-22T13:46:58Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "a6cc7ac4cc66034fe69b3ffaae15181bcc6e9757",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue80",
      "headRefOid": "23ba1d8fae80c42e06b229e1a457b9d026dbb572",
      "closedAt": "2022-02-22T13:46:56Z",
      "mergedAt": "2022-02-22T13:46:56Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "118893c9c095b6e8eb6e42196ec5bc084d17ebd8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s41CMqE",
          "commit": {
            "abbreviatedOid": "23ba1d8"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-22T13:07:12Z",
          "updatedAt": "2022-02-22T13:07:12Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s41CYy2",
          "commit": {
            "abbreviatedOid": "23ba1d8"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-22T13:45:50Z",
          "updatedAt": "2022-02-22T13:45:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 96,
      "id": "PR_kwDOEtjg5s4z4hfq",
      "title": "Proposed text for addressing Stream Usage for DTLS messages in a bett\u2026",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/96",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "\u2026er way. Targeting to resolve issue #68.",
      "createdAt": "2022-03-03T10:48:57Z",
      "updatedAt": "2022-03-07T09:22:29Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "118893c9c095b6e8eb6e42196ec5bc084d17ebd8",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "stream-usage#68",
      "headRefOid": "6ff885dfa105c4bec7ca34ceb3bddd0339e21fec",
      "closedAt": "2022-03-04T17:21:45Z",
      "mergedAt": "2022-03-04T17:21:45Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "a75277cf45d048ba944f8d86b0068aa8bdeafb24"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s41qpSv",
          "commit": {
            "abbreviatedOid": "05c757c"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-04T15:31:48Z",
          "updatedAt": "2022-03-04T15:31:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s41uqSp",
          "commit": {
            "abbreviatedOid": "6ff885d"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Proposed change:\r\n\r\nA simple solution avoiding any protocol issue consists in  sending all DTLS\r\n   messages that are not protected user message fragments on own\r\n   stream that is not used by the ULP; those DTLS messages will be sent in their own\r\n   user messages with in order delivery. That mimics the RFC 6083\r\n   behavior without impacting the ULP\r\n",
          "createdAt": "2022-03-07T09:22:29Z",
          "updatedAt": "2022-03-07T09:22:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 97,
      "id": "PR_kwDOEtjg5s4z5SK2",
      "title": "Text proposal for clarified RFC 6083 fallback procedure.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/97",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This PR intended to resolved #81 ",
      "createdAt": "2022-03-03T14:34:14Z",
      "updatedAt": "2022-03-07T10:43:28Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "e371bdf8c0bfe8abe907dbf35014c3aecd59f585",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "fallback#81",
      "headRefOid": "c9ee24efca66c2f3a247d6f7ffd97b6036b6c779",
      "closedAt": "2022-03-07T10:43:25Z",
      "mergedAt": "2022-03-07T10:43:24Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "76659163906f6c9ba2ed0aeabab5c9037a600ac2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s41uIpV",
          "commit": {
            "abbreviatedOid": "c9ee24e"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-07T06:42:04Z",
          "updatedAt": "2022-03-07T06:42:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 98,
      "id": "PR_kwDOEtjg5s4z5e14",
      "title": "Correcting the parallel DTLS draining text.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/98",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Trying to resolve spec text errors found in discussion on issue #60 ",
      "createdAt": "2022-03-03T15:20:04Z",
      "updatedAt": "2022-03-07T11:10:07Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "e371bdf8c0bfe8abe907dbf35014c3aecd59f585",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "verifying-transmission#60",
      "headRefOid": "57c05110263729fd4afc6992c2218961f8a20fcf",
      "closedAt": "2022-03-07T11:08:59Z",
      "mergedAt": "2022-03-07T11:08:59Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "3e9357786d919cc6c6e17e233bae471c02a9b1d6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s41uI9A",
          "commit": {
            "abbreviatedOid": "1290250"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-07T06:44:18Z",
          "updatedAt": "2022-03-07T06:44:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 99,
      "id": "PR_kwDOEtjg5s4z-PL-",
      "title": "Stream usage bug fix",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/99",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "When updating the text on stream usage an important aspect was lost, namely that DTLS messages that are not ULP data needs to be sent reliably. ",
      "createdAt": "2022-03-04T19:37:00Z",
      "updatedAt": "2022-03-07T09:55:23Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "a75277cf45d048ba944f8d86b0068aa8bdeafb24",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "stream-usage#68",
      "headRefOid": "abe14071e5611b2e9d1b69555364f9f0adc0039b",
      "closedAt": "2022-03-07T09:47:20Z",
      "mergedAt": "2022-03-07T09:47:20Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "997da201b3ce6e3aa7120f9701475e30e63c0668"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s41ueqb",
          "commit": {
            "abbreviatedOid": "abe1407"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-07T08:38:41Z",
          "updatedAt": "2022-03-07T08:38:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s41uu9G",
          "commit": {
            "abbreviatedOid": "abe1407"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I'd change the text into \r\n\r\nThus, it is allowed to insert DTLS records of other types between protected user message fragments as the DTLS receiver will process them independently, thus not resulting in any user message data being inserted into the ULP's user message. \r\n\r\nHowever, DTLS messages of other types than protected user message MUST be sent in reliable mode , so the DTLS record can only be interleaved in case that also the ULP user message is sent in reliable mode.",
          "createdAt": "2022-03-07T09:38:50Z",
          "updatedAt": "2022-03-07T09:38:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 101,
      "id": "PR_kwDOEtjg5s4z-aNt",
      "title": "Api consideration#78",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/101",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Initial proposal for consideration to address issue #78 ",
      "createdAt": "2022-03-04T20:40:19Z",
      "updatedAt": "2022-03-07T11:09:32Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "da8767264e60f263674c82f22740152706e8fc53",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "api-consideration#78",
      "headRefOid": "afdda9d2c4eba7e824ef4ec49c980fae4971e0de",
      "closedAt": "2022-03-07T11:09:27Z",
      "mergedAt": "2022-03-07T11:09:26Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "5b78d438426a317b90ab6e9599295a15f6e783f5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s41uekH",
          "commit": {
            "abbreviatedOid": "58f371c"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-07T08:38:17Z",
          "updatedAt": "2022-03-07T08:38:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s41u0EJ",
          "commit": {
            "abbreviatedOid": "afdda9d"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-07T09:56:38Z",
          "updatedAt": "2022-03-07T09:56:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 102,
      "id": "PR_kwDOEtjg5s40B3rp",
      "title": "PPID does not matter for this DTLS/SCTP",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/102",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Minor issue with text due to that DTLS will always be used in SCTP association after establishment. Therefore PPID values being same does not matter. However, keep recommendation due to not diverge with RFC 6083.",
      "createdAt": "2022-03-07T09:45:38Z",
      "updatedAt": "2022-03-07T09:55:05Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "8382a889e0a64b8b5f1b8f0245810756cd5c8ed9",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "ppid-clarification",
      "headRefOid": "cd54ad845752d6706defece7ff4bffbe5a6630f8",
      "closedAt": "2022-03-07T09:55:02Z",
      "mergedAt": "2022-03-07T09:55:02Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "6e4db11e05f5f951f90a2116326752b22d8e4194"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s41uyd6",
          "commit": {
            "abbreviatedOid": "cd54ad8"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-07T09:51:03Z",
          "updatedAt": "2022-03-07T09:51:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 105,
      "id": "PR_kwDOEtjg5s40DBCx",
      "title": "Editorial changes from review",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/105",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-03-07T14:50:34Z",
      "updatedAt": "2022-03-07T20:17:03Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "5b78d438426a317b90ab6e9599295a15f6e783f5",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "mw-edits",
      "headRefOid": "d45ee4518608cf5ccd1d6235fd18bd51ff169b41",
      "closedAt": "2022-03-07T20:17:03Z",
      "mergedAt": "2022-03-07T20:17:03Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "b57f2f78abf213d4adf8b7feece07d3067ab9c01"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s41wL3Y",
          "commit": {
            "abbreviatedOid": "8bb2b35"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-07T15:09:39Z",
          "updatedAt": "2022-03-07T15:09:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 109,
      "id": "PR_kwDOEtjg5s42nJnW",
      "title": "Updating DTLS 1.3 Reference and remove Obsoletes",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/109",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-22T09:38:56Z",
      "updatedAt": "2022-04-22T10:16:25Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "dd833e82bfc4d3b90eb4716b8b44f54c6f6c752b",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "mw-edits",
      "headRefOid": "73a15fd93877aa13d09340906c6f5823552eb74b",
      "closedAt": "2022-04-22T10:16:25Z",
      "mergedAt": "2022-04-22T10:16:25Z",
      "mergedBy": "teiclap",
      "mergeCommit": {
        "oid": "0a007f749c1af85c4298f555d68c216d89b255ac"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 110,
      "id": "PR_kwDOEtjg5s42nPmK",
      "title": "Require non-zero CID values.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/110",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This resolves #108. ",
      "createdAt": "2022-04-22T09:55:58Z",
      "updatedAt": "2022-06-23T12:50:06Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "dd833e82bfc4d3b90eb4716b8b44f54c6f6c752b",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue-108",
      "headRefOid": "01a471ec95e436b215aef4386efbb58b9844e27f",
      "closedAt": "2022-04-22T10:17:41Z",
      "mergedAt": "2022-04-22T10:17:41Z",
      "mergedBy": "teiclap",
      "mergeCommit": {
        "oid": "a920e8a49cf3cdd5e3b70172d9918a8c3d8d79ee"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s44nYCn",
          "commit": {
            "abbreviatedOid": "01a471e"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-22T10:17:31Z",
          "updatedAt": "2022-04-22T10:17:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 112,
      "id": "PR_kwDOEtjg5s45isDW",
      "title": "Issue 103 controlled closing",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/112",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Proposal for how to handle the DTLS 1.2 and DTLS 1.3 difference in handling in #103.",
      "createdAt": "2022-06-13T07:58:38Z",
      "updatedAt": "2022-06-21T07:57:31Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "a920e8a49cf3cdd5e3b70172d9918a8c3d8d79ee",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue-103-controlled-closing",
      "headRefOid": "7fde0330fe758ebeeb47dc0dfa20214d8f0491b8",
      "closedAt": "2022-06-21T07:57:31Z",
      "mergedAt": "2022-06-21T07:57:31Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "7fde0330fe758ebeeb47dc0dfa20214d8f0491b8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s4710tx",
          "commit": {
            "abbreviatedOid": "7fde033"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "It works for me",
          "createdAt": "2022-06-13T08:29:27Z",
          "updatedAt": "2022-06-13T08:29:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 113,
      "id": "PR_kwDOEtjg5s45n9Zz",
      "title": "Some small updates",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/113",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- The final DTLS 1.3 only support 2^48 epochs\r\n- Integrity and replay are provided to more chunks than user messages.",
      "createdAt": "2022-06-14T11:01:09Z",
      "updatedAt": "2022-06-21T07:56:00Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "a920e8a49cf3cdd5e3b70172d9918a8c3d8d79ee",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Some-small-updates",
      "headRefOid": "082047a2d92f9ad4ab49790b7e225355e3683914",
      "closedAt": "2022-06-21T07:50:25Z",
      "mergedAt": "2022-06-21T07:50:25Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "54e5989bbb4b6bf4e9c60d825e004971e72665a8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s478U4g",
          "commit": {
            "abbreviatedOid": "6c7f49c"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "OK for me",
          "createdAt": "2022-06-14T11:09:57Z",
          "updatedAt": "2022-06-14T11:09:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s478YvD",
          "commit": {
            "abbreviatedOid": "6c7f49c"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-14T11:23:07Z",
          "updatedAt": "2022-06-14T11:23:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 114,
      "id": "PR_kwDOEtjg5s45ofL-",
      "title": "Issue 100 key usage",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/114",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "A build on onto the PR #112 mechanism to resolve Issue #100.  ",
      "createdAt": "2022-06-14T13:09:59Z",
      "updatedAt": "2022-06-21T07:57:33Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "a920e8a49cf3cdd5e3b70172d9918a8c3d8d79ee",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue-100-key-usage",
      "headRefOid": "56af1a6193dfa766a14d4d639464209852012a15",
      "closedAt": "2022-06-21T07:57:30Z",
      "mergedAt": "2022-06-21T07:57:29Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "cc509ba6c0720bcf7442e8c268832a9fdbe15226"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s47891z",
          "commit": {
            "abbreviatedOid": "1ade788"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-14T13:11:55Z",
          "updatedAt": "2022-06-14T13:11:55Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "delivered as early...",
              "createdAt": "2022-06-14T13:11:55Z",
              "updatedAt": "2022-06-14T13:11:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEtjg5s478-4q",
          "commit": {
            "abbreviatedOid": "1ade788"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-14T13:14:32Z",
          "updatedAt": "2022-06-14T13:14:33Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "...endpoint indicates to its...",
              "createdAt": "2022-06-14T13:14:32Z",
              "updatedAt": "2022-06-14T13:14:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEtjg5s479Aeb",
          "commit": {
            "abbreviatedOid": "1ade788"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-14T13:18:08Z",
          "updatedAt": "2022-06-14T13:18:09Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "RFC9260 ",
              "createdAt": "2022-06-14T13:18:08Z",
              "updatedAt": "2022-06-14T13:18:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEtjg5s479Al1",
          "commit": {
            "abbreviatedOid": "1ade788"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-14T13:18:25Z",
          "updatedAt": "2022-06-14T13:18:25Z",
          "comments": [
            {
              "originalPosition": 193,
              "body": "RFC9260",
              "createdAt": "2022-06-14T13:18:25Z",
              "updatedAt": "2022-06-14T13:18:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEtjg5s479BWe",
          "commit": {
            "abbreviatedOid": "1ade788"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I had a few comments, some typos and some replacements of rfc4960 with rfc9260.",
          "createdAt": "2022-06-14T13:20:10Z",
          "updatedAt": "2022-06-14T13:20:10Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s48BcRb",
          "commit": {
            "abbreviatedOid": "1ade788"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T07:39:17Z",
          "updatedAt": "2022-06-15T07:39:17Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "Lets do that change is a separate PR across the whole document.",
              "createdAt": "2022-06-15T07:39:17Z",
              "updatedAt": "2022-06-15T07:39:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEtjg5s48BcXD",
          "commit": {
            "abbreviatedOid": "1ade788"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T07:39:33Z",
          "updatedAt": "2022-06-15T07:39:33Z",
          "comments": [
            {
              "originalPosition": 193,
              "body": "Common change PR will be done. ",
              "createdAt": "2022-06-15T07:39:33Z",
              "updatedAt": "2022-06-15T07:39:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 115,
      "id": "PR_kwDOEtjg5s45o3eK",
      "title": "Removed Socket API section.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/115",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This PR removes the Socket API changes. As previously discussed these are not specific to this draft and would make more sense in an update of SCTP-AUTH. It was also missing the idea of the Drain a particular SCTP-AUTH key ID which would be useful. \r\n\r\nThis PR resolves #111 ",
      "createdAt": "2022-06-14T14:29:16Z",
      "updatedAt": "2022-06-21T07:57:18Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "a920e8a49cf3cdd5e3b70172d9918a8c3d8d79ee",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue-111",
      "headRefOid": "f2878409679a1c809cd36129915648ce2fab04fe",
      "closedAt": "2022-06-21T07:57:13Z",
      "mergedAt": "2022-06-21T07:57:13Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "24d8a0defc320efbc51c3ed904e57105f7deb104"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s479g8a",
          "commit": {
            "abbreviatedOid": "f287840"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-14T14:30:39Z",
          "updatedAt": "2022-06-14T14:30:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 117,
      "id": "PR_kwDOEtjg5s45s-Wh",
      "title": "Clarification on receiver buffers minimal vs needing larger to avoid \u2026",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/117",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "\u2026flow control issues. This may resolve #107 ",
      "createdAt": "2022-06-15T12:08:31Z",
      "updatedAt": "2022-06-21T07:56:55Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "a920e8a49cf3cdd5e3b70172d9918a8c3d8d79ee",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue-107-recv-buffers",
      "headRefOid": "223dcb441f60ad87631dba7c1d92dbcff173d773",
      "closedAt": "2022-06-21T07:56:51Z",
      "mergedAt": "2022-06-21T07:56:51Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "81329286274de45539d16d2c1c512b004adf3462"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s48C6G9",
          "commit": {
            "abbreviatedOid": "8e1a6bf"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T12:15:26Z",
          "updatedAt": "2022-06-15T12:15:27Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "stored in the receiver's buffer",
              "createdAt": "2022-06-15T12:15:26Z",
              "updatedAt": "2022-06-15T12:15:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEtjg5s48C6eU",
          "commit": {
            "abbreviatedOid": "8e1a6bf"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-15T12:16:35Z",
          "updatedAt": "2022-06-15T12:16:35Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "... needs to be",
              "createdAt": "2022-06-15T12:16:35Z",
              "updatedAt": "2022-06-15T12:16:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEtjg5s48C6nJ",
          "commit": {
            "abbreviatedOid": "8e1a6bf"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "A couple of minor typos.",
          "createdAt": "2022-06-15T12:17:00Z",
          "updatedAt": "2022-06-15T12:17:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 118,
      "id": "PR_kwDOEtjg5s46Ams-",
      "title": "Updated RFC4960 to RFC9260. Which will resolve issue #116.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/118",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This updates the references and resolves #116.",
      "createdAt": "2022-06-21T08:08:46Z",
      "updatedAt": "2022-06-21T08:09:09Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "cc509ba6c0720bcf7442e8c268832a9fdbe15226",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "references-116",
      "headRefOid": "f01dba4effa902608d7a02da59828c09fdc84232",
      "closedAt": "2022-06-21T08:09:06Z",
      "mergedAt": "2022-06-21T08:09:06Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "8df1720e6bf44cd915239eeb284c6a672e2700fd"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 119,
      "id": "PR_kwDOEtjg5s46BJ-F",
      "title": "DTLS versions",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/119",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#104",
      "createdAt": "2022-06-21T10:21:08Z",
      "updatedAt": "2022-06-21T12:00:38Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "5804ae47c59c02315a3643ee6403d297ea428e4c",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "DTLS-versions",
      "headRefOid": "c91f1e16695dfc0c2ac1c94bfe5122e2f7902cc0",
      "closedAt": "2022-06-21T12:00:38Z",
      "mergedAt": "2022-06-21T12:00:38Z",
      "mergedBy": "emanjon",
      "mergeCommit": {
        "oid": "7141b34b388fa82432cc5944e6b2c2bf64f1f09d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s48Z39Y",
          "commit": {
            "abbreviatedOid": "c91f1e1"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-21T11:16:02Z",
          "updatedAt": "2022-06-21T11:16:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 120,
      "id": "PR_kwDOEtjg5s46H-Z-",
      "title": "Epochs",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/120",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Suggest to delete the epoch section. It has several incorrect statements and does not seem to provide any value. The important things are already covered in other sections.",
      "createdAt": "2022-06-22T14:11:54Z",
      "updatedAt": "2022-06-22T15:26:33Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "77aaf65092282e212d4bab2f7b126f62b6673266",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Epochs",
      "headRefOid": "7da479b4a55d7961f84836d362d145c4f4485704",
      "closedAt": "2022-06-22T15:26:33Z",
      "mergedAt": "2022-06-22T15:26:32Z",
      "mergedBy": "emanjon",
      "mergeCommit": {
        "oid": "5e0a632f16510473ffd481e7cf7f602fed933e51"
      },
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "#106",
          "createdAt": "2022-06-22T14:37:41Z",
          "updatedAt": "2022-06-22T14:37:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s48g6oB",
          "commit": {
            "abbreviatedOid": "8ada7a8"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-22T14:13:06Z",
          "updatedAt": "2022-06-22T14:13:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 121,
      "id": "PR_kwDOEtjg5s46I65S",
      "title": "Mw edits",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/121",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "A number of edits to resolve inconsistencies or unclarities in reformulations. ",
      "createdAt": "2022-06-22T16:31:10Z",
      "updatedAt": "2022-06-23T07:11:01Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "5e0a632f16510473ffd481e7cf7f602fed933e51",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "mw-edits",
      "headRefOid": "b8f2b090b0f63acf05696075d9fd6ab4a7dab34d",
      "closedAt": "2022-06-23T07:10:57Z",
      "mergedAt": "2022-06-23T07:10:57Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "dd0406c86622959f98ebb27478808ed2e976714e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s48lUEK",
          "commit": {
            "abbreviatedOid": "bdbc4cb"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-23T05:41:27Z",
          "updatedAt": "2022-06-23T05:41:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s48lXDg",
          "commit": {
            "abbreviatedOid": "ab71556"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-23T05:59:08Z",
          "updatedAt": "2022-06-23T05:59:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 122,
      "id": "PR_kwDOEtjg5s46N_Bo",
      "title": "Addressing unclarity in RFC6458 API regarding message length.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/122",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-06-23T07:28:47Z",
      "updatedAt": "2022-06-23T11:20:40Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "dd0406c86622959f98ebb27478808ed2e976714e",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "api-limitation",
      "headRefOid": "aaacf9b4df3ddd89f4ee876b159c21c7c290371b",
      "closedAt": "2022-06-23T11:20:34Z",
      "mergedAt": "2022-06-23T11:20:34Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "0fced430331f909bd6d601f2f195e451c3b27189"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s48l8vW",
          "commit": {
            "abbreviatedOid": "aaacf9b"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-23T08:18:27Z",
          "updatedAt": "2022-06-23T08:18:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 157,
      "id": "PR_kwDOEtjg5s4-XLKh",
      "title": "Issue123",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/157",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Updating for text related to key update",
      "createdAt": "2022-09-05T11:47:52Z",
      "updatedAt": "2022-09-06T07:54:49Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "2d27a35866e96fcc9ee510a7e2d26ef759dacef4",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue123",
      "headRefOid": "8e0bb9fe4e069951d012f380f0018bb7673c5ed6",
      "closedAt": "2022-09-06T07:54:49Z",
      "mergedAt": "2022-09-06T07:54:49Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "375147928f7098538d0f81f4e10e192a612e1a6a"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Resolves #123 ",
          "createdAt": "2022-09-05T12:15:24Z",
          "updatedAt": "2022-09-05T12:15:24Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5BWSVK",
          "commit": {
            "abbreviatedOid": "8e0bb9f"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-05T12:14:49Z",
          "updatedAt": "2022-09-05T12:14:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 158,
      "id": "PR_kwDOEtjg5s4-XLVJ",
      "title": "Implemented changes in upcase according to issue 124",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/158",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixed the text for exponents",
      "createdAt": "2022-09-05T11:48:32Z",
      "updatedAt": "2022-09-05T12:50:48Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "2d27a35866e96fcc9ee510a7e2d26ef759dacef4",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue124",
      "headRefOid": "c870a7c41833020fae49d0caf5269249abba4a8b",
      "closedAt": "2022-09-05T12:50:38Z",
      "mergedAt": "2022-09-05T12:50:38Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "91193b624325a7df26a6106a421b210fd7557f7f"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Resolves #124 ",
          "createdAt": "2022-09-05T12:50:04Z",
          "updatedAt": "2022-09-05T12:50:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5BWdlS",
          "commit": {
            "abbreviatedOid": "c870a7c"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-05T12:50:09Z",
          "updatedAt": "2022-09-05T12:50:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 159,
      "id": "PR_kwDOEtjg5s4-XLiz",
      "title": "Added a description of semi-permanent term",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/159",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Describe the concept of semi-permanent",
      "createdAt": "2022-09-05T11:49:25Z",
      "updatedAt": "2022-09-05T13:30:44Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "2d27a35866e96fcc9ee510a7e2d26ef759dacef4",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue125",
      "headRefOid": "1714f0c0deaf7bc31ce92222439a30aac96b30fb",
      "closedAt": "2022-09-05T13:30:44Z",
      "mergedAt": "2022-09-05T13:30:44Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "3ff6d016238e6806e985ae30816f8ea2ea6d7547"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Resolves #125",
          "createdAt": "2022-09-05T13:30:35Z",
          "updatedAt": "2022-09-05T13:30:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5BWq2z",
          "commit": {
            "abbreviatedOid": "1714f0c"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-05T13:30:23Z",
          "updatedAt": "2022-09-05T13:30:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 160,
      "id": "PR_kwDOEtjg5s4-XLtw",
      "title": "Implemented comments as in issue 126 for abbreviations",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/160",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixed the syntax for lists",
      "createdAt": "2022-09-05T11:50:06Z",
      "updatedAt": "2022-09-05T13:29:46Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "2d27a35866e96fcc9ee510a7e2d26ef759dacef4",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue126",
      "headRefOid": "92eaf2eac5db85ecb79d0eef8e85e34996cfb878",
      "closedAt": "2022-09-05T13:29:46Z",
      "mergedAt": "2022-09-05T13:29:46Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "a6dbaccaed575292b79c65275e419a90b514b7a6"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Resolves #126 ",
          "createdAt": "2022-09-05T13:29:42Z",
          "updatedAt": "2022-09-05T13:29:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5BWqkC",
          "commit": {
            "abbreviatedOid": "92eaf2e"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-05T13:29:26Z",
          "updatedAt": "2022-09-05T13:29:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 161,
      "id": "PR_kwDOEtjg5s4-XL8A",
      "title": "Fixed all singular/plural and other english",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/161",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixed singular/plural in all the document and other minor sentences.",
      "createdAt": "2022-09-05T11:51:06Z",
      "updatedAt": "2022-09-06T08:00:23Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "375147928f7098538d0f81f4e10e192a612e1a6a",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue128",
      "headRefOid": "ab5ba04ae6ed60f88b44cf6e01f850edf7834f0b",
      "closedAt": "2022-09-06T08:00:10Z",
      "mergedAt": "2022-09-06T08:00:10Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "32cd370a595dcc87c31babd4ce053772519d6011"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So this should resolve a large number of the singular and plural issues that #128 notes. ",
          "createdAt": "2022-09-05T13:57:08Z",
          "updatedAt": "2022-09-05T13:57:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5BWy81",
          "commit": {
            "abbreviatedOid": "e00aee0"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "With the changes I committed I think this can be merged. ",
          "createdAt": "2022-09-05T13:54:47Z",
          "updatedAt": "2022-09-05T13:54:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 162,
      "id": "PR_kwDOEtjg5s4-XMHD",
      "title": "Clarified the meaning of DTLS ready",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/162",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixed the concept of endpoint ready",
      "createdAt": "2022-09-05T11:51:49Z",
      "updatedAt": "2022-09-06T07:54:12Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "2d27a35866e96fcc9ee510a7e2d26ef759dacef4",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue137",
      "headRefOid": "0a8474c591d35386fe1348eb2cb7a71a9294576e",
      "closedAt": "2022-09-06T07:54:12Z",
      "mergedAt": "2022-09-06T07:54:12Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "07a5a501af740b93ec0c3ac1dac7b4eee8933541"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Resolves #137 ",
          "createdAt": "2022-09-05T13:58:27Z",
          "updatedAt": "2022-09-05T13:58:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5BW0Lb",
          "commit": {
            "abbreviatedOid": "0a8474c"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-05T13:58:33Z",
          "updatedAt": "2022-09-05T13:58:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 163,
      "id": "PR_kwDOEtjg5s4-XMRA",
      "title": "Fixed acronym transposition (at least tried)",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/163",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixed Acronym transpositions",
      "createdAt": "2022-09-05T11:52:28Z",
      "updatedAt": "2022-09-06T07:53:29Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "2d27a35866e96fcc9ee510a7e2d26ef759dacef4",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue147",
      "headRefOid": "e4970d7deee10c2b2e683e1c7768a8cda324d247",
      "closedAt": "2022-09-06T07:53:29Z",
      "mergedAt": "2022-09-06T07:53:29Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "8edd459729fd585b62d8ecad078401abf34e6295"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Resolved #147 .",
          "createdAt": "2022-09-05T14:01:31Z",
          "updatedAt": "2022-09-05T14:01:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5BW1Ge",
          "commit": {
            "abbreviatedOid": "e4970d7"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "I tried searching in the source for other transpositions for DTLS and SCTP and didn't find any. ",
          "createdAt": "2022-09-05T14:01:18Z",
          "updatedAt": "2022-09-05T14:01:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 164,
      "id": "PR_kwDOEtjg5s4-XMsy",
      "title": "EC(DHE) -> (EC)DHE",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/164",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "EC(DHE) -> (EC)DHE",
      "createdAt": "2022-09-05T11:54:08Z",
      "updatedAt": "2022-09-05T12:03:56Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "2d27a35866e96fcc9ee510a7e2d26ef759dacef4",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue150",
      "headRefOid": "9dab80202ca6167400b25405ff760a353c4387f3",
      "closedAt": "2022-09-05T12:03:56Z",
      "mergedAt": "2022-09-05T12:03:56Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "1bdafdde06dfc6a5925215836761512fa5d0bf1c"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Resolves issue #150.",
          "createdAt": "2022-09-05T12:03:50Z",
          "updatedAt": "2022-09-05T12:03:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5BWOdc",
          "commit": {
            "abbreviatedOid": "9dab802"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-05T12:02:58Z",
          "updatedAt": "2022-09-05T12:02:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 165,
      "id": "PR_kwDOEtjg5s4-bm8y",
      "title": "#issue149 - created new label",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/165",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Created the new label EXPORTER-EXT-DTLS-OVER-SCTP",
      "createdAt": "2022-09-06T11:17:31Z",
      "updatedAt": "2022-10-07T08:10:40Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "32cd370a595dcc87c31babd4ce053772519d6011",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue149",
      "headRefOid": "f818499a9e34a94cac7a8ce821bdb206757edb3e",
      "closedAt": "2022-10-07T08:10:40Z",
      "mergedAt": "2022-10-07T08:10:40Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "de91eefa4b1961db39f614d577e30fd85cbeb2fd"
      },
      "comments": [
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "Changed to EXPORTER-DTLS-OVER-SCTP-EXT",
          "createdAt": "2022-09-06T12:46:48Z",
          "updatedAt": "2022-09-06T12:46:48Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So, I think this section needs to be improved to also indicate that this exporter is intended to be used by DTLS and I don't quite understand the criteria for Recommended. Also, the process for IESG approved docs, here needs to be understood. So I think we should send an email to the experts list and ask. \r\n\r\nI also think there are some benefit to make it clearer what is expected to be added to the IANA registry, so if one can make a table with the values to add I think it would be clearer.\r\n\r\nI would also recommend that the reference is updated to include also RFC 8447. ",
          "createdAt": "2022-09-12T13:55:44Z",
          "updatedAt": "2022-09-12T13:55:44Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So this is intended to resolve #149. ",
          "createdAt": "2022-09-19T11:15:43Z",
          "updatedAt": "2022-09-19T11:15:43Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "- I added a table to align with the other IANA registrations.\r\n- I added DTLS-OK = Y\r\n- I added Recommended = Y (requires standards action)",
          "createdAt": "2022-10-05T11:17:58Z",
          "updatedAt": "2022-10-05T11:17:58Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "The text in the three IANA subsection 8.1, 8.2, and 8.3 are quite different even if they all register a new value in an existing register. It would make sense to align them and more or less use the same text in all of them. This migth be a new issue.",
          "createdAt": "2022-10-05T11:22:49Z",
          "updatedAt": "2022-10-05T11:22:49Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I will merge this update and create an new issue for the editorial work to stylistic align the IANA Sections. ",
          "createdAt": "2022-10-07T08:10:36Z",
          "updatedAt": "2022-10-07T08:10:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5Baeg3",
          "commit": {
            "abbreviatedOid": "1f01230"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "I wonder if the label should be \"EXPORTER-DTLS-OVER-SCTP-EXT\" instead?",
          "createdAt": "2022-09-06T12:06:13Z",
          "updatedAt": "2022-09-06T12:06:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5DmLqh",
          "commit": {
            "abbreviatedOid": "f818499"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-07T08:09:54Z",
          "updatedAt": "2022-10-07T08:09:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 166,
      "id": "PR_kwDOEtjg5s4-bx8u",
      "title": "Initial version of text to address issue #127.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/166",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Initial text for protocol overview to help people better understand later parts. Solves #127 ",
      "createdAt": "2022-09-06T12:03:28Z",
      "updatedAt": "2022-10-07T08:22:59Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "32cd370a595dcc87c31babd4ce053772519d6011",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue127",
      "headRefOid": "3f56d07abc35cc60761d6c43211d3f1339635ec1",
      "closedAt": "2022-09-07T09:23:34Z",
      "mergedAt": "2022-09-07T09:23:34Z",
      "mergedBy": "teiclap",
      "mergeCommit": {
        "oid": "519748fe07614ad6655b5340c31a1ba7913a80ff"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5Baovh",
          "commit": {
            "abbreviatedOid": "2ff440d"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I have some minor changes to add, I'm fixing it right now.",
          "createdAt": "2022-09-06T12:32:24Z",
          "updatedAt": "2022-09-06T12:32:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5Bar7P",
          "commit": {
            "abbreviatedOid": "3f56d07"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This is my contribution, please check.",
          "createdAt": "2022-09-06T12:41:12Z",
          "updatedAt": "2022-09-06T12:41:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 167,
      "id": "PR_kwDOEtjg5s4-gs7M",
      "title": "issue130 - added reference to rfc8449",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/167",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#issue130 - reference to rfc8449 and related text",
      "createdAt": "2022-09-07T13:22:22Z",
      "updatedAt": "2022-10-07T08:12:07Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "519748fe07614ad6655b5340c31a1ba7913a80ff",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue130",
      "headRefOid": "3cf6aa5d15bcfb043ad39461d9869b42712c10e8",
      "closedAt": "2022-10-07T08:11:59Z",
      "mergedAt": "2022-10-07T08:11:59Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "a4ddb1752af72ba2c6f3f2010d3e782aba400920"
      },
      "comments": [
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "#130 - text has been fixed",
          "createdAt": "2022-09-08T08:30:04Z",
          "updatedAt": "2022-09-08T08:30:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5Cxo6d",
          "commit": {
            "abbreviatedOid": "3cf6aa5"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-26T14:12:34Z",
          "updatedAt": "2022-09-26T14:12:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5DbeXZ",
          "commit": {
            "abbreviatedOid": "3cf6aa5"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-05T11:26:37Z",
          "updatedAt": "2022-10-05T11:26:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 168,
      "id": "PR_kwDOEtjg5s4-gwOy",
      "title": "issue132 - text updated for considering DTLS implementation",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/168",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#issue132 - Updated with considerations towards record size limits due to DTLS implementation",
      "createdAt": "2022-09-07T13:33:25Z",
      "updatedAt": "2022-10-10T09:04:42Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "42a34432b3d9b00dec58d74e5a73b414e26f3037",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue132",
      "headRefOid": "7fdcbf5a372199bebbb360306d4517907b3f6682",
      "closedAt": "2022-10-10T09:00:29Z",
      "mergedAt": "2022-10-10T09:00:29Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "f74cb642b9e3b9a9307d46c4e88cf2972b82d2ff"
      },
      "comments": [
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "Text has been aligned with #130, the relationship between DTLS maximum record size and rfc8449 has been clarified.",
          "createdAt": "2022-09-08T11:09:56Z",
          "updatedAt": "2022-09-08T11:09:56Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Realise that this text is in the introduction section and the text is to provide an overview. Thus, the text should be reformulated to not use RFC 2119 language and instead rather be informative that implementation that support RFC 8449 can negotiate reduced sized DTLS records that allows reducing buffering. I am uncertain if it might also provide improved interoperability with any implementation that has limited sized DTLS records?",
          "createdAt": "2022-09-13T13:17:41Z",
          "updatedAt": "2022-09-13T13:17:41Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "I see, on the other hand where in the document should we place the normative part?\r\nI suggest to move it in \"Message Sizes\" section and fix the introduction text",
          "createdAt": "2022-09-13T13:42:39Z",
          "updatedAt": "2022-09-13T13:42:39Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "With the introduction changes that are overlapping with this PR in #169. I would suggest that the normative text part is moved into that PR and this abandoned to avoid having to deal with overlapping text changes. ",
          "createdAt": "2022-09-14T10:05:48Z",
          "updatedAt": "2022-09-14T10:05:48Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems to be very much overlap with #167 ",
          "createdAt": "2022-10-05T11:36:55Z",
          "updatedAt": "2022-10-05T11:36:55Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "Resolved the conflict, ready for merging.",
          "createdAt": "2022-10-10T06:39:54Z",
          "updatedAt": "2022-10-10T06:39:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5B0RR2",
          "commit": {
            "abbreviatedOid": "6f6ad13"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "This text appears to be duplicating the change in #167? ",
          "createdAt": "2022-09-12T14:13:55Z",
          "updatedAt": "2022-09-12T14:14:54Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "do you mean lesser maximum sizes due to implementation choice. ",
              "createdAt": "2022-09-12T14:13:55Z",
              "updatedAt": "2022-09-12T14:14:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEtjg5s5DbgKf",
          "commit": {
            "abbreviatedOid": "53c12c3"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-05T11:33:49Z",
          "updatedAt": "2022-10-05T11:33:50Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Martin wrote:\r\n\r\n\"you might find that things fail if you **handshake** with 214 bytes in a record.\"\r\n\r\nShould the requirement be general or should it only be for application data?\r\n\r\n",
              "createdAt": "2022-10-05T11:33:49Z",
              "updatedAt": "2022-10-05T11:33:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEtjg5s5DmLLJ",
          "commit": {
            "abbreviatedOid": "53c12c3"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-07T08:08:19Z",
          "updatedAt": "2022-10-07T08:08:20Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "It was intended for application data, not to apply to other DTLS messages like handshake etc. ",
              "createdAt": "2022-10-07T08:08:19Z",
              "updatedAt": "2022-10-07T08:08:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEtjg5s5DsSpt",
          "commit": {
            "abbreviatedOid": "7fdcbf5"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-10T09:00:14Z",
          "updatedAt": "2022-10-10T09:00:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 169,
      "id": "PR_kwDOEtjg5s4-7jbz",
      "title": "Buffering, DTLS record sequence numbers wraps and transmission limitations ",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/169",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "So this is a larger change that attempts to address issues:\r\n #131, #133, #134, #135, and #136 as well as impacts #132. \r\n \r\n- So a new sub-section in Introduction is added regarding buffering and flow control in general.\r\n- New DTLS sections regarding normative text for connection IDs that was moved from elsewhere. \r\n- New section on transmission limitations due to implementation and APIs. \r\n- Moved text around regarding processing and messages lengths. ",
      "createdAt": "2022-09-14T10:04:07Z",
      "updatedAt": "2022-10-07T08:13:25Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "b4be74409931bccfcd11e566e31cbbe6ca4904f4",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue135",
      "headRefOid": "efd65a2cd45535125ce3691fe183bdda64412d2e",
      "closedAt": "2022-10-07T08:13:15Z",
      "mergedAt": "2022-10-07T08:13:15Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "751afadf37c8b872e2a5098f1b34de25d8ab0d0c"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "This PR is not yet ready, especially the transmit limitations needs to be completed and decision made in regards to PR #168.\r\n",
          "createdAt": "2022-09-14T10:06:49Z",
          "updatedAt": "2022-09-14T10:06:49Z"
        },
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "We may completely drop issue132 due to the explanation given in this PR.",
          "createdAt": "2022-09-14T11:26:45Z",
          "updatedAt": "2022-09-14T11:26:45Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5B__yc",
          "commit": {
            "abbreviatedOid": "8f2ac88"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-14T11:26:09Z",
          "updatedAt": "2022-09-14T11:26:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 170,
      "id": "PR_kwDOEtjg5s4_Mpny",
      "title": "Issue #145 Solved conflict in Ready To Close race condition.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/170",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-19T13:01:20Z",
      "updatedAt": "2022-10-07T08:16:51Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "519748fe07614ad6655b5340c31a1ba7913a80ff",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue145",
      "headRefOid": "74eb1d5d340fb6a1af6560aaa9626ed325c22d57",
      "closedAt": "2022-10-07T08:16:48Z",
      "mergedAt": "2022-10-07T08:16:48Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "1047e1d1d9c487b81a8497cf0a8e48b17b031bd7"
      },
      "comments": [
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "I did some clarification on the message, please check.",
          "createdAt": "2022-09-20T06:11:31Z",
          "updatedAt": "2022-09-20T06:11:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5CTeaX",
          "commit": {
            "abbreviatedOid": "8747945"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "So I think we need a bit more text on the DTLS Connection ID and its handling. So formally the connection ID can be 0 to 255 bytes long. The expected length in this application is a single byte, but possibly two. Thus, there is some need to discuss how one handle the DTLS connection ID in case it is either shorter than 32-bits, i.e. pad the more significant bit with 0, or if longer than 4 bytes, just include the lower 4-bytes of the CID. ",
          "createdAt": "2022-09-19T14:51:46Z",
          "updatedAt": "2022-09-19T14:51:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5CWwIl",
          "commit": {
            "abbreviatedOid": "74eb1d5"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "That will work and avoid any truncation issue if someone uses really strange long CIDs.",
          "createdAt": "2022-09-20T07:14:09Z",
          "updatedAt": "2022-09-20T07:14:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 171,
      "id": "PR_kwDOEtjg5s4_Mpzg",
      "title": "Issue #153 Improved the denial-of-service protection description in Section 9.11",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/171",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-19T13:01:57Z",
      "updatedAt": "2022-10-07T08:15:35Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "519748fe07614ad6655b5340c31a1ba7913a80ff",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue153",
      "headRefOid": "bb1d7f5ddd7063e9c39434a13ef466787093cf3e",
      "closedAt": "2022-10-07T08:15:24Z",
      "mergedAt": "2022-10-07T08:15:24Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "61a48284670892b9c4cd0cbf89485e0f51cbdd5f"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Resolves #153 ",
          "createdAt": "2022-09-27T09:04:59Z",
          "updatedAt": "2022-09-27T09:04:59Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Also, I wonder if we now need to also discuss the other DOS angle this limitation do provide. If one refuses to close a DTLS connection the other endpoint will eventually run out of keying material and have to close the SCTP association. Nothing to do about it but maybe worth mentioning. It is denying the service, but it is not consuming a lot of extra resources like the case of churning through DTLS connection can.\r\n",
          "createdAt": "2022-09-27T09:06:54Z",
          "updatedAt": "2022-09-27T09:06:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5CTfUV",
          "commit": {
            "abbreviatedOid": "9fd1616"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "A bit thin, but I guess it hints enough, but could also be clear that an endpoint that thinks the peer turns over the DTLS Connections to fast can simply wait before closing it. ",
          "createdAt": "2022-09-19T14:54:06Z",
          "updatedAt": "2022-09-19T14:54:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 172,
      "id": "PR_kwDOEtjg5s4_Mp53",
      "title": "Issue #154 Clarified the mutual auth requirement for DTLS",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/172",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-19T13:02:16Z",
      "updatedAt": "2022-09-26T13:43:07Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "519748fe07614ad6655b5340c31a1ba7913a80ff",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue154",
      "headRefOid": "030e9764e1b48263ece66c802c737566bab334c1",
      "closedAt": "2022-09-26T13:43:01Z",
      "mergedAt": "2022-09-26T13:43:01Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "b4be74409931bccfcd11e566e31cbbe6ca4904f4"
      },
      "comments": [
        {
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "body": "Changed into \"Authentication\"",
          "createdAt": "2022-09-20T06:26:36Z",
          "updatedAt": "2022-09-20T06:26:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5CTgn9",
          "commit": {
            "abbreviatedOid": "3153bfb"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "I think the title of the section should likely be \"Authentication\". The reason is that also like the section before on Cipher suits are something that is determined during handshake. Thus, the section is much wider than what is actually written in it.",
          "createdAt": "2022-09-19T14:57:13Z",
          "updatedAt": "2022-09-19T14:57:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5CxcU2",
          "commit": {
            "abbreviatedOid": "030e976"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-26T13:42:50Z",
          "updatedAt": "2022-09-26T13:42:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 173,
      "id": "PR_kwDOEtjg5s4_rVjo",
      "title": "Fixed issue #142 related to DTLS version mix",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/173",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-09-27T09:19:09Z",
      "updatedAt": "2022-10-10T09:04:03Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "b4be74409931bccfcd11e566e31cbbe6ca4904f4",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue142",
      "headRefOid": "73c94ce2f33ee29a214e6d4bd998711bacb2f1ab",
      "closedAt": "2022-10-07T08:22:20Z",
      "mergedAt": "2022-10-07T08:22:20Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "42a34432b3d9b00dec58d74e5a73b414e26f3037"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Addresses #142.",
          "createdAt": "2022-09-27T10:43:22Z",
          "updatedAt": "2022-09-27T10:43:22Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5C3F2t",
          "commit": {
            "abbreviatedOid": "73c94ce"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-27T10:42:37Z",
          "updatedAt": "2022-09-27T10:42:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 174,
      "id": "PR_kwDOEtjg5s4_sRjO",
      "title": "Moved DTLS Renegotation and Key-Update section to DTLS consideration \u2026",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/174",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "\u2026section as the main conclusion is to not use them and thus not impact the DTLS/SCTP implementation.\r\n\r\nIntended to resolve #143 ",
      "createdAt": "2022-09-27T12:43:13Z",
      "updatedAt": "2022-10-10T09:01:40Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "42a34432b3d9b00dec58d74e5a73b414e26f3037",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue143",
      "headRefOid": "cccd409d2ca28ee4185ab2a018c08fa1a3908d2b",
      "closedAt": "2022-10-10T09:01:35Z",
      "mergedAt": "2022-10-10T09:01:35Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "d246a32089841326591f55d21a300021225639c6"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Yes, that would be one potential. What the current text says is basically if you are going to do a key-update you need to drain your queue first. Thus, there are any need for an integration between the DTLS stack and the DTLS/SCTP layer here. Thus, it might be simpler to assume that one can simply turn of the key-update feature and instead trigger a parallel DTLS rekeying instead. \r\n\r\nBut I would note that they are compatible, but using keyUpdate with draining is just not getting the advantage that parallel provides. But, it may not be obvious.",
          "createdAt": "2022-09-28T08:15:04Z",
          "updatedAt": "2022-09-28T08:16:11Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "So I have now implemented no keyUpdate usage in this PR. @teiclap and @emanjon please review. ",
          "createdAt": "2022-10-07T12:47:05Z",
          "updatedAt": "2022-10-07T12:47:05Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5C8E8D",
          "commit": {
            "abbreviatedOid": "4340b41"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "In my opinion the sentence in ##Renegotiation and Key Update\r\n\"   This specification also recommends against using DTLS 1.3 KeyUpdate\r\n   and instead rely on parallel DTLS connections. \"\r\nand\r\n\"Before sending a KeyUpdate message, the DTLS endpoint MUST ensure...\"\r\nin ### DTLS 1.3 Consideration \r\nmay be seen as contradictory.\r\nWe should state that we MUST not use DTLS 1.3 KeyUpdate instead.\r\n\r\n",
          "createdAt": "2022-09-28T05:41:17Z",
          "updatedAt": "2022-09-28T05:41:17Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5DngDf",
          "commit": {
            "abbreviatedOid": "cccd409"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-07T12:48:37Z",
          "updatedAt": "2022-10-07T12:48:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5DryhQ",
          "commit": {
            "abbreviatedOid": "cccd409"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-10T07:07:09Z",
          "updatedAt": "2022-10-10T07:07:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 175,
      "id": "PR_kwDOEtjg5s4_sem4",
      "title": "Initial text proposal for indicating potential preference for hashing\u2026",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/175",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "\u2026 algorithms that are supported both in SCTP-AUTH and DTLS.\r\n\r\nResolves #140 ",
      "createdAt": "2022-09-27T13:23:18Z",
      "updatedAt": "2022-10-07T08:05:13Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "b4be74409931bccfcd11e566e31cbbe6ca4904f4",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue140",
      "headRefOid": "3592573c67fbaab25a0eec6ee49249794b3fdda5",
      "closedAt": "2022-10-07T08:05:09Z",
      "mergedAt": "2022-10-07T08:05:08Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "ca3ba7dcf9e15e8ff86ed33c8e08affdd763023f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5C8FaO",
          "commit": {
            "abbreviatedOid": "3592573"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-28T05:44:08Z",
          "updatedAt": "2022-09-28T05:44:08Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5DcTgO",
          "commit": {
            "abbreviatedOid": "3592573"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-05T14:06:06Z",
          "updatedAt": "2022-10-05T14:06:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 177,
      "id": "PR_kwDOEtjg5s5ADODy",
      "title": "Issue #146 - clarified the roles for DTLS/SCTP",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/177",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Added some text and removed the DTLS cases.",
      "createdAt": "2022-10-03T12:13:19Z",
      "updatedAt": "2022-10-10T09:02:06Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "b4be74409931bccfcd11e566e31cbbe6ca4904f4",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue146",
      "headRefOid": "737296ab0f4d0e6dcdca64c8ca32ddb56b8aff3e",
      "closedAt": "2022-10-10T09:02:03Z",
      "mergedAt": "2022-10-10T09:02:03Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "35e911623df4fe8df58499d31d8c17a1518890af"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5DcSsd",
          "commit": {
            "abbreviatedOid": "55bb0c6"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-05T14:04:03Z",
          "updatedAt": "2022-10-05T14:04:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5DoBDQ",
          "commit": {
            "abbreviatedOid": "737296a"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-07T14:16:01Z",
          "updatedAt": "2022-10-07T14:16:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5DryUQ",
          "commit": {
            "abbreviatedOid": "737296a"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-10T07:06:13Z",
          "updatedAt": "2022-10-10T07:06:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 179,
      "id": "PR_kwDOEtjg5s5AeSUv",
      "title": "Issue #151 - Resumption performance",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/179",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#151",
      "createdAt": "2022-10-10T08:05:53Z",
      "updatedAt": "2022-10-12T14:48:08Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "42a34432b3d9b00dec58d74e5a73b414e26f3037",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Issue-#151---Resumption-performance",
      "headRefOid": "5dbb6c162714646d7513fbe7208ddc919475ce23",
      "closedAt": "2022-10-12T14:48:07Z",
      "mergedAt": "2022-10-12T14:48:07Z",
      "mergedBy": "emanjon",
      "mergeCommit": {
        "oid": "c775824db08f501814c00cd74c512e75016bd752"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5DsCsT",
          "commit": {
            "abbreviatedOid": "5dbb6c1"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-10T08:07:18Z",
          "updatedAt": "2022-10-10T08:07:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 180,
      "id": "PR_kwDOEtjg5s5Ai--l",
      "title": " Issue #148 - Define how the SCTP-AUTH keys are derived",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/180",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- MUST use the same HMAC Identifier in all AUTH chunks during the SCTP association.\r\n- Spelled out \"endpoint pair shared secret\" to differentiate from \"association shared secret\"\r\n- Changed that Shared Key Identifier 0 is not used instead of that the key is removed (there is not really any key stored)\r\n- Made all the input to the TLS exporter more explicit in a single place.\r\n- Moved DTLS 1.2 specific things to \"DTLS 1.2 Considerations\". Similar stuff for DTLS 1.3 is TDB\r\n- Editorial changes.\r\n\r\n#148",
      "createdAt": "2022-10-11T08:00:23Z",
      "updatedAt": "2022-10-13T05:24:14Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "35e911623df4fe8df58499d31d8c17a1518890af",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Issue-#148---Define-how-the-SCTP-AUTH-keys-are-derived",
      "headRefOid": "afc4ffbe9a198203c6f8e63b9fb49dbeae97d589",
      "closedAt": "2022-10-13T05:24:14Z",
      "mergedAt": "2022-10-13T05:24:14Z",
      "mergedBy": "emanjon",
      "mergeCommit": {
        "oid": "e4438e26a04b7db539a8a365b686bac4d4665a73"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5D89VU",
          "commit": {
            "abbreviatedOid": "c06315b"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-13T05:01:38Z",
          "updatedAt": "2022-10-13T05:01:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5D8-Ab",
          "commit": {
            "abbreviatedOid": "c06315b"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-13T05:06:29Z",
          "updatedAt": "2022-10-13T05:06:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 181,
      "id": "PR_kwDOEtjg5s5AmeXk",
      "title": "Issue #156 - Authenticating fallback to RFC 6083",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/181",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR likely needs some more work like changes and additions in other sections",
      "createdAt": "2022-10-11T20:59:07Z",
      "updatedAt": "2022-10-18T05:18:02Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "35e911623df4fe8df58499d31d8c17a1518890af",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Issue-#156---Authenticating-fallback-to-RFC-6083",
      "headRefOid": "4222e8fb8357efbbad38b78a9f3556121ad387dd",
      "closedAt": "2022-10-18T05:18:02Z",
      "mergedAt": "2022-10-18T05:18:02Z",
      "mergedBy": "emanjon",
      "mergeCommit": {
        "oid": "36dbaadcabc30b46dc214e824fa754342f7bc31f"
      },
      "comments": [
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "Needs to add IANA section and update the RFC 6083 fallback section before this is ready. ",
          "createdAt": "2022-10-13T08:39:02Z",
          "updatedAt": "2022-10-13T08:39:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5D8-Ru",
          "commit": {
            "abbreviatedOid": "16145b8"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-13T05:08:21Z",
          "updatedAt": "2022-10-13T05:08:21Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5ENh8t",
          "commit": {
            "abbreviatedOid": "4222e8f"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-17T15:36:15Z",
          "updatedAt": "2022-10-17T15:36:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 185,
      "id": "PR_kwDOEtjg5s5AtYrB",
      "title": " Issue #183 - Address new vulnerabilities found in SCTP-AUTH",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/185",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "First commit of several to this PR",
      "createdAt": "2022-10-13T07:28:34Z",
      "updatedAt": "2022-10-20T12:39:10Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "e4438e26a04b7db539a8a365b686bac4d4665a73",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Issue-#183---Address-new-vulnerabilities-found-in-SCTP-AUTH",
      "headRefOid": "3315b7b5fc7415d34a932910be4bbeb70175a5c1",
      "closedAt": "2022-10-20T12:33:41Z",
      "mergedAt": "2022-10-20T12:33:41Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "d84c43640366254fce8f4ccea4dfa798347dbd12"
      },
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "#184",
          "createdAt": "2022-10-14T14:16:31Z",
          "updatedAt": "2022-10-14T14:16:31Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "I think this issue needs to address text in Section on \"Chunk Handling\" also. ",
          "createdAt": "2022-10-18T13:48:55Z",
          "updatedAt": "2022-10-18T13:48:55Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "We also have to mitigate the Forward-TSN chunk defined by RFC 3758. As it is a full resolution TSN, it can be mitigated similar with a key change and revoke before the TSN space has wrapped.\r\n",
          "createdAt": "2022-10-18T13:53:51Z",
          "updatedAt": "2022-10-18T13:53:51Z"
        },
        {
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "body": "This sentence in Parallel DTLS connection needs to be fixed: \"here is also only a single SCTP-AUTH key exported per DTLS connection ensuring that there is clear mapping between the DTLS connection ID and the SCTP-AUTH security context for each key-id.\" \r\n\r\nand also in later paragraph\r\n\r\n\"Also, after the completion of the DTLS handshake, a new SCTP-AUTH key will be exported per [Section 4.8].\"\r\n",
          "createdAt": "2022-10-18T14:06:49Z",
          "updatedAt": "2022-10-18T14:10:38Z"
        },
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": " EXPORTER-DTLS-OVER-SCTP-CLIENT-WRITE\r\n EXPORTER-DTLS-OVER-SCTP-SERVER-WRITE\r\n\r\nor \r\n\r\n EXPORTER-DTLS-OVER-SCTP-CLIENT-SEND\r\n EXPORTER-DTLS-OVER-SCTP-SERVER-SEND\r\n \r\n (write and read keys is the terminology used by TLS)\r\n",
          "createdAt": "2022-10-20T08:02:51Z",
          "updatedAt": "2022-10-20T08:02:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5D9pnp",
          "commit": {
            "abbreviatedOid": "49820ed"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-13T07:41:51Z",
          "updatedAt": "2022-10-13T07:41:51Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5ENjAL",
          "commit": {
            "abbreviatedOid": "f9f7ef7"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "Some clarifications regarding key lifetime needed. Otherwise it looks good. ",
          "createdAt": "2022-10-17T15:39:05Z",
          "updatedAt": "2022-10-17T15:45:58Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "So the SCTP stack will cycle back on the TSN. It is the SCTP-AUTH key that MUST be retired before 2^32 TSN number from the first used with this key. ",
              "createdAt": "2022-10-17T15:39:05Z",
              "updatedAt": "2022-10-17T15:45:58Z"
            },
            {
              "originalPosition": 132,
              "body": "Should the \"zero (0)\" be used to make it clear when one talk about key identifier 0 above? ",
              "createdAt": "2022-10-17T15:44:21Z",
              "updatedAt": "2022-10-17T15:45:58Z"
            },
            {
              "originalPosition": 156,
              "body": "Should the requirement to retire the key before the TSN has wrapped once from the first TSN that contained a usage of this write SCTP-AUTH key be added here?",
              "createdAt": "2022-10-17T15:45:26Z",
              "updatedAt": "2022-10-17T15:45:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEtjg5s5EXI4N",
          "commit": {
            "abbreviatedOid": "f9f7ef7"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-19T06:29:00Z",
          "updatedAt": "2022-10-19T06:29:00Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "fixed",
              "createdAt": "2022-10-19T06:29:00Z",
              "updatedAt": "2022-10-19T06:29:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEtjg5s5EXI57",
          "commit": {
            "abbreviatedOid": "f9f7ef7"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-19T06:29:07Z",
          "updatedAt": "2022-10-19T06:29:08Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "fixed",
              "createdAt": "2022-10-19T06:29:07Z",
              "updatedAt": "2022-10-19T06:29:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEtjg5s5Eft7R",
          "commit": {
            "abbreviatedOid": "e5fa9ab"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-20T12:39:10Z",
          "updatedAt": "2022-10-20T12:39:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 187,
      "id": "PR_kwDOEtjg5s5A0RAa",
      "title": "Issie #186 - Clarify that COOKIE-ECHO and COOKIE-ACK are not authenticated",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/187",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#186 \r\n\r\nThere was a lot of duplicated MUST in the section. I shorted it. Please review.",
      "createdAt": "2022-10-14T13:17:12Z",
      "updatedAt": "2022-10-18T05:17:06Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "62e46264b5f144583885e8148391444364b4258a",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Issie-#186---Clarify-that-COOKIE-ECHO-and-COOKIE-ACK-are-not-authenticated",
      "headRefOid": "71c75b54efabf5a0c674c355f30e4f7caa7466e9",
      "closedAt": "2022-10-18T05:17:05Z",
      "mergedAt": "2022-10-18T05:17:05Z",
      "mergedBy": "emanjon",
      "mergeCommit": {
        "oid": "661870a0bbf499a1c1f5212e2d0e2d443f67e737"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5EGBZf",
          "commit": {
            "abbreviatedOid": "f93d23d"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "are sent in an authenticated way whcih makes sure that it is not possible for an\r\nshould be\r\nare sent in an authenticated way which makes sure that it is not possible for an",
          "createdAt": "2022-10-14T13:26:23Z",
          "updatedAt": "2022-10-14T13:26:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5EL_Rd",
          "commit": {
            "abbreviatedOid": "71c75b5"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-17T11:34:10Z",
          "updatedAt": "2022-10-17T11:34:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 188,
      "id": "PR_kwDOEtjg5s5A1Jbt",
      "title": "Issue #182 - AEAD limits",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/188",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "key limits was already mentioned. But not explicitly AEAD limits. As we are specifying a new mechanism (parallel connection) I think it makes sense to put the same requirements on DTLS 1.2 and DTLS 1.3. This simplifies implementation.",
      "createdAt": "2022-10-14T16:44:13Z",
      "updatedAt": "2022-10-18T05:15:52Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "62e46264b5f144583885e8148391444364b4258a",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Issue-#182---AEAD-limits",
      "headRefOid": "b8afa498b5e733e95ffa9baad28c457ce6d70471",
      "closedAt": "2022-10-18T05:15:52Z",
      "mergedAt": "2022-10-18T05:15:52Z",
      "mergedBy": "emanjon",
      "mergeCommit": {
        "oid": "a1b93469d58b0f4fa75c928b91883e30d81c038b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5EKM6Q",
          "commit": {
            "abbreviatedOid": "b8afa49"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-17T05:40:57Z",
          "updatedAt": "2022-10-17T05:40:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5EL-4Q",
          "commit": {
            "abbreviatedOid": "b8afa49"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-17T11:32:59Z",
          "updatedAt": "2022-10-17T11:32:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 190,
      "id": "PR_kwDOEtjg5s5A_waY",
      "title": "Aligns formulation and information in the IANA section",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/190",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Resolves issue #178. ",
      "createdAt": "2022-10-18T09:00:35Z",
      "updatedAt": "2022-10-19T07:32:25Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "36dbaadcabc30b46dc214e824fa754342f7bc31f",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue178-iana-alignment",
      "headRefOid": "b6820a3fcc49cde225f3d8bda728d9cdf8be4d44",
      "closedAt": "2022-10-19T07:32:20Z",
      "mergedAt": "2022-10-19T07:32:20Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "de3cab92d6544b85be4542648889d5ba7a28fb7d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5ERU29",
          "commit": {
            "abbreviatedOid": "b6820a3"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-18T09:07:04Z",
          "updatedAt": "2022-10-18T09:07:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5EUKb7",
          "commit": {
            "abbreviatedOid": "b6820a3"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-18T16:13:28Z",
          "updatedAt": "2022-10-18T16:13:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 191,
      "id": "PR_kwDOEtjg5s5BBbnP",
      "title": "Editorial fixes and reformulations from a reveiw up to DTLS/SCTP Control Messages",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/191",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-10-18T14:30:13Z",
      "updatedAt": "2022-10-19T07:32:52Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "36dbaadcabc30b46dc214e824fa754342f7bc31f",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "mw-edits",
      "headRefOid": "ae5a4b2e0731e51a9656d237c50bfd77bbe1667a",
      "closedAt": "2022-10-19T07:32:52Z",
      "mergedAt": "2022-10-19T07:32:52Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "f1de3a29e282691a0460230c05cb01cfe2bf2d6c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5ETeHI",
          "commit": {
            "abbreviatedOid": "ae5a4b2"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-18T14:35:35Z",
          "updatedAt": "2022-10-18T14:35:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5EUKI0",
          "commit": {
            "abbreviatedOid": "ae5a4b2"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-18T16:12:41Z",
          "updatedAt": "2022-10-18T16:12:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 192,
      "id": "PR_kwDOEtjg5s5BHP5b",
      "title": "Issue #144 - DTLS glare",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/192",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#144",
      "createdAt": "2022-10-19T14:17:22Z",
      "updatedAt": "2022-10-20T13:11:44Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "f1de3a29e282691a0460230c05cb01cfe2bf2d6c",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Issue-#144---DTLS-glare",
      "headRefOid": "d13bc96611348ea53b5bdaeae0640838e77b0a9b",
      "closedAt": "2022-10-20T13:11:39Z",
      "mergedAt": "2022-10-20T13:11:39Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "385f1875f00d7ad75aaaa92c93e47cadd1a7853f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5EaB7V",
          "commit": {
            "abbreviatedOid": "ee87192"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-19T14:19:45Z",
          "updatedAt": "2022-10-19T14:19:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5EaB_Z",
          "commit": {
            "abbreviatedOid": "ee87192"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-19T14:19:53Z",
          "updatedAt": "2022-10-19T14:19:53Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Why do we say \"full\" here?",
              "createdAt": "2022-10-19T14:19:53Z",
              "updatedAt": "2022-10-19T14:19:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEtjg5s5EexKZ",
          "commit": {
            "abbreviatedOid": "ee87192"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-20T09:42:48Z",
          "updatedAt": "2022-10-20T09:42:48Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think the full can be removed, there are no particular reason. Any complete handshake should be sufficient here. ",
              "createdAt": "2022-10-20T09:42:48Z",
              "updatedAt": "2022-10-20T09:42:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOEtjg5s5Ef618",
          "commit": {
            "abbreviatedOid": "d13bc96"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-20T13:11:33Z",
          "updatedAt": "2022-10-20T13:11:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 193,
      "id": "PR_kwDOEtjg5s5BKtOJ",
      "title": "Issue #189 Terminology adaptated",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/193",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-10-20T07:08:06Z",
      "updatedAt": "2022-10-20T12:50:35Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "d84c43640366254fce8f4ccea4dfa798347dbd12",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue189",
      "headRefOid": "f18404cf5c203d836c9a436edc52724e9c142ecc",
      "closedAt": "2022-10-20T12:50:31Z",
      "mergedAt": "2022-10-20T12:50:31Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "b8cee3ed9541df021b6a4c935ecf767136ca393d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5EevOl",
          "commit": {
            "abbreviatedOid": "6e5562a"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-20T09:37:42Z",
          "updatedAt": "2022-10-20T09:41:18Z",
          "comments": [
            {
              "originalPosition": 141,
              "body": "This sentence references the actual message name, thus further reformulation needed. ",
              "createdAt": "2022-10-20T09:37:43Z",
              "updatedAt": "2022-10-20T09:41:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 194,
      "id": "PR_kwDOEtjg5s5BMYOV",
      "title": "Issue #189",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/194",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixed exponential notation",
      "createdAt": "2022-10-20T13:00:40Z",
      "updatedAt": "2022-10-20T13:08:45Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "b8cee3ed9541df021b6a4c935ecf767136ca393d",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "issue189",
      "headRefOid": "2d36897545cf6b412f39697829b9ef106d8dd0c7",
      "closedAt": "2022-10-20T13:08:45Z",
      "mergedAt": "2022-10-20T13:08:45Z",
      "mergedBy": "teiclap",
      "mergeCommit": {
        "oid": "18101b3ebce89556d50789e7bf06ff82de4e4620"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5Ef4uZ",
          "commit": {
            "abbreviatedOid": "2d36897"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-20T13:06:34Z",
          "updatedAt": "2022-10-20T13:06:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 195,
      "id": "PR_kwDOEtjg5s5BSubM",
      "title": "Issue #184 - When to use DTLS and SCTP AUTH",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/195",
      "state": "MERGED",
      "author": "emanjon",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#184\r\n\r\n- MUST NOT use DTLS connection to protect data before other endpoint has been authenticated\r\n- MUST NOT use key id zero for ULP DATA.\r\n- ",
      "createdAt": "2022-10-21T14:46:51Z",
      "updatedAt": "2022-10-24T09:36:04Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "edb213403d807c75c0cd77b1f0f96111654740be",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "Issue-#184---When-to-use-DTLS-and-SCTP-AUTH",
      "headRefOid": "e4000dddbeb45cb0c1482ab9ddb141631f751fc5",
      "closedAt": "2022-10-24T09:35:33Z",
      "mergedAt": "2022-10-24T09:35:32Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "9ae4558cce24b515a86d022c383951a71be03e12"
      },
      "comments": [
        {
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "body": "Spelled out data confidentiality, data origin authentication, data integrity protection, and data replay protection in one place in the document",
          "createdAt": "2022-10-21T14:48:56Z",
          "updatedAt": "2022-10-21T14:48:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5Etu-P",
          "commit": {
            "abbreviatedOid": "e4000dd"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-24T09:34:47Z",
          "updatedAt": "2022-10-24T09:34:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 196,
      "id": "PR_kwDOEtjg5s5BZnBl",
      "title": "Changed to SCTP-AUTH and rewrapped some paragraphs.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/196",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "This reverts the change of SCTP-AUTH to SCTP AUTH as discussed in issue #189 ",
      "createdAt": "2022-10-24T09:51:33Z",
      "updatedAt": "2022-10-24T11:07:27Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "9ae4558cce24b515a86d022c383951a71be03e12",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "term-sctp-auth",
      "headRefOid": "70aa5f292a460e7ddee2e1647d0cadacb6dddbf0",
      "closedAt": "2022-10-24T11:07:24Z",
      "mergedAt": "2022-10-24T11:07:24Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "c7936b673ddf6f3a778dbd34f3843036cfedc927"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5Et9ub",
          "commit": {
            "abbreviatedOid": "70aa5f2"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-24T10:22:30Z",
          "updatedAt": "2022-10-24T10:22:30Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5Et__9",
          "commit": {
            "abbreviatedOid": "70aa5f2"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-24T10:29:55Z",
          "updatedAt": "2022-10-24T10:29:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 198,
      "id": "PR_kwDOEtjg5s5BaR7Y",
      "title": "Several small fixes in the text.",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/198",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "These are minor text changes to address issues found in review. ",
      "createdAt": "2022-10-24T12:30:26Z",
      "updatedAt": "2022-10-24T14:45:21Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "c7936b673ddf6f3a778dbd34f3843036cfedc927",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "mw-edits",
      "headRefOid": "c8c4e3f53542ca7ed7858f99179e6f33d2089b05",
      "closedAt": "2022-10-24T14:45:18Z",
      "mergedAt": "2022-10-24T14:45:18Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "312cf637a2898015e4bce4e179c877738f68a44b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5EulMN",
          "commit": {
            "abbreviatedOid": "6fb3cfa"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-24T12:33:02Z",
          "updatedAt": "2022-10-24T12:33:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5EuogB",
          "commit": {
            "abbreviatedOid": "3d9f443"
          },
          "author": "emanjon",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-24T12:43:21Z",
          "updatedAt": "2022-10-24T12:43:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 202,
      "id": "PR_kwDOEtjg5s5cn09g",
      "title": "Added some text related to the immaturity towards replay attacks",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/202",
      "state": "MERGED",
      "author": "teiclap",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Did some work explaining why this is still not good enough",
      "createdAt": "2023-10-12T11:19:39Z",
      "updatedAt": "2023-10-23T09:03:18Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "d066ddec1518c62bb8fecad2e27b721b836c2590",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "security_props",
      "headRefOid": "47f938e1826065450d7b03019d0ae33aee6e1778",
      "closedAt": "2023-10-23T09:03:12Z",
      "mergedAt": "2023-10-23T09:03:12Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "45b405a8a7740b0c01976bdd32bfe1ed53c6dbb6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5kJ95l",
          "commit": {
            "abbreviatedOid": "85bd93e"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I agree to your version (and you can remove the latin if you wish)",
          "createdAt": "2023-10-16T15:35:00Z",
          "updatedAt": "2023-10-16T15:35:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5k2pX0",
          "commit": {
            "abbreviatedOid": "47f938e"
          },
          "author": "gloinul",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T09:02:38Z",
          "updatedAt": "2023-10-23T09:02:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 203,
      "id": "PR_kwDOEtjg5s5djQgQ",
      "title": "Editorial pass to align text based on the updated SCTP-AUTH mitigation and properties. ",
      "url": "https://github.com/gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis/pull/203",
      "state": "MERGED",
      "author": "gloinul",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-23T16:26:51Z",
      "updatedAt": "2023-10-23T18:12:01Z",
      "baseRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "baseRefName": "main",
      "baseRefOid": "45b405a8a7740b0c01976bdd32bfe1ed53c6dbb6",
      "headRepository": "gloinul/draft-westerlund-tsvwg-dtls-over-sctp-bis",
      "headRefName": "mw-edits",
      "headRefOid": "2927f8954918fce54cfb86c5decb7e231e66d6d0",
      "closedAt": "2023-10-23T18:12:00Z",
      "mergedAt": "2023-10-23T18:12:00Z",
      "mergedBy": "gloinul",
      "mergeCommit": {
        "oid": "7494af3c0f11ff62f69a82937c1f703ee60d4ffd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOEtjg5s5k6cxz",
          "commit": {
            "abbreviatedOid": "2927f89"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T16:50:20Z",
          "updatedAt": "2023-10-23T16:50:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOEtjg5s5k63_u",
          "commit": {
            "abbreviatedOid": "2927f89"
          },
          "author": "teiclap",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-10-23T17:47:09Z",
          "updatedAt": "2023-10-23T17:47:09Z",
          "comments": []
        }
      ]
    }
  ]
}